"use strict";(self.webpackChunkapp_scaffold=self.webpackChunkapp_scaffold||[]).push([[2848],{"./node_modules/openai/index.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function __classPrivateFieldSet(receiver,state,value,kind,f){if("m"===kind)throw new TypeError("Private method is not writable");if("a"===kind&&!f)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof state?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===kind?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value}function __classPrivateFieldGet(receiver,state,kind,f){if("a"===kind&&!f)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof state?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===kind?f:"a"===kind?f.call(receiver):f?f.value:state.get(receiver)}__webpack_require__.d(__webpack_exports__,{Ay:()=>OpenAI});let uuid4=function(){const{crypto}=globalThis;if(crypto?.randomUUID)return uuid4=crypto.randomUUID.bind(crypto),crypto.randomUUID();const u8=new Uint8Array(1),randomByte=crypto?()=>crypto.getRandomValues(u8)[0]:()=>255*Math.random()&255;return"10000000-1000-4000-8000-100000000000".replace(/[018]/g,c=>(+c^randomByte()&15>>+c/4).toString(16))};function isAbortError(err){return"object"==typeof err&&null!==err&&("name"in err&&"AbortError"===err.name||"message"in err&&String(err.message).includes("FetchRequestCanceledException"))}const castToError=err=>{if(err instanceof Error)return err;if("object"==typeof err&&null!==err){try{if("[object Error]"===Object.prototype.toString.call(err)){const error=new Error(err.message,err.cause?{cause:err.cause}:{});return err.stack&&(error.stack=err.stack),err.cause&&!error.cause&&(error.cause=err.cause),err.name&&(error.name=err.name),error}}catch{}try{return new Error(JSON.stringify(err))}catch{}}return new Error(err)};class error_OpenAIError extends Error{}class APIError extends error_OpenAIError{constructor(status,error,message,headers){super(`${APIError.makeMessage(status,error,message)}`),this.status=status,this.headers=headers,this.requestID=headers?.get("x-request-id"),this.error=error;const data=error;this.code=data?.code,this.param=data?.param,this.type=data?.type}static makeMessage(status,error,message){const msg=error?.message?"string"==typeof error.message?error.message:JSON.stringify(error.message):error?JSON.stringify(error):message;return status&&msg?`${status} ${msg}`:status?`${status} status code (no body)`:msg||"(no status code or body)"}static generate(status,errorResponse,message,headers){if(!status||!headers)return new APIConnectionError({message,cause:castToError(errorResponse)});const error=errorResponse?.error;return 400===status?new BadRequestError(status,error,message,headers):401===status?new AuthenticationError(status,error,message,headers):403===status?new PermissionDeniedError(status,error,message,headers):404===status?new NotFoundError(status,error,message,headers):409===status?new ConflictError(status,error,message,headers):422===status?new UnprocessableEntityError(status,error,message,headers):429===status?new RateLimitError(status,error,message,headers):status>=500?new InternalServerError(status,error,message,headers):new APIError(status,error,message,headers)}}class APIUserAbortError extends APIError{constructor({message}={}){super(void 0,void 0,message||"Request was aborted.",void 0)}}class APIConnectionError extends APIError{constructor({message,cause}){super(void 0,void 0,message||"Connection error.",void 0),cause&&(this.cause=cause)}}class APIConnectionTimeoutError extends APIConnectionError{constructor({message}={}){super({message:message??"Request timed out."})}}class BadRequestError extends APIError{}class AuthenticationError extends APIError{}class PermissionDeniedError extends APIError{}class NotFoundError extends APIError{}class ConflictError extends APIError{}class UnprocessableEntityError extends APIError{}class RateLimitError extends APIError{}class InternalServerError extends APIError{}class LengthFinishReasonError extends error_OpenAIError{constructor(){super("Could not parse response content as the length limit was reached")}}class ContentFilterFinishReasonError extends error_OpenAIError{constructor(){super("Could not parse response content as the request was rejected by the content filter")}}class InvalidWebhookSignatureError extends Error{constructor(message){super(message)}}const startsWithSchemeRegexp=/^[a-z][a-z0-9+.-]*:/i;let values_isArray=val=>(values_isArray=Array.isArray,values_isArray(val)),isReadonlyArray=values_isArray;function isObj(obj){return null!=obj&&"object"==typeof obj&&!Array.isArray(obj)}const sleep=ms=>new Promise(resolve=>setTimeout(resolve,ms));const getPlatformProperties=()=>{const detectedPlatform=function getDetectedPlatform(){return"undefined"!=typeof Deno&&null!=Deno.build?"deno":"undefined"!=typeof EdgeRuntime?"edge":"[object process]"===Object.prototype.toString.call(void 0!==globalThis.process?globalThis.process:0)?"node":"unknown"}();if("deno"===detectedPlatform)return{"X-Stainless-Lang":"js","X-Stainless-Package-Version":"5.8.2","X-Stainless-OS":normalizePlatform(Deno.build.os),"X-Stainless-Arch":normalizeArch(Deno.build.arch),"X-Stainless-Runtime":"deno","X-Stainless-Runtime-Version":"string"==typeof Deno.version?Deno.version:Deno.version?.deno??"unknown"};if("undefined"!=typeof EdgeRuntime)return{"X-Stainless-Lang":"js","X-Stainless-Package-Version":"5.8.2","X-Stainless-OS":"Unknown","X-Stainless-Arch":`other:${EdgeRuntime}`,"X-Stainless-Runtime":"edge","X-Stainless-Runtime-Version":globalThis.process.version};if("node"===detectedPlatform)return{"X-Stainless-Lang":"js","X-Stainless-Package-Version":"5.8.2","X-Stainless-OS":normalizePlatform(globalThis.process.platform??"unknown"),"X-Stainless-Arch":normalizeArch(globalThis.process.arch??"unknown"),"X-Stainless-Runtime":"node","X-Stainless-Runtime-Version":globalThis.process.version??"unknown"};const browserInfo=function getBrowserInfo(){if("undefined"==typeof navigator||!navigator)return null;const browserPatterns=[{key:"edge",pattern:/Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/},{key:"ie",pattern:/MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/},{key:"ie",pattern:/Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/},{key:"chrome",pattern:/Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/},{key:"firefox",pattern:/Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/},{key:"safari",pattern:/(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/}];for(const{key,pattern}of browserPatterns){const match=pattern.exec(navigator.userAgent);if(match){return{browser:key,version:`${match[1]||0}.${match[2]||0}.${match[3]||0}`}}}return null}();return browserInfo?{"X-Stainless-Lang":"js","X-Stainless-Package-Version":"5.8.2","X-Stainless-OS":"Unknown","X-Stainless-Arch":"unknown","X-Stainless-Runtime":`browser:${browserInfo.browser}`,"X-Stainless-Runtime-Version":browserInfo.version}:{"X-Stainless-Lang":"js","X-Stainless-Package-Version":"5.8.2","X-Stainless-OS":"Unknown","X-Stainless-Arch":"unknown","X-Stainless-Runtime":"unknown","X-Stainless-Runtime-Version":"unknown"}};const normalizeArch=arch=>"x32"===arch?"x32":"x86_64"===arch||"x64"===arch?"x64":"arm"===arch?"arm":"aarch64"===arch||"arm64"===arch?"arm64":arch?`other:${arch}`:"unknown",normalizePlatform=platform=>(platform=platform.toLowerCase()).includes("ios")?"iOS":"android"===platform?"Android":"darwin"===platform?"MacOS":"win32"===platform?"Windows":"freebsd"===platform?"FreeBSD":"openbsd"===platform?"OpenBSD":"linux"===platform?"Linux":platform?`Other:${platform}`:"Unknown";let _platformHeaders;function makeReadableStream(...args){const ReadableStream=globalThis.ReadableStream;if(void 0===ReadableStream)throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");return new ReadableStream(...args)}function ReadableStreamFrom(iterable){let iter=Symbol.asyncIterator in iterable?iterable[Symbol.asyncIterator]():iterable[Symbol.iterator]();return makeReadableStream({start(){},async pull(controller){const{done,value}=await iter.next();done?controller.close():controller.enqueue(value)},async cancel(){await(iter.return?.())}})}function ReadableStreamToAsyncIterable(stream){if(stream[Symbol.asyncIterator])return stream;const reader=stream.getReader();return{async next(){try{const result=await reader.read();return result?.done&&reader.releaseLock(),result}catch(e){throw reader.releaseLock(),e}},async return(){const cancelPromise=reader.cancel();return reader.releaseLock(),await cancelPromise,{done:!0,value:void 0}},[Symbol.asyncIterator](){return this}}}const FallbackEncoder=({headers,body})=>({bodyHeaders:{"content-type":"application/json"},body:JSON.stringify(body)}),default_formatter=v=>String(v),formatters={RFC1738:v=>String(v).replace(/%20/g,"+"),RFC3986:default_formatter};let has=(obj,key)=>(has=Object.hasOwn??Function.prototype.call.bind(Object.prototype.hasOwnProperty),has(obj,key));const hex_table=(()=>{const array=[];for(let i=0;i<256;++i)array.push("%"+((i<16?"0":"")+i.toString(16)).toUpperCase());return array})();function maybe_map(val,fn){if(values_isArray(val)){const mapped=[];for(let i=0;i<val.length;i+=1)mapped.push(fn(val[i]));return mapped}return fn(val)}const array_prefix_generators={brackets:prefix=>String(prefix)+"[]",comma:"comma",indices:(prefix,key)=>String(prefix)+"["+key+"]",repeat:prefix=>String(prefix)},push_to_array=function(arr,value_or_array){Array.prototype.push.apply(arr,values_isArray(value_or_array)?value_or_array:[value_or_array])};let toISOString;const defaults={addQueryPrefix:!1,allowDots:!1,allowEmptyArrays:!1,arrayFormat:"indices",charset:"utf-8",charsetSentinel:!1,delimiter:"&",encode:!0,encodeDotInKeys:!1,encoder:(str,_defaultEncoder,charset,_kind,format)=>{if(0===str.length)return str;let string=str;if("symbol"==typeof str?string=Symbol.prototype.toString.call(str):"string"!=typeof str&&(string=String(str)),"iso-8859-1"===charset)return escape(string).replace(/%u[0-9a-f]{4}/gi,function($0){return"%26%23"+parseInt($0.slice(2),16)+"%3B"});let out="";for(let j=0;j<string.length;j+=1024){const segment=string.length>=1024?string.slice(j,j+1024):string,arr=[];for(let i=0;i<segment.length;++i){let c=segment.charCodeAt(i);45===c||46===c||95===c||126===c||c>=48&&c<=57||c>=65&&c<=90||c>=97&&c<=122||"RFC1738"===format&&(40===c||41===c)?arr[arr.length]=segment.charAt(i):c<128?arr[arr.length]=hex_table[c]:c<2048?arr[arr.length]=hex_table[192|c>>6]+hex_table[128|63&c]:c<55296||c>=57344?arr[arr.length]=hex_table[224|c>>12]+hex_table[128|c>>6&63]+hex_table[128|63&c]:(i+=1,c=65536+((1023&c)<<10|1023&segment.charCodeAt(i)),arr[arr.length]=hex_table[240|c>>18]+hex_table[128|c>>12&63]+hex_table[128|c>>6&63]+hex_table[128|63&c])}out+=arr.join("")}return out},encodeValuesOnly:!1,format:"RFC3986",formatter:default_formatter,indices:!1,serializeDate:date=>(toISOString??(toISOString=Function.prototype.call.bind(Date.prototype.toISOString)))(date),skipNulls:!1,strictNullHandling:!1};const sentinel={};function inner_stringify(object,prefix,generateArrayPrefix,commaRoundTrip,allowEmptyArrays,strictNullHandling,skipNulls,encodeDotInKeys,encoder,filter,sort,allowDots,serializeDate,format,formatter,encodeValuesOnly,charset,sideChannel){let obj=object,tmp_sc=sideChannel,step=0,find_flag=!1;for(;void 0!==(tmp_sc=tmp_sc.get(sentinel))&&!find_flag;){const pos=tmp_sc.get(object);if(step+=1,void 0!==pos){if(pos===step)throw new RangeError("Cyclic object value");find_flag=!0}void 0===tmp_sc.get(sentinel)&&(step=0)}if("function"==typeof filter?obj=filter(prefix,obj):obj instanceof Date?obj=serializeDate?.(obj):"comma"===generateArrayPrefix&&values_isArray(obj)&&(obj=maybe_map(obj,function(value){return value instanceof Date?serializeDate?.(value):value})),null===obj){if(strictNullHandling)return encoder&&!encodeValuesOnly?encoder(prefix,defaults.encoder,charset,"key",format):prefix;obj=""}if(function is_non_nullish_primitive(v){return"string"==typeof v||"number"==typeof v||"boolean"==typeof v||"symbol"==typeof v||"bigint"==typeof v}(obj)||function is_buffer(obj){return!(!obj||"object"!=typeof obj||!(obj.constructor&&obj.constructor.isBuffer&&obj.constructor.isBuffer(obj)))}(obj)){if(encoder){const key_value=encodeValuesOnly?prefix:encoder(prefix,defaults.encoder,charset,"key",format);return[formatter?.(key_value)+"="+formatter?.(encoder(obj,defaults.encoder,charset,"value",format))]}return[formatter?.(prefix)+"="+formatter?.(String(obj))]}const values=[];if(void 0===obj)return values;let obj_keys;if("comma"===generateArrayPrefix&&values_isArray(obj))encodeValuesOnly&&encoder&&(obj=maybe_map(obj,encoder)),obj_keys=[{value:obj.length>0?obj.join(",")||null:void 0}];else if(values_isArray(filter))obj_keys=filter;else{const keys=Object.keys(obj);obj_keys=sort?keys.sort(sort):keys}const encoded_prefix=encodeDotInKeys?String(prefix).replace(/\./g,"%2E"):String(prefix),adjusted_prefix=commaRoundTrip&&values_isArray(obj)&&1===obj.length?encoded_prefix+"[]":encoded_prefix;if(allowEmptyArrays&&values_isArray(obj)&&0===obj.length)return adjusted_prefix+"[]";for(let j=0;j<obj_keys.length;++j){const key=obj_keys[j],value="object"==typeof key&&void 0!==key.value?key.value:obj[key];if(skipNulls&&null===value)continue;const encoded_key=allowDots&&encodeDotInKeys?key.replace(/\./g,"%2E"):key,key_prefix=values_isArray(obj)?"function"==typeof generateArrayPrefix?generateArrayPrefix(adjusted_prefix,encoded_key):adjusted_prefix:adjusted_prefix+(allowDots?"."+encoded_key:"["+encoded_key+"]");sideChannel.set(object,step);const valueSideChannel=new WeakMap;valueSideChannel.set(sentinel,sideChannel),push_to_array(values,inner_stringify(value,key_prefix,generateArrayPrefix,commaRoundTrip,allowEmptyArrays,strictNullHandling,skipNulls,encodeDotInKeys,"comma"===generateArrayPrefix&&encodeValuesOnly&&values_isArray(obj)?null:encoder,filter,sort,allowDots,serializeDate,format,formatter,encodeValuesOnly,charset,valueSideChannel))}return values}function stringify(object,opts={}){let obj=object;const options=function normalize_stringify_options(opts=defaults){if(void 0!==opts.allowEmptyArrays&&"boolean"!=typeof opts.allowEmptyArrays)throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");if(void 0!==opts.encodeDotInKeys&&"boolean"!=typeof opts.encodeDotInKeys)throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");if(null!==opts.encoder&&void 0!==opts.encoder&&"function"!=typeof opts.encoder)throw new TypeError("Encoder has to be a function.");const charset=opts.charset||defaults.charset;if(void 0!==opts.charset&&"utf-8"!==opts.charset&&"iso-8859-1"!==opts.charset)throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");let format="RFC3986";if(void 0!==opts.format){if(!has(formatters,opts.format))throw new TypeError("Unknown format option provided.");format=opts.format}const formatter=formatters[format];let arrayFormat,filter=defaults.filter;if(("function"==typeof opts.filter||values_isArray(opts.filter))&&(filter=opts.filter),arrayFormat=opts.arrayFormat&&opts.arrayFormat in array_prefix_generators?opts.arrayFormat:"indices"in opts?opts.indices?"indices":"repeat":defaults.arrayFormat,"commaRoundTrip"in opts&&"boolean"!=typeof opts.commaRoundTrip)throw new TypeError("`commaRoundTrip` must be a boolean, or absent");const allowDots=void 0===opts.allowDots?1==!!opts.encodeDotInKeys||defaults.allowDots:!!opts.allowDots;return{addQueryPrefix:"boolean"==typeof opts.addQueryPrefix?opts.addQueryPrefix:defaults.addQueryPrefix,allowDots,allowEmptyArrays:"boolean"==typeof opts.allowEmptyArrays?!!opts.allowEmptyArrays:defaults.allowEmptyArrays,arrayFormat,charset,charsetSentinel:"boolean"==typeof opts.charsetSentinel?opts.charsetSentinel:defaults.charsetSentinel,commaRoundTrip:!!opts.commaRoundTrip,delimiter:void 0===opts.delimiter?defaults.delimiter:opts.delimiter,encode:"boolean"==typeof opts.encode?opts.encode:defaults.encode,encodeDotInKeys:"boolean"==typeof opts.encodeDotInKeys?opts.encodeDotInKeys:defaults.encodeDotInKeys,encoder:"function"==typeof opts.encoder?opts.encoder:defaults.encoder,encodeValuesOnly:"boolean"==typeof opts.encodeValuesOnly?opts.encodeValuesOnly:defaults.encodeValuesOnly,filter,format,formatter,serializeDate:"function"==typeof opts.serializeDate?opts.serializeDate:defaults.serializeDate,skipNulls:"boolean"==typeof opts.skipNulls?opts.skipNulls:defaults.skipNulls,sort:"function"==typeof opts.sort?opts.sort:null,strictNullHandling:"boolean"==typeof opts.strictNullHandling?opts.strictNullHandling:defaults.strictNullHandling}}(opts);let obj_keys,filter;"function"==typeof options.filter?(filter=options.filter,obj=filter("",obj)):values_isArray(options.filter)&&(filter=options.filter,obj_keys=filter);const keys=[];if("object"!=typeof obj||null===obj)return"";const generateArrayPrefix=array_prefix_generators[options.arrayFormat],commaRoundTrip="comma"===generateArrayPrefix&&options.commaRoundTrip;obj_keys||(obj_keys=Object.keys(obj)),options.sort&&obj_keys.sort(options.sort);const sideChannel=new WeakMap;for(let i=0;i<obj_keys.length;++i){const key=obj_keys[i];options.skipNulls&&null===obj[key]||push_to_array(keys,inner_stringify(obj[key],key,generateArrayPrefix,commaRoundTrip,options.allowEmptyArrays,options.strictNullHandling,options.skipNulls,options.encodeDotInKeys,options.encode?options.encoder:null,options.filter,options.sort,options.allowDots,options.serializeDate,options.format,options.formatter,options.encodeValuesOnly,options.charset,sideChannel))}const joined=keys.join(options.delimiter);let prefix=!0===options.addQueryPrefix?"?":"";return options.charsetSentinel&&("iso-8859-1"===options.charset?prefix+="utf8=%26%2310003%3B&":prefix+="utf8=%E2%9C%93&"),joined.length>0?prefix+joined:""}let encodeUTF8_,decodeUTF8_;function bytes_encodeUTF8(str){let encoder;return(encodeUTF8_??(encoder=new globalThis.TextEncoder,encodeUTF8_=encoder.encode.bind(encoder)))(str)}function decodeUTF8(bytes){let decoder;return(decodeUTF8_??(decoder=new globalThis.TextDecoder,decodeUTF8_=decoder.decode.bind(decoder)))(bytes)}var _LineDecoder_buffer,_LineDecoder_carriageReturnIndex;class LineDecoder{constructor(){_LineDecoder_buffer.set(this,void 0),_LineDecoder_carriageReturnIndex.set(this,void 0),__classPrivateFieldSet(this,_LineDecoder_buffer,new Uint8Array,"f"),__classPrivateFieldSet(this,_LineDecoder_carriageReturnIndex,null,"f")}decode(chunk){if(null==chunk)return[];const binaryChunk=chunk instanceof ArrayBuffer?new Uint8Array(chunk):"string"==typeof chunk?bytes_encodeUTF8(chunk):chunk;__classPrivateFieldSet(this,_LineDecoder_buffer,function concatBytes(buffers){let length=0;for(const buffer of buffers)length+=buffer.length;const output=new Uint8Array(length);let index=0;for(const buffer of buffers)output.set(buffer,index),index+=buffer.length;return output}([__classPrivateFieldGet(this,_LineDecoder_buffer,"f"),binaryChunk]),"f");const lines=[];let patternIndex;for(;null!=(patternIndex=findNewlineIndex(__classPrivateFieldGet(this,_LineDecoder_buffer,"f"),__classPrivateFieldGet(this,_LineDecoder_carriageReturnIndex,"f")));){if(patternIndex.carriage&&null==__classPrivateFieldGet(this,_LineDecoder_carriageReturnIndex,"f")){__classPrivateFieldSet(this,_LineDecoder_carriageReturnIndex,patternIndex.index,"f");continue}if(null!=__classPrivateFieldGet(this,_LineDecoder_carriageReturnIndex,"f")&&(patternIndex.index!==__classPrivateFieldGet(this,_LineDecoder_carriageReturnIndex,"f")+1||patternIndex.carriage)){lines.push(decodeUTF8(__classPrivateFieldGet(this,_LineDecoder_buffer,"f").subarray(0,__classPrivateFieldGet(this,_LineDecoder_carriageReturnIndex,"f")-1))),__classPrivateFieldSet(this,_LineDecoder_buffer,__classPrivateFieldGet(this,_LineDecoder_buffer,"f").subarray(__classPrivateFieldGet(this,_LineDecoder_carriageReturnIndex,"f")),"f"),__classPrivateFieldSet(this,_LineDecoder_carriageReturnIndex,null,"f");continue}const endIndex=null!==__classPrivateFieldGet(this,_LineDecoder_carriageReturnIndex,"f")?patternIndex.preceding-1:patternIndex.preceding,line=decodeUTF8(__classPrivateFieldGet(this,_LineDecoder_buffer,"f").subarray(0,endIndex));lines.push(line),__classPrivateFieldSet(this,_LineDecoder_buffer,__classPrivateFieldGet(this,_LineDecoder_buffer,"f").subarray(patternIndex.index),"f"),__classPrivateFieldSet(this,_LineDecoder_carriageReturnIndex,null,"f")}return lines}flush(){return __classPrivateFieldGet(this,_LineDecoder_buffer,"f").length?this.decode("\n"):[]}}function findNewlineIndex(buffer,startIndex){for(let i=startIndex??0;i<buffer.length;i++){if(10===buffer[i])return{preceding:i,index:i+1,carriage:!1};if(13===buffer[i])return{preceding:i,index:i+1,carriage:!0}}return null}function findDoubleNewlineIndex(buffer){for(let i=0;i<buffer.length-1;i++){if(10===buffer[i]&&10===buffer[i+1])return i+2;if(13===buffer[i]&&13===buffer[i+1])return i+2;if(13===buffer[i]&&10===buffer[i+1]&&i+3<buffer.length&&13===buffer[i+2]&&10===buffer[i+3])return i+4}return-1}_LineDecoder_buffer=new WeakMap,_LineDecoder_carriageReturnIndex=new WeakMap,LineDecoder.NEWLINE_CHARS=new Set(["\n","\r"]),LineDecoder.NEWLINE_REGEXP=/\r\n|[\n\r]/g;var console=__webpack_require__("./node_modules/console-browserify/index.js");class Stream{constructor(iterator,controller){this.iterator=iterator,this.controller=controller}static fromSSEResponse(response,controller){let consumed=!1;return new Stream(async function*iterator(){if(consumed)throw new error_OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");consumed=!0;let done=!1;try{for await(const sse of async function*_iterSSEMessages(response,controller){if(!response.body){if(controller.abort(),void 0!==globalThis.navigator&&"ReactNative"===globalThis.navigator.product)throw new error_OpenAIError("The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api");throw new error_OpenAIError("Attempted to iterate over a response with no body")}const sseDecoder=new SSEDecoder,lineDecoder=new LineDecoder,iter=ReadableStreamToAsyncIterable(response.body);for await(const sseChunk of async function*iterSSEChunks(iterator){let data=new Uint8Array;for await(const chunk of iterator){if(null==chunk)continue;const binaryChunk=chunk instanceof ArrayBuffer?new Uint8Array(chunk):"string"==typeof chunk?bytes_encodeUTF8(chunk):chunk;let patternIndex,newData=new Uint8Array(data.length+binaryChunk.length);for(newData.set(data),newData.set(binaryChunk,data.length),data=newData;-1!==(patternIndex=findDoubleNewlineIndex(data));)yield data.slice(0,patternIndex),data=data.slice(patternIndex)}data.length>0&&(yield data)}(iter))for(const line of lineDecoder.decode(sseChunk)){const sse=sseDecoder.decode(line);sse&&(yield sse)}for(const line of lineDecoder.flush()){const sse=sseDecoder.decode(line);sse&&(yield sse)}}(response,controller))if(!done)if(sse.data.startsWith("[DONE]"))done=!0;else if(null===sse.event||sse.event.startsWith("response.")||sse.event.startsWith("transcript.")){let data;try{data=JSON.parse(sse.data)}catch(e){throw console.error("Could not parse message into JSON:",sse.data),console.error("From chunk:",sse.raw),e}if(data&&data.error)throw new APIError(void 0,data.error,void 0,response.headers);yield data}else{let data;try{data=JSON.parse(sse.data)}catch(e){throw console.error("Could not parse message into JSON:",sse.data),console.error("From chunk:",sse.raw),e}if("error"==sse.event)throw new APIError(void 0,data.error,data.message,void 0);yield{event:sse.event,data}}done=!0}catch(e){if(isAbortError(e))return;throw e}finally{done||controller.abort()}},controller)}static fromReadableStream(readableStream,controller){let consumed=!1;return new Stream(async function*iterator(){if(consumed)throw new error_OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");consumed=!0;let done=!1;try{for await(const line of async function*iterLines(){const lineDecoder=new LineDecoder,iter=ReadableStreamToAsyncIterable(readableStream);for await(const chunk of iter)for(const line of lineDecoder.decode(chunk))yield line;for(const line of lineDecoder.flush())yield line}())done||line&&(yield JSON.parse(line));done=!0}catch(e){if(isAbortError(e))return;throw e}finally{done||controller.abort()}},controller)}[Symbol.asyncIterator](){return this.iterator()}tee(){const left=[],right=[],iterator=this.iterator(),teeIterator=queue=>({next:()=>{if(0===queue.length){const result=iterator.next();left.push(result),right.push(result)}return queue.shift()}});return[new Stream(()=>teeIterator(left),this.controller),new Stream(()=>teeIterator(right),this.controller)]}toReadableStream(){const self=this;let iter;return makeReadableStream({async start(){iter=self[Symbol.asyncIterator]()},async pull(ctrl){try{const{value,done}=await iter.next();if(done)return ctrl.close();const bytes=bytes_encodeUTF8(JSON.stringify(value)+"\n");ctrl.enqueue(bytes)}catch(err){ctrl.error(err)}},async cancel(){await(iter.return?.())}})}}class SSEDecoder{constructor(){this.event=null,this.data=[],this.chunks=[]}decode(line){if(line.endsWith("\r")&&(line=line.substring(0,line.length-1)),!line){if(!this.event&&!this.data.length)return null;const sse={event:this.event,data:this.data.join("\n"),raw:this.chunks};return this.event=null,this.data=[],this.chunks=[],sse}if(this.chunks.push(line),line.startsWith(":"))return null;let[fieldname,_,value]=function partition(str,delimiter){const index=str.indexOf(delimiter);if(-1!==index)return[str.substring(0,index),delimiter,str.substring(index+delimiter.length)];return[str,"",""]}(line,":");return value.startsWith(" ")&&(value=value.substring(1)),"event"===fieldname?this.event=value:"data"===fieldname&&this.data.push(value),null}}const levelNumbers={off:0,error:200,warn:300,info:400,debug:500},parseLogLevel=(maybeLevel,sourceName,client)=>{if(maybeLevel)return function hasOwn(obj,key){return Object.prototype.hasOwnProperty.call(obj,key)}(levelNumbers,maybeLevel)?maybeLevel:void loggerFor(client).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`)};function noop(){}function makeLogFn(fnLevel,logger,logLevel){return!logger||levelNumbers[fnLevel]>levelNumbers[logLevel]?noop:logger[fnLevel].bind(logger)}const noopLogger={error:noop,warn:noop,info:noop,debug:noop};let cachedLoggers=new WeakMap;function loggerFor(client){const logger=client.logger,logLevel=client.logLevel??"off";if(!logger)return noopLogger;const cachedLogger=cachedLoggers.get(logger);if(cachedLogger&&cachedLogger[0]===logLevel)return cachedLogger[1];const levelLogger={error:makeLogFn("error",logger,logLevel),warn:makeLogFn("warn",logger,logLevel),info:makeLogFn("info",logger,logLevel),debug:makeLogFn("debug",logger,logLevel)};return cachedLoggers.set(logger,[logLevel,levelLogger]),levelLogger}const formatRequestDetails=details=>(details.options&&(details.options={...details.options},delete details.options.headers),details.headers&&(details.headers=Object.fromEntries((details.headers instanceof Headers?[...details.headers]:Object.entries(details.headers)).map(([name,value])=>[name,"authorization"===name.toLowerCase()||"cookie"===name.toLowerCase()||"set-cookie"===name.toLowerCase()?"***":value]))),"retryOfRequestLogID"in details&&(details.retryOfRequestLogID&&(details.retryOf=details.retryOfRequestLogID),delete details.retryOfRequestLogID),details);async function defaultParseResponse(client,props){const{response,requestLogID,retryOfRequestLogID,startTime}=props,body=await(async()=>{if(props.options.stream)return loggerFor(client).debug("response",response.status,response.url,response.headers,response.body),props.options.__streamClass?props.options.__streamClass.fromSSEResponse(response,props.controller):Stream.fromSSEResponse(response,props.controller);if(204===response.status)return null;if(props.options.__binaryResponse)return response;const contentType=response.headers.get("content-type"),mediaType=contentType?.split(";")[0]?.trim();if(mediaType?.includes("application/json")||mediaType?.endsWith("+json")){return addRequestID(await response.json(),response)}return await response.text()})();return loggerFor(client).debug(`[${requestLogID}] response parsed`,formatRequestDetails({retryOfRequestLogID,url:response.url,status:response.status,body,durationMs:Date.now()-startTime})),body}function addRequestID(value,response){return!value||"object"!=typeof value||Array.isArray(value)?value:Object.defineProperty(value,"_request_id",{value:response.headers.get("x-request-id"),enumerable:!1})}var _APIPromise_client,_AbstractPage_client;class APIPromise extends Promise{constructor(client,responsePromise,parseResponse=defaultParseResponse){super(resolve=>{resolve(null)}),this.responsePromise=responsePromise,this.parseResponse=parseResponse,_APIPromise_client.set(this,void 0),__classPrivateFieldSet(this,_APIPromise_client,client,"f")}_thenUnwrap(transform){return new APIPromise(__classPrivateFieldGet(this,_APIPromise_client,"f"),this.responsePromise,async(client,props)=>addRequestID(transform(await this.parseResponse(client,props),props),props.response))}asResponse(){return this.responsePromise.then(p=>p.response)}async withResponse(){const[data,response]=await Promise.all([this.parse(),this.asResponse()]);return{data,response,request_id:response.headers.get("x-request-id")}}parse(){return this.parsedPromise||(this.parsedPromise=this.responsePromise.then(data=>this.parseResponse(__classPrivateFieldGet(this,_APIPromise_client,"f"),data))),this.parsedPromise}then(onfulfilled,onrejected){return this.parse().then(onfulfilled,onrejected)}catch(onrejected){return this.parse().catch(onrejected)}finally(onfinally){return this.parse().finally(onfinally)}}_APIPromise_client=new WeakMap;class AbstractPage{constructor(client,response,body,options){_AbstractPage_client.set(this,void 0),__classPrivateFieldSet(this,_AbstractPage_client,client,"f"),this.options=options,this.response=response,this.body=body}hasNextPage(){return!!this.getPaginatedItems().length&&null!=this.nextPageRequestOptions()}async getNextPage(){const nextOptions=this.nextPageRequestOptions();if(!nextOptions)throw new error_OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");return await __classPrivateFieldGet(this,_AbstractPage_client,"f").requestAPIList(this.constructor,nextOptions)}async*iterPages(){let page=this;for(yield page;page.hasNextPage();)page=await page.getNextPage(),yield page}async*[(_AbstractPage_client=new WeakMap,Symbol.asyncIterator)](){for await(const page of this.iterPages())for(const item of page.getPaginatedItems())yield item}}class PagePromise extends APIPromise{constructor(client,request,Page){super(client,request,async(client,props)=>new Page(client,props.response,await defaultParseResponse(client,props),props.options))}async*[Symbol.asyncIterator](){const page=await(this);for await(const item of page)yield item}}class Page extends AbstractPage{constructor(client,response,body,options){super(client,response,body,options),this.data=body.data||[],this.object=body.object}getPaginatedItems(){return this.data??[]}nextPageRequestOptions(){return null}}class CursorPage extends AbstractPage{constructor(client,response,body,options){super(client,response,body,options),this.data=body.data||[],this.has_more=body.has_more||!1}getPaginatedItems(){return this.data??[]}hasNextPage(){return!1!==this.has_more&&super.hasNextPage()}nextPageRequestOptions(){const data=this.getPaginatedItems(),id=data[data.length-1]?.id;return id?{...this.options,query:{...(x=this.options.query,"object"!=typeof x?{}:x??{}),after:id}}:null;var x}}const checkFileSupport=()=>{if("undefined"==typeof File){const{process}=globalThis,isOldNode="string"==typeof process?.versions?.node&&parseInt(process.versions.node.split("."))<20;throw new Error("`File` is not defined as a global, which is required for file uploads."+(isOldNode?" Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`.":""))}};function makeFile(fileBits,fileName,options){return checkFileSupport(),new File(fileBits,fileName??"unknown_file",options)}function getName(value){return("object"==typeof value&&null!==value&&("name"in value&&value.name&&String(value.name)||"url"in value&&value.url&&String(value.url)||"filename"in value&&value.filename&&String(value.filename)||"path"in value&&value.path&&String(value.path))||"").split(/[\\/]/).pop()||void 0}const isAsyncIterable=value=>null!=value&&"object"==typeof value&&"function"==typeof value[Symbol.asyncIterator],multipartFormRequestOptions=async(opts,fetch)=>({...opts,body:await createForm(opts.body,fetch)}),supportsFormDataMap=new WeakMap;const createForm=async(body,fetch)=>{if(!await function supportsFormData(fetchObject){const fetch="function"==typeof fetchObject?fetchObject:fetchObject.fetch,cached=supportsFormDataMap.get(fetch);if(cached)return cached;const promise=(async()=>{try{const FetchResponse="Response"in fetch?fetch.Response:(await fetch("data:,")).constructor,data=new FormData;return data.toString()!==await new FetchResponse(data).text()}catch{return!0}})();return supportsFormDataMap.set(fetch,promise),promise}(fetch))throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");const form=new FormData;return await Promise.all(Object.entries(body||{}).map(([key,value])=>addFormValue(form,key,value))),form},isNamedBlob=value=>value instanceof Blob&&"name"in value,addFormValue=async(form,key,value)=>{if(void 0!==value){if(null==value)throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);if("string"==typeof value||"number"==typeof value||"boolean"==typeof value)form.append(key,String(value));else if(value instanceof Response)form.append(key,makeFile([await value.blob()],getName(value)));else if(isAsyncIterable(value))form.append(key,makeFile([await new Response(ReadableStreamFrom(value)).blob()],getName(value)));else if(isNamedBlob(value))form.append(key,value,getName(value));else if(Array.isArray(value))await Promise.all(value.map(entry=>addFormValue(form,key+"[]",entry)));else{if("object"!=typeof value)throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);await Promise.all(Object.entries(value).map(([name,prop])=>addFormValue(form,`${key}[${name}]`,prop)))}}},isBlobLike=value=>null!=value&&"object"==typeof value&&"number"==typeof value.size&&"string"==typeof value.type&&"function"==typeof value.text&&"function"==typeof value.slice&&"function"==typeof value.arrayBuffer;async function getBytes(value){let parts=[];if("string"==typeof value||ArrayBuffer.isView(value)||value instanceof ArrayBuffer)parts.push(value);else if(isBlobLike(value))parts.push(value instanceof Blob?value:await value.arrayBuffer());else{if(!isAsyncIterable(value)){const constructor=value?.constructor?.name;throw new Error(`Unexpected data type: ${typeof value}${constructor?`; constructor: ${constructor}`:""}${function propsForError(value){if("object"!=typeof value||null===value)return"";const props=Object.getOwnPropertyNames(value);return`; props: [${props.map(p=>`"${p}"`).join(", ")}]`}(value)}`)}for await(const chunk of value)parts.push(...await getBytes(chunk))}return parts}class APIResource{constructor(client){this._client=client}}function encodeURIPath(str){return str.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g,encodeURIComponent)}const createPathTagFunction=(pathEncoder=encodeURIPath)=>function path(statics,...params){if(1===statics.length)return statics[0];let postPath=!1;const path=statics.reduce((previousValue,currentValue,index)=>(/[?#]/.test(currentValue)&&(postPath=!0),previousValue+currentValue+(index===params.length?"":(postPath?encodeURIComponent:pathEncoder)(String(params[index])))),""),pathOnly=path.split(/[?#]/,1)[0],invalidSegments=[],invalidSegmentPattern=/(?<=^|\/)(?:\.|%2e){1,2}(?=\/|$)/gi;let match;for(;null!==(match=invalidSegmentPattern.exec(pathOnly));)invalidSegments.push({start:match.index,length:match[0].length});if(invalidSegments.length>0){let lastEnd=0;const underline=invalidSegments.reduce((acc,segment)=>{const spaces=" ".repeat(segment.start-lastEnd),arrows="^".repeat(segment.length);return lastEnd=segment.start+segment.length,acc+spaces+arrows},"");throw new error_OpenAIError(`Path parameters result in path with invalid segments:\n${path}\n${underline}`)}return path},path=createPathTagFunction(encodeURIPath);class Messages extends APIResource{list(completionID,query={},options){return this._client.getAPIList(path`/chat/completions/${completionID}/messages`,CursorPage,{query,...options})}}function isRunnableFunctionWithParse(fn){return"function"==typeof fn.parse}const isAssistantMessage=message=>"assistant"===message?.role,isToolMessage=message=>"tool"===message?.role;var _EventStream_instances,_EventStream_connectedPromise,_EventStream_resolveConnectedPromise,_EventStream_rejectConnectedPromise,_EventStream_endPromise,_EventStream_resolveEndPromise,_EventStream_rejectEndPromise,_EventStream_listeners,_EventStream_ended,_EventStream_errored,_EventStream_aborted,_EventStream_catchingPromiseCreated,_EventStream_handleError,_AbstractChatCompletionRunner_instances,_AbstractChatCompletionRunner_getFinalContent,_AbstractChatCompletionRunner_getFinalMessage,_AbstractChatCompletionRunner_getFinalFunctionToolCall,_AbstractChatCompletionRunner_getFinalFunctionToolCallResult,_AbstractChatCompletionRunner_calculateTotalUsage,_AbstractChatCompletionRunner_validateParams,_AbstractChatCompletionRunner_stringifyFunctionCallResult;class EventStream{constructor(){_EventStream_instances.add(this),this.controller=new AbortController,_EventStream_connectedPromise.set(this,void 0),_EventStream_resolveConnectedPromise.set(this,()=>{}),_EventStream_rejectConnectedPromise.set(this,()=>{}),_EventStream_endPromise.set(this,void 0),_EventStream_resolveEndPromise.set(this,()=>{}),_EventStream_rejectEndPromise.set(this,()=>{}),_EventStream_listeners.set(this,{}),_EventStream_ended.set(this,!1),_EventStream_errored.set(this,!1),_EventStream_aborted.set(this,!1),_EventStream_catchingPromiseCreated.set(this,!1),__classPrivateFieldSet(this,_EventStream_connectedPromise,new Promise((resolve,reject)=>{__classPrivateFieldSet(this,_EventStream_resolveConnectedPromise,resolve,"f"),__classPrivateFieldSet(this,_EventStream_rejectConnectedPromise,reject,"f")}),"f"),__classPrivateFieldSet(this,_EventStream_endPromise,new Promise((resolve,reject)=>{__classPrivateFieldSet(this,_EventStream_resolveEndPromise,resolve,"f"),__classPrivateFieldSet(this,_EventStream_rejectEndPromise,reject,"f")}),"f"),__classPrivateFieldGet(this,_EventStream_connectedPromise,"f").catch(()=>{}),__classPrivateFieldGet(this,_EventStream_endPromise,"f").catch(()=>{})}_run(executor){setTimeout(()=>{executor().then(()=>{this._emitFinal(),this._emit("end")},__classPrivateFieldGet(this,_EventStream_instances,"m",_EventStream_handleError).bind(this))},0)}_connected(){this.ended||(__classPrivateFieldGet(this,_EventStream_resolveConnectedPromise,"f").call(this),this._emit("connect"))}get ended(){return __classPrivateFieldGet(this,_EventStream_ended,"f")}get errored(){return __classPrivateFieldGet(this,_EventStream_errored,"f")}get aborted(){return __classPrivateFieldGet(this,_EventStream_aborted,"f")}abort(){this.controller.abort()}on(event,listener){return(__classPrivateFieldGet(this,_EventStream_listeners,"f")[event]||(__classPrivateFieldGet(this,_EventStream_listeners,"f")[event]=[])).push({listener}),this}off(event,listener){const listeners=__classPrivateFieldGet(this,_EventStream_listeners,"f")[event];if(!listeners)return this;const index=listeners.findIndex(l=>l.listener===listener);return index>=0&&listeners.splice(index,1),this}once(event,listener){return(__classPrivateFieldGet(this,_EventStream_listeners,"f")[event]||(__classPrivateFieldGet(this,_EventStream_listeners,"f")[event]=[])).push({listener,once:!0}),this}emitted(event){return new Promise((resolve,reject)=>{__classPrivateFieldSet(this,_EventStream_catchingPromiseCreated,!0,"f"),"error"!==event&&this.once("error",reject),this.once(event,resolve)})}async done(){__classPrivateFieldSet(this,_EventStream_catchingPromiseCreated,!0,"f"),await __classPrivateFieldGet(this,_EventStream_endPromise,"f")}_emit(event,...args){if(__classPrivateFieldGet(this,_EventStream_ended,"f"))return;"end"===event&&(__classPrivateFieldSet(this,_EventStream_ended,!0,"f"),__classPrivateFieldGet(this,_EventStream_resolveEndPromise,"f").call(this));const listeners=__classPrivateFieldGet(this,_EventStream_listeners,"f")[event];if(listeners&&(__classPrivateFieldGet(this,_EventStream_listeners,"f")[event]=listeners.filter(l=>!l.once),listeners.forEach(({listener})=>listener(...args))),"abort"===event){const error=args[0];return __classPrivateFieldGet(this,_EventStream_catchingPromiseCreated,"f")||listeners?.length||Promise.reject(error),__classPrivateFieldGet(this,_EventStream_rejectConnectedPromise,"f").call(this,error),__classPrivateFieldGet(this,_EventStream_rejectEndPromise,"f").call(this,error),void this._emit("end")}if("error"===event){const error=args[0];__classPrivateFieldGet(this,_EventStream_catchingPromiseCreated,"f")||listeners?.length||Promise.reject(error),__classPrivateFieldGet(this,_EventStream_rejectConnectedPromise,"f").call(this,error),__classPrivateFieldGet(this,_EventStream_rejectEndPromise,"f").call(this,error),this._emit("end")}}_emitFinal(){}}function isAutoParsableResponseFormat(response_format){return"auto-parseable-response-format"===response_format?.$brand}function isAutoParsableTool(tool){return"auto-parseable-tool"===tool?.$brand}function parseChatCompletion(completion,params){const choices=completion.choices.map(choice=>{if("length"===choice.finish_reason)throw new LengthFinishReasonError;if("content_filter"===choice.finish_reason)throw new ContentFilterFinishReasonError;return{...choice,message:{...choice.message,...choice.message.tool_calls?{tool_calls:choice.message.tool_calls?.map(toolCall=>function parseToolCall(params,toolCall){const inputTool=params.tools?.find(inputTool=>inputTool.function?.name===toolCall.function.name);return{...toolCall,function:{...toolCall.function,parsed_arguments:isAutoParsableTool(inputTool)?inputTool.$parseRaw(toolCall.function.arguments):inputTool?.function.strict?JSON.parse(toolCall.function.arguments):null}}}(params,toolCall))??void 0}:void 0,parsed:choice.message.content&&!choice.message.refusal?parseResponseFormat(params,choice.message.content):null}}});return{...completion,choices}}function parseResponseFormat(params,content){if("json_schema"!==params.response_format?.type)return null;if("json_schema"===params.response_format?.type){if("$parseRaw"in params.response_format){return params.response_format.$parseRaw(content)}return JSON.parse(content)}return null}function shouldParseToolCall(params,toolCall){if(!params)return!1;const inputTool=params.tools?.find(inputTool=>inputTool.function?.name===toolCall.function.name);return isAutoParsableTool(inputTool)||inputTool?.function.strict||!1}function hasAutoParseableInput(params){return!!isAutoParsableResponseFormat(params.response_format)||(params.tools?.some(t=>isAutoParsableTool(t)||"function"===t.type&&!0===t.function.strict)??!1)}_EventStream_connectedPromise=new WeakMap,_EventStream_resolveConnectedPromise=new WeakMap,_EventStream_rejectConnectedPromise=new WeakMap,_EventStream_endPromise=new WeakMap,_EventStream_resolveEndPromise=new WeakMap,_EventStream_rejectEndPromise=new WeakMap,_EventStream_listeners=new WeakMap,_EventStream_ended=new WeakMap,_EventStream_errored=new WeakMap,_EventStream_aborted=new WeakMap,_EventStream_catchingPromiseCreated=new WeakMap,_EventStream_instances=new WeakSet,_EventStream_handleError=function _EventStream_handleError(error){if(__classPrivateFieldSet(this,_EventStream_errored,!0,"f"),error instanceof Error&&"AbortError"===error.name&&(error=new APIUserAbortError),error instanceof APIUserAbortError)return __classPrivateFieldSet(this,_EventStream_aborted,!0,"f"),this._emit("abort",error);if(error instanceof error_OpenAIError)return this._emit("error",error);if(error instanceof Error){const openAIError=new error_OpenAIError(error.message);return openAIError.cause=error,this._emit("error",openAIError)}return this._emit("error",new error_OpenAIError(String(error)))};const DEFAULT_MAX_CHAT_COMPLETIONS=10;class AbstractChatCompletionRunner extends EventStream{constructor(){super(...arguments),_AbstractChatCompletionRunner_instances.add(this),this._chatCompletions=[],this.messages=[]}_addChatCompletion(chatCompletion){this._chatCompletions.push(chatCompletion),this._emit("chatCompletion",chatCompletion);const message=chatCompletion.choices[0]?.message;return message&&this._addMessage(message),chatCompletion}_addMessage(message,emit=!0){if("content"in message||(message.content=null),this.messages.push(message),emit)if(this._emit("message",message),isToolMessage(message)&&message.content)this._emit("functionToolCallResult",message.content);else if(isAssistantMessage(message)&&message.tool_calls)for(const tool_call of message.tool_calls)"function"===tool_call.type&&this._emit("functionToolCall",tool_call.function)}async finalChatCompletion(){await this.done();const completion=this._chatCompletions[this._chatCompletions.length-1];if(!completion)throw new error_OpenAIError("stream ended without producing a ChatCompletion");return completion}async finalContent(){return await this.done(),__classPrivateFieldGet(this,_AbstractChatCompletionRunner_instances,"m",_AbstractChatCompletionRunner_getFinalContent).call(this)}async finalMessage(){return await this.done(),__classPrivateFieldGet(this,_AbstractChatCompletionRunner_instances,"m",_AbstractChatCompletionRunner_getFinalMessage).call(this)}async finalFunctionToolCall(){return await this.done(),__classPrivateFieldGet(this,_AbstractChatCompletionRunner_instances,"m",_AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this)}async finalFunctionToolCallResult(){return await this.done(),__classPrivateFieldGet(this,_AbstractChatCompletionRunner_instances,"m",_AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this)}async totalUsage(){return await this.done(),__classPrivateFieldGet(this,_AbstractChatCompletionRunner_instances,"m",_AbstractChatCompletionRunner_calculateTotalUsage).call(this)}allChatCompletions(){return[...this._chatCompletions]}_emitFinal(){const completion=this._chatCompletions[this._chatCompletions.length-1];completion&&this._emit("finalChatCompletion",completion);const finalMessage=__classPrivateFieldGet(this,_AbstractChatCompletionRunner_instances,"m",_AbstractChatCompletionRunner_getFinalMessage).call(this);finalMessage&&this._emit("finalMessage",finalMessage);const finalContent=__classPrivateFieldGet(this,_AbstractChatCompletionRunner_instances,"m",_AbstractChatCompletionRunner_getFinalContent).call(this);finalContent&&this._emit("finalContent",finalContent);const finalFunctionCall=__classPrivateFieldGet(this,_AbstractChatCompletionRunner_instances,"m",_AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);finalFunctionCall&&this._emit("finalFunctionToolCall",finalFunctionCall);const finalFunctionCallResult=__classPrivateFieldGet(this,_AbstractChatCompletionRunner_instances,"m",_AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);null!=finalFunctionCallResult&&this._emit("finalFunctionToolCallResult",finalFunctionCallResult),this._chatCompletions.some(c=>c.usage)&&this._emit("totalUsage",__classPrivateFieldGet(this,_AbstractChatCompletionRunner_instances,"m",_AbstractChatCompletionRunner_calculateTotalUsage).call(this))}async _createChatCompletion(client,params,options){const signal=options?.signal;signal&&(signal.aborted&&this.controller.abort(),signal.addEventListener("abort",()=>this.controller.abort())),__classPrivateFieldGet(this,_AbstractChatCompletionRunner_instances,"m",_AbstractChatCompletionRunner_validateParams).call(this,params);const chatCompletion=await client.chat.completions.create({...params,stream:!1},{...options,signal:this.controller.signal});return this._connected(),this._addChatCompletion(parseChatCompletion(chatCompletion,params))}async _runChatCompletion(client,params,options){for(const message of params.messages)this._addMessage(message,!1);return await this._createChatCompletion(client,params,options)}async _runTools(client,params,options){const{tool_choice="auto",stream,...restParams}=params,singleFunctionToCall="string"!=typeof tool_choice&&tool_choice?.function?.name,{maxChatCompletions=DEFAULT_MAX_CHAT_COMPLETIONS}=options||{},inputTools=params.tools.map(tool=>{if(isAutoParsableTool(tool)){if(!tool.$callback)throw new error_OpenAIError("Tool given to `.runTools()` that does not have an associated function");return{type:"function",function:{function:tool.$callback,name:tool.function.name,description:tool.function.description||"",parameters:tool.function.parameters,parse:tool.$parseRaw,strict:!0}}}return tool}),functionsByName={};for(const f of inputTools)"function"===f.type&&(functionsByName[f.function.name||f.function.function.name]=f.function);const tools="tools"in params?inputTools.map(t=>"function"===t.type?{type:"function",function:{name:t.function.name||t.function.function.name,parameters:t.function.parameters,description:t.function.description,strict:t.function.strict}}:t):void 0;for(const message of params.messages)this._addMessage(message,!1);for(let i=0;i<maxChatCompletions;++i){const chatCompletion=await this._createChatCompletion(client,{...restParams,tool_choice,tools,messages:[...this.messages]},options),message=chatCompletion.choices[0]?.message;if(!message)throw new error_OpenAIError("missing message in ChatCompletion response");if(!message.tool_calls?.length)return;for(const tool_call of message.tool_calls){if("function"!==tool_call.type)continue;const tool_call_id=tool_call.id,{name,arguments:args}=tool_call.function,fn=functionsByName[name];if(!fn){const content=`Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map(name=>JSON.stringify(name)).join(", ")}. Please try again`;this._addMessage({role:"tool",tool_call_id,content});continue}if(singleFunctionToCall&&singleFunctionToCall!==name){const content=`Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;this._addMessage({role:"tool",tool_call_id,content});continue}let parsed;try{parsed=isRunnableFunctionWithParse(fn)?await fn.parse(args):args}catch(error){const content=error instanceof Error?error.message:String(error);this._addMessage({role:"tool",tool_call_id,content});continue}const rawContent=await fn.function(parsed,this),content=__classPrivateFieldGet(this,_AbstractChatCompletionRunner_instances,"m",_AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this,rawContent);if(this._addMessage({role:"tool",tool_call_id,content}),singleFunctionToCall)return}}}}_AbstractChatCompletionRunner_instances=new WeakSet,_AbstractChatCompletionRunner_getFinalContent=function _AbstractChatCompletionRunner_getFinalContent(){return __classPrivateFieldGet(this,_AbstractChatCompletionRunner_instances,"m",_AbstractChatCompletionRunner_getFinalMessage).call(this).content??null},_AbstractChatCompletionRunner_getFinalMessage=function _AbstractChatCompletionRunner_getFinalMessage(){let i=this.messages.length;for(;i-- >0;){const message=this.messages[i];if(isAssistantMessage(message)){return{...message,content:message.content??null,refusal:message.refusal??null}}}throw new error_OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant")},_AbstractChatCompletionRunner_getFinalFunctionToolCall=function _AbstractChatCompletionRunner_getFinalFunctionToolCall(){for(let i=this.messages.length-1;i>=0;i--){const message=this.messages[i];if(isAssistantMessage(message)&&message?.tool_calls?.length)return message.tool_calls.at(-1)?.function}},_AbstractChatCompletionRunner_getFinalFunctionToolCallResult=function _AbstractChatCompletionRunner_getFinalFunctionToolCallResult(){for(let i=this.messages.length-1;i>=0;i--){const message=this.messages[i];if(isToolMessage(message)&&null!=message.content&&"string"==typeof message.content&&this.messages.some(x=>"assistant"===x.role&&x.tool_calls?.some(y=>"function"===y.type&&y.id===message.tool_call_id)))return message.content}},_AbstractChatCompletionRunner_calculateTotalUsage=function _AbstractChatCompletionRunner_calculateTotalUsage(){const total={completion_tokens:0,prompt_tokens:0,total_tokens:0};for(const{usage}of this._chatCompletions)usage&&(total.completion_tokens+=usage.completion_tokens,total.prompt_tokens+=usage.prompt_tokens,total.total_tokens+=usage.total_tokens);return total},_AbstractChatCompletionRunner_validateParams=function _AbstractChatCompletionRunner_validateParams(params){if(null!=params.n&&params.n>1)throw new error_OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.")},_AbstractChatCompletionRunner_stringifyFunctionCallResult=function _AbstractChatCompletionRunner_stringifyFunctionCallResult(rawContent){return"string"==typeof rawContent?rawContent:void 0===rawContent?"undefined":JSON.stringify(rawContent)};class ChatCompletionRunner extends AbstractChatCompletionRunner{static runTools(client,params,options){const runner=new ChatCompletionRunner,opts={...options,headers:{...options?.headers,"X-Stainless-Helper-Method":"runTools"}};return runner._run(()=>runner._runTools(client,params,opts)),runner}_addMessage(message,emit=!0){super._addMessage(message,emit),isAssistantMessage(message)&&message.content&&this._emit("content",message.content)}}const Allow_STR=1,Allow_NUM=2,Allow_ARR=4,Allow_OBJ=8,Allow_NULL=16,Allow_BOOL=32,Allow_NAN=64,Allow_INFINITY=128,Allow_MINUS_INFINITY=256,Allow_ALL=511;class PartialJSON extends Error{}class MalformedJSON extends Error{}const _parseJSON=(jsonString,allow)=>{const length=jsonString.length;let index=0;const markPartialJSON=msg=>{throw new PartialJSON(`${msg} at position ${index}`)},throwMalformedError=msg=>{throw new MalformedJSON(`${msg} at position ${index}`)},parseAny=()=>(skipBlank(),index>=length&&markPartialJSON("Unexpected end of input"),'"'===jsonString[index]?parseStr():"{"===jsonString[index]?parseObj():"["===jsonString[index]?parseArr():"null"===jsonString.substring(index,index+4)||Allow_NULL&allow&&length-index<4&&"null".startsWith(jsonString.substring(index))?(index+=4,null):"true"===jsonString.substring(index,index+4)||Allow_BOOL&allow&&length-index<4&&"true".startsWith(jsonString.substring(index))?(index+=4,!0):"false"===jsonString.substring(index,index+5)||Allow_BOOL&allow&&length-index<5&&"false".startsWith(jsonString.substring(index))?(index+=5,!1):"Infinity"===jsonString.substring(index,index+8)||Allow_INFINITY&allow&&length-index<8&&"Infinity".startsWith(jsonString.substring(index))?(index+=8,1/0):"-Infinity"===jsonString.substring(index,index+9)||Allow_MINUS_INFINITY&allow&&1<length-index&&length-index<9&&"-Infinity".startsWith(jsonString.substring(index))?(index+=9,-1/0):"NaN"===jsonString.substring(index,index+3)||Allow_NAN&allow&&length-index<3&&"NaN".startsWith(jsonString.substring(index))?(index+=3,NaN):parseNum()),parseStr=()=>{const start=index;let escape=!1;for(index++;index<length&&('"'!==jsonString[index]||escape&&"\\"===jsonString[index-1]);)escape="\\"===jsonString[index]&&!escape,index++;if('"'==jsonString.charAt(index))try{return JSON.parse(jsonString.substring(start,++index-Number(escape)))}catch(e){throwMalformedError(String(e))}else if(Allow_STR&allow)try{return JSON.parse(jsonString.substring(start,index-Number(escape))+'"')}catch(e){return JSON.parse(jsonString.substring(start,jsonString.lastIndexOf("\\"))+'"')}markPartialJSON("Unterminated string literal")},parseObj=()=>{index++,skipBlank();const obj={};try{for(;"}"!==jsonString[index];){if(skipBlank(),index>=length&&Allow_OBJ&allow)return obj;const key=parseStr();skipBlank(),index++;try{const value=parseAny();Object.defineProperty(obj,key,{value,writable:!0,enumerable:!0,configurable:!0})}catch(e){if(Allow_OBJ&allow)return obj;throw e}skipBlank(),","===jsonString[index]&&index++}}catch(e){if(Allow_OBJ&allow)return obj;markPartialJSON("Expected '}' at end of object")}return index++,obj},parseArr=()=>{index++;const arr=[];try{for(;"]"!==jsonString[index];)arr.push(parseAny()),skipBlank(),","===jsonString[index]&&index++}catch(e){if(Allow_ARR&allow)return arr;markPartialJSON("Expected ']' at end of array")}return index++,arr},parseNum=()=>{if(0===index){"-"===jsonString&&Allow_NUM&allow&&markPartialJSON("Not sure what '-' is");try{return JSON.parse(jsonString)}catch(e){if(Allow_NUM&allow)try{return"."===jsonString[jsonString.length-1]?JSON.parse(jsonString.substring(0,jsonString.lastIndexOf("."))):JSON.parse(jsonString.substring(0,jsonString.lastIndexOf("e")))}catch(e){}throwMalformedError(String(e))}}const start=index;for("-"===jsonString[index]&&index++;jsonString[index]&&!",]}".includes(jsonString[index]);)index++;index!=length||Allow_NUM&allow||markPartialJSON("Unterminated number literal");try{return JSON.parse(jsonString.substring(start,index))}catch(e){"-"===jsonString.substring(start,index)&&Allow_NUM&allow&&markPartialJSON("Not sure what '-' is");try{return JSON.parse(jsonString.substring(start,jsonString.lastIndexOf("e")))}catch(e){throwMalformedError(String(e))}}},skipBlank=()=>{for(;index<length&&" \n\r\t".includes(jsonString[index]);)index++};return parseAny()},partialParse=input=>function parseJSON(jsonString,allowPartial=Allow_ALL){if("string"!=typeof jsonString)throw new TypeError("expecting str, got "+typeof jsonString);if(!jsonString.trim())throw new Error(`${jsonString} is empty`);return _parseJSON(jsonString.trim(),allowPartial)}(input,Allow_ALL^Allow_NUM);var _ChatCompletionStream_instances,_ChatCompletionStream_params,_ChatCompletionStream_choiceEventStates,_ChatCompletionStream_currentChatCompletionSnapshot,_ChatCompletionStream_beginRequest,_ChatCompletionStream_getChoiceEventState,_ChatCompletionStream_addChunk,_ChatCompletionStream_emitToolCallDoneEvent,_ChatCompletionStream_emitContentDoneEvents,_ChatCompletionStream_endRequest,_ChatCompletionStream_getAutoParseableResponseFormat,_ChatCompletionStream_accumulateChatCompletion;class ChatCompletionStream extends AbstractChatCompletionRunner{constructor(params){super(),_ChatCompletionStream_instances.add(this),_ChatCompletionStream_params.set(this,void 0),_ChatCompletionStream_choiceEventStates.set(this,void 0),_ChatCompletionStream_currentChatCompletionSnapshot.set(this,void 0),__classPrivateFieldSet(this,_ChatCompletionStream_params,params,"f"),__classPrivateFieldSet(this,_ChatCompletionStream_choiceEventStates,[],"f")}get currentChatCompletionSnapshot(){return __classPrivateFieldGet(this,_ChatCompletionStream_currentChatCompletionSnapshot,"f")}static fromReadableStream(stream){const runner=new ChatCompletionStream(null);return runner._run(()=>runner._fromReadableStream(stream)),runner}static createChatCompletion(client,params,options){const runner=new ChatCompletionStream(params);return runner._run(()=>runner._runChatCompletion(client,{...params,stream:!0},{...options,headers:{...options?.headers,"X-Stainless-Helper-Method":"stream"}})),runner}async _createChatCompletion(client,params,options){super._createChatCompletion;const signal=options?.signal;signal&&(signal.aborted&&this.controller.abort(),signal.addEventListener("abort",()=>this.controller.abort())),__classPrivateFieldGet(this,_ChatCompletionStream_instances,"m",_ChatCompletionStream_beginRequest).call(this);const stream=await client.chat.completions.create({...params,stream:!0},{...options,signal:this.controller.signal});this._connected();for await(const chunk of stream)__classPrivateFieldGet(this,_ChatCompletionStream_instances,"m",_ChatCompletionStream_addChunk).call(this,chunk);if(stream.controller.signal?.aborted)throw new APIUserAbortError;return this._addChatCompletion(__classPrivateFieldGet(this,_ChatCompletionStream_instances,"m",_ChatCompletionStream_endRequest).call(this))}async _fromReadableStream(readableStream,options){const signal=options?.signal;signal&&(signal.aborted&&this.controller.abort(),signal.addEventListener("abort",()=>this.controller.abort())),__classPrivateFieldGet(this,_ChatCompletionStream_instances,"m",_ChatCompletionStream_beginRequest).call(this),this._connected();const stream=Stream.fromReadableStream(readableStream,this.controller);let chatId;for await(const chunk of stream)chatId&&chatId!==chunk.id&&this._addChatCompletion(__classPrivateFieldGet(this,_ChatCompletionStream_instances,"m",_ChatCompletionStream_endRequest).call(this)),__classPrivateFieldGet(this,_ChatCompletionStream_instances,"m",_ChatCompletionStream_addChunk).call(this,chunk),chatId=chunk.id;if(stream.controller.signal?.aborted)throw new APIUserAbortError;return this._addChatCompletion(__classPrivateFieldGet(this,_ChatCompletionStream_instances,"m",_ChatCompletionStream_endRequest).call(this))}[(_ChatCompletionStream_params=new WeakMap,_ChatCompletionStream_choiceEventStates=new WeakMap,_ChatCompletionStream_currentChatCompletionSnapshot=new WeakMap,_ChatCompletionStream_instances=new WeakSet,_ChatCompletionStream_beginRequest=function _ChatCompletionStream_beginRequest(){this.ended||__classPrivateFieldSet(this,_ChatCompletionStream_currentChatCompletionSnapshot,void 0,"f")},_ChatCompletionStream_getChoiceEventState=function _ChatCompletionStream_getChoiceEventState(choice){let state=__classPrivateFieldGet(this,_ChatCompletionStream_choiceEventStates,"f")[choice.index];return state||(state={content_done:!1,refusal_done:!1,logprobs_content_done:!1,logprobs_refusal_done:!1,done_tool_calls:new Set,current_tool_call_index:null},__classPrivateFieldGet(this,_ChatCompletionStream_choiceEventStates,"f")[choice.index]=state,state)},_ChatCompletionStream_addChunk=function _ChatCompletionStream_addChunk(chunk){if(this.ended)return;const completion=__classPrivateFieldGet(this,_ChatCompletionStream_instances,"m",_ChatCompletionStream_accumulateChatCompletion).call(this,chunk);this._emit("chunk",chunk,completion);for(const choice of chunk.choices){const choiceSnapshot=completion.choices[choice.index];null!=choice.delta.content&&"assistant"===choiceSnapshot.message?.role&&choiceSnapshot.message?.content&&(this._emit("content",choice.delta.content,choiceSnapshot.message.content),this._emit("content.delta",{delta:choice.delta.content,snapshot:choiceSnapshot.message.content,parsed:choiceSnapshot.message.parsed})),null!=choice.delta.refusal&&"assistant"===choiceSnapshot.message?.role&&choiceSnapshot.message?.refusal&&this._emit("refusal.delta",{delta:choice.delta.refusal,snapshot:choiceSnapshot.message.refusal}),null!=choice.logprobs?.content&&"assistant"===choiceSnapshot.message?.role&&this._emit("logprobs.content.delta",{content:choice.logprobs?.content,snapshot:choiceSnapshot.logprobs?.content??[]}),null!=choice.logprobs?.refusal&&"assistant"===choiceSnapshot.message?.role&&this._emit("logprobs.refusal.delta",{refusal:choice.logprobs?.refusal,snapshot:choiceSnapshot.logprobs?.refusal??[]});const state=__classPrivateFieldGet(this,_ChatCompletionStream_instances,"m",_ChatCompletionStream_getChoiceEventState).call(this,choiceSnapshot);choiceSnapshot.finish_reason&&(__classPrivateFieldGet(this,_ChatCompletionStream_instances,"m",_ChatCompletionStream_emitContentDoneEvents).call(this,choiceSnapshot),null!=state.current_tool_call_index&&__classPrivateFieldGet(this,_ChatCompletionStream_instances,"m",_ChatCompletionStream_emitToolCallDoneEvent).call(this,choiceSnapshot,state.current_tool_call_index));for(const toolCall of choice.delta.tool_calls??[])state.current_tool_call_index!==toolCall.index&&(__classPrivateFieldGet(this,_ChatCompletionStream_instances,"m",_ChatCompletionStream_emitContentDoneEvents).call(this,choiceSnapshot),null!=state.current_tool_call_index&&__classPrivateFieldGet(this,_ChatCompletionStream_instances,"m",_ChatCompletionStream_emitToolCallDoneEvent).call(this,choiceSnapshot,state.current_tool_call_index)),state.current_tool_call_index=toolCall.index;for(const toolCallDelta of choice.delta.tool_calls??[]){const toolCallSnapshot=choiceSnapshot.message.tool_calls?.[toolCallDelta.index];toolCallSnapshot?.type&&("function"===toolCallSnapshot?.type?this._emit("tool_calls.function.arguments.delta",{name:toolCallSnapshot.function?.name,index:toolCallDelta.index,arguments:toolCallSnapshot.function.arguments,parsed_arguments:toolCallSnapshot.function.parsed_arguments,arguments_delta:toolCallDelta.function?.arguments??""}):assertNever(toolCallSnapshot?.type))}}},_ChatCompletionStream_emitToolCallDoneEvent=function _ChatCompletionStream_emitToolCallDoneEvent(choiceSnapshot,toolCallIndex){if(__classPrivateFieldGet(this,_ChatCompletionStream_instances,"m",_ChatCompletionStream_getChoiceEventState).call(this,choiceSnapshot).done_tool_calls.has(toolCallIndex))return;const toolCallSnapshot=choiceSnapshot.message.tool_calls?.[toolCallIndex];if(!toolCallSnapshot)throw new Error("no tool call snapshot");if(!toolCallSnapshot.type)throw new Error("tool call snapshot missing `type`");if("function"===toolCallSnapshot.type){const inputTool=__classPrivateFieldGet(this,_ChatCompletionStream_params,"f")?.tools?.find(tool=>"function"===tool.type&&tool.function.name===toolCallSnapshot.function.name);this._emit("tool_calls.function.arguments.done",{name:toolCallSnapshot.function.name,index:toolCallIndex,arguments:toolCallSnapshot.function.arguments,parsed_arguments:isAutoParsableTool(inputTool)?inputTool.$parseRaw(toolCallSnapshot.function.arguments):inputTool?.function.strict?JSON.parse(toolCallSnapshot.function.arguments):null})}else toolCallSnapshot.type},_ChatCompletionStream_emitContentDoneEvents=function _ChatCompletionStream_emitContentDoneEvents(choiceSnapshot){const state=__classPrivateFieldGet(this,_ChatCompletionStream_instances,"m",_ChatCompletionStream_getChoiceEventState).call(this,choiceSnapshot);if(choiceSnapshot.message.content&&!state.content_done){state.content_done=!0;const responseFormat=__classPrivateFieldGet(this,_ChatCompletionStream_instances,"m",_ChatCompletionStream_getAutoParseableResponseFormat).call(this);this._emit("content.done",{content:choiceSnapshot.message.content,parsed:responseFormat?responseFormat.$parseRaw(choiceSnapshot.message.content):null})}choiceSnapshot.message.refusal&&!state.refusal_done&&(state.refusal_done=!0,this._emit("refusal.done",{refusal:choiceSnapshot.message.refusal})),choiceSnapshot.logprobs?.content&&!state.logprobs_content_done&&(state.logprobs_content_done=!0,this._emit("logprobs.content.done",{content:choiceSnapshot.logprobs.content})),choiceSnapshot.logprobs?.refusal&&!state.logprobs_refusal_done&&(state.logprobs_refusal_done=!0,this._emit("logprobs.refusal.done",{refusal:choiceSnapshot.logprobs.refusal}))},_ChatCompletionStream_endRequest=function _ChatCompletionStream_endRequest(){if(this.ended)throw new error_OpenAIError("stream has ended, this shouldn't happen");const snapshot=__classPrivateFieldGet(this,_ChatCompletionStream_currentChatCompletionSnapshot,"f");if(!snapshot)throw new error_OpenAIError("request ended without sending any chunks");return __classPrivateFieldSet(this,_ChatCompletionStream_currentChatCompletionSnapshot,void 0,"f"),__classPrivateFieldSet(this,_ChatCompletionStream_choiceEventStates,[],"f"),function finalizeChatCompletion(snapshot,params){const{id,choices,created,model,system_fingerprint,...rest}=snapshot,completion={...rest,id,choices:choices.map(({message,finish_reason,index,logprobs,...choiceRest})=>{if(!finish_reason)throw new error_OpenAIError(`missing finish_reason for choice ${index}`);const{content=null,function_call,tool_calls,...messageRest}=message,role=message.role;if(!role)throw new error_OpenAIError(`missing role for choice ${index}`);if(function_call){const{arguments:args,name}=function_call;if(null==args)throw new error_OpenAIError(`missing function_call.arguments for choice ${index}`);if(!name)throw new error_OpenAIError(`missing function_call.name for choice ${index}`);return{...choiceRest,message:{content,function_call:{arguments:args,name},role,refusal:message.refusal??null},finish_reason,index,logprobs}}return tool_calls?{...choiceRest,index,finish_reason,logprobs,message:{...messageRest,role,content,refusal:message.refusal??null,tool_calls:tool_calls.map((tool_call,i)=>{const{function:fn,type,id,...toolRest}=tool_call,{arguments:args,name,...fnRest}=fn||{};if(null==id)throw new error_OpenAIError(`missing choices[${index}].tool_calls[${i}].id\n${str(snapshot)}`);if(null==type)throw new error_OpenAIError(`missing choices[${index}].tool_calls[${i}].type\n${str(snapshot)}`);if(null==name)throw new error_OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name\n${str(snapshot)}`);if(null==args)throw new error_OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments\n${str(snapshot)}`);return{...toolRest,id,type,function:{...fnRest,name,arguments:args}}})}}:{...choiceRest,message:{...messageRest,content,role,refusal:message.refusal??null},finish_reason,index,logprobs}}),created,model,object:"chat.completion",...system_fingerprint?{system_fingerprint}:{}};return function maybeParseChatCompletion(completion,params){return params&&hasAutoParseableInput(params)?parseChatCompletion(completion,params):{...completion,choices:completion.choices.map(choice=>({...choice,message:{...choice.message,parsed:null,...choice.message.tool_calls?{tool_calls:choice.message.tool_calls}:void 0}}))}}(completion,params)}(snapshot,__classPrivateFieldGet(this,_ChatCompletionStream_params,"f"))},_ChatCompletionStream_getAutoParseableResponseFormat=function _ChatCompletionStream_getAutoParseableResponseFormat(){const responseFormat=__classPrivateFieldGet(this,_ChatCompletionStream_params,"f")?.response_format;return isAutoParsableResponseFormat(responseFormat)?responseFormat:null},_ChatCompletionStream_accumulateChatCompletion=function _ChatCompletionStream_accumulateChatCompletion(chunk){var _a,_b,_c,_d;let snapshot=__classPrivateFieldGet(this,_ChatCompletionStream_currentChatCompletionSnapshot,"f");const{choices,...rest}=chunk;snapshot?Object.assign(snapshot,rest):snapshot=__classPrivateFieldSet(this,_ChatCompletionStream_currentChatCompletionSnapshot,{...rest,choices:[]},"f");for(const{delta,finish_reason,index,logprobs=null,...other}of chunk.choices){let choice=snapshot.choices[index];if(choice||(choice=snapshot.choices[index]={finish_reason,index,message:{},logprobs,...other}),logprobs)if(choice.logprobs){const{content,refusal,...rest}=logprobs;assertIsEmpty(rest),Object.assign(choice.logprobs,rest),content&&((_a=choice.logprobs).content??(_a.content=[]),choice.logprobs.content.push(...content)),refusal&&((_b=choice.logprobs).refusal??(_b.refusal=[]),choice.logprobs.refusal.push(...refusal))}else choice.logprobs=Object.assign({},logprobs);if(finish_reason&&(choice.finish_reason=finish_reason,__classPrivateFieldGet(this,_ChatCompletionStream_params,"f")&&hasAutoParseableInput(__classPrivateFieldGet(this,_ChatCompletionStream_params,"f")))){if("length"===finish_reason)throw new LengthFinishReasonError;if("content_filter"===finish_reason)throw new ContentFilterFinishReasonError}if(Object.assign(choice,other),!delta)continue;const{content,refusal,function_call,role,tool_calls,...rest}=delta;if(assertIsEmpty(rest),Object.assign(choice.message,rest),refusal&&(choice.message.refusal=(choice.message.refusal||"")+refusal),role&&(choice.message.role=role),function_call&&(choice.message.function_call?(function_call.name&&(choice.message.function_call.name=function_call.name),function_call.arguments&&((_c=choice.message.function_call).arguments??(_c.arguments=""),choice.message.function_call.arguments+=function_call.arguments)):choice.message.function_call=function_call),content&&(choice.message.content=(choice.message.content||"")+content,!choice.message.refusal&&__classPrivateFieldGet(this,_ChatCompletionStream_instances,"m",_ChatCompletionStream_getAutoParseableResponseFormat).call(this)&&(choice.message.parsed=partialParse(choice.message.content))),tool_calls){choice.message.tool_calls||(choice.message.tool_calls=[]);for(const{index,id,type,function:fn,...rest}of tool_calls){const tool_call=(_d=choice.message.tool_calls)[index]??(_d[index]={});Object.assign(tool_call,rest),id&&(tool_call.id=id),type&&(tool_call.type=type),fn&&(tool_call.function??(tool_call.function={name:fn.name??"",arguments:""})),fn?.name&&(tool_call.function.name=fn.name),fn?.arguments&&(tool_call.function.arguments+=fn.arguments,shouldParseToolCall(__classPrivateFieldGet(this,_ChatCompletionStream_params,"f"),tool_call)&&(tool_call.function.parsed_arguments=partialParse(tool_call.function.arguments)))}}}return snapshot},Symbol.asyncIterator)](){const pushQueue=[],readQueue=[];let done=!1;return this.on("chunk",chunk=>{const reader=readQueue.shift();reader?reader.resolve(chunk):pushQueue.push(chunk)}),this.on("end",()=>{done=!0;for(const reader of readQueue)reader.resolve(void 0);readQueue.length=0}),this.on("abort",err=>{done=!0;for(const reader of readQueue)reader.reject(err);readQueue.length=0}),this.on("error",err=>{done=!0;for(const reader of readQueue)reader.reject(err);readQueue.length=0}),{next:async()=>{if(!pushQueue.length)return done?{value:void 0,done:!0}:new Promise((resolve,reject)=>readQueue.push({resolve,reject})).then(chunk=>chunk?{value:chunk,done:!1}:{value:void 0,done:!0});return{value:pushQueue.shift(),done:!1}},return:async()=>(this.abort(),{value:void 0,done:!0})}}toReadableStream(){return new Stream(this[Symbol.asyncIterator].bind(this),this.controller).toReadableStream()}}function str(x){return JSON.stringify(x)}function assertIsEmpty(obj){}function assertNever(_x){}class ChatCompletionStreamingRunner extends ChatCompletionStream{static fromReadableStream(stream){const runner=new ChatCompletionStreamingRunner(null);return runner._run(()=>runner._fromReadableStream(stream)),runner}static runTools(client,params,options){const runner=new ChatCompletionStreamingRunner(params),opts={...options,headers:{...options?.headers,"X-Stainless-Helper-Method":"runTools"}};return runner._run(()=>runner._runTools(client,params,opts)),runner}}class Completions extends APIResource{constructor(){super(...arguments),this.messages=new Messages(this._client)}create(body,options){return this._client.post("/chat/completions",{body,...options,stream:body.stream??!1})}retrieve(completionID,options){return this._client.get(path`/chat/completions/${completionID}`,options)}update(completionID,body,options){return this._client.post(path`/chat/completions/${completionID}`,{body,...options})}list(query={},options){return this._client.getAPIList("/chat/completions",CursorPage,{query,...options})}delete(completionID,options){return this._client.delete(path`/chat/completions/${completionID}`,options)}parse(body,options){return function validateInputTools(tools){for(const tool of tools??[]){if("function"!==tool.type)throw new error_OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);if(!0!==tool.function.strict)throw new error_OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`)}}(body.tools),this._client.chat.completions.create(body,{...options,headers:{...options?.headers,"X-Stainless-Helper-Method":"chat.completions.parse"}})._thenUnwrap(completion=>parseChatCompletion(completion,body))}runTools(body,options){return body.stream?ChatCompletionStreamingRunner.runTools(this._client,body,options):ChatCompletionRunner.runTools(this._client,body,options)}stream(body,options){return ChatCompletionStream.createChatCompletion(this._client,body,options)}}Completions.Messages=Messages;class Chat extends APIResource{constructor(){super(...arguments),this.completions=new Completions(this._client)}}Chat.Completions=Completions;const brand_privateNullableHeaders=Symbol("brand.privateNullableHeaders");function*iterateHeaders(headers){if(!headers)return;if(brand_privateNullableHeaders in headers){const{values,nulls}=headers;yield*values.entries();for(const name of nulls)yield[name,null];return}let iter,shouldClear=!1;headers instanceof Headers?iter=headers.entries():isReadonlyArray(headers)?iter=headers:(shouldClear=!0,iter=Object.entries(headers??{}));for(let row of iter){const name=row[0];if("string"!=typeof name)throw new TypeError("expected header name to be a string");const values=isReadonlyArray(row[1])?row[1]:[row[1]];let didClear=!1;for(const value of values)void 0!==value&&(shouldClear&&!didClear&&(didClear=!0,yield[name,null]),yield[name,value])}}const buildHeaders=newHeaders=>{const targetHeaders=new Headers,nullHeaders=new Set;for(const headers of newHeaders){const seenHeaders=new Set;for(const[name,value]of iterateHeaders(headers)){const lowerName=name.toLowerCase();seenHeaders.has(lowerName)||(targetHeaders.delete(name),seenHeaders.add(lowerName)),null===value?(targetHeaders.delete(name),nullHeaders.add(lowerName)):(targetHeaders.append(name,value),nullHeaders.delete(lowerName))}}return{[brand_privateNullableHeaders]:!0,values:targetHeaders,nulls:nullHeaders}};class Speech extends APIResource{create(body,options){return this._client.post("/audio/speech",{body,...options,headers:buildHeaders([{Accept:"application/octet-stream"},options?.headers]),__binaryResponse:!0})}}class Transcriptions extends APIResource{create(body,options){return this._client.post("/audio/transcriptions",multipartFormRequestOptions({body,...options,stream:body.stream??!1,__metadata:{model:body.model}},this._client))}}class Translations extends APIResource{create(body,options){return this._client.post("/audio/translations",multipartFormRequestOptions({body,...options,__metadata:{model:body.model}},this._client))}}class Audio extends APIResource{constructor(){super(...arguments),this.transcriptions=new Transcriptions(this._client),this.translations=new Translations(this._client),this.speech=new Speech(this._client)}}Audio.Transcriptions=Transcriptions,Audio.Translations=Translations,Audio.Speech=Speech;class Batches extends APIResource{create(body,options){return this._client.post("/batches",{body,...options})}retrieve(batchID,options){return this._client.get(path`/batches/${batchID}`,options)}list(query={},options){return this._client.getAPIList("/batches",CursorPage,{query,...options})}cancel(batchID,options){return this._client.post(path`/batches/${batchID}/cancel`,options)}}class Assistants extends APIResource{create(body,options){return this._client.post("/assistants",{body,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}retrieve(assistantID,options){return this._client.get(path`/assistants/${assistantID}`,{...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}update(assistantID,body,options){return this._client.post(path`/assistants/${assistantID}`,{body,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}list(query={},options){return this._client.getAPIList("/assistants",CursorPage,{query,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}delete(assistantID,options){return this._client.delete(path`/assistants/${assistantID}`,{...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}}class Sessions extends APIResource{create(body,options){return this._client.post("/realtime/sessions",{body,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}}class TranscriptionSessions extends APIResource{create(body,options){return this._client.post("/realtime/transcription_sessions",{body,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}}class Realtime extends APIResource{constructor(){super(...arguments),this.sessions=new Sessions(this._client),this.transcriptionSessions=new TranscriptionSessions(this._client)}}Realtime.Sessions=Sessions,Realtime.TranscriptionSessions=TranscriptionSessions;class messages_Messages extends APIResource{create(threadID,body,options){return this._client.post(path`/threads/${threadID}/messages`,{body,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}retrieve(messageID,params,options){const{thread_id}=params;return this._client.get(path`/threads/${thread_id}/messages/${messageID}`,{...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}update(messageID,params,options){const{thread_id,...body}=params;return this._client.post(path`/threads/${thread_id}/messages/${messageID}`,{body,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}list(threadID,query={},options){return this._client.getAPIList(path`/threads/${threadID}/messages`,CursorPage,{query,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}delete(messageID,params,options){const{thread_id}=params;return this._client.delete(path`/threads/${thread_id}/messages/${messageID}`,{...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}}class Steps extends APIResource{retrieve(stepID,params,options){const{thread_id,run_id,...query}=params;return this._client.get(path`/threads/${thread_id}/runs/${run_id}/steps/${stepID}`,{query,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}list(runID,params,options){const{thread_id,...query}=params;return this._client.getAPIList(path`/threads/${thread_id}/runs/${runID}/steps`,CursorPage,{query,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}}var Buffer=__webpack_require__("./node_modules/buffer/index.js").Buffer;const readEnv=env=>void 0!==globalThis.process?globalThis.process.env?.[env]?.trim()??void 0:void 0!==globalThis.Deno?globalThis.Deno.env?.get?.(env)?.trim():void 0;var _AssistantStream_instances,_a,_AssistantStream_events,_AssistantStream_runStepSnapshots,_AssistantStream_messageSnapshots,_AssistantStream_messageSnapshot,_AssistantStream_finalRun,_AssistantStream_currentContentIndex,_AssistantStream_currentContent,_AssistantStream_currentToolCallIndex,_AssistantStream_currentToolCall,_AssistantStream_currentEvent,_AssistantStream_currentRunSnapshot,_AssistantStream_currentRunStepSnapshot,_AssistantStream_addEvent,_AssistantStream_endRequest,_AssistantStream_handleMessage,_AssistantStream_handleRunStep,_AssistantStream_handleEvent,_AssistantStream_accumulateRunStep,_AssistantStream_accumulateMessage,_AssistantStream_accumulateContent,_AssistantStream_handleRun,_ResponseStream_instances,_ResponseStream_params,_ResponseStream_currentResponseSnapshot,_ResponseStream_finalResponse,_ResponseStream_beginRequest,_ResponseStream_addEvent,_ResponseStream_endRequest,_ResponseStream_accumulateResponse,AssistantStream_console=__webpack_require__("./node_modules/console-browserify/index.js");class AssistantStream extends EventStream{constructor(){super(...arguments),_AssistantStream_instances.add(this),_AssistantStream_events.set(this,[]),_AssistantStream_runStepSnapshots.set(this,{}),_AssistantStream_messageSnapshots.set(this,{}),_AssistantStream_messageSnapshot.set(this,void 0),_AssistantStream_finalRun.set(this,void 0),_AssistantStream_currentContentIndex.set(this,void 0),_AssistantStream_currentContent.set(this,void 0),_AssistantStream_currentToolCallIndex.set(this,void 0),_AssistantStream_currentToolCall.set(this,void 0),_AssistantStream_currentEvent.set(this,void 0),_AssistantStream_currentRunSnapshot.set(this,void 0),_AssistantStream_currentRunStepSnapshot.set(this,void 0)}[(_AssistantStream_events=new WeakMap,_AssistantStream_runStepSnapshots=new WeakMap,_AssistantStream_messageSnapshots=new WeakMap,_AssistantStream_messageSnapshot=new WeakMap,_AssistantStream_finalRun=new WeakMap,_AssistantStream_currentContentIndex=new WeakMap,_AssistantStream_currentContent=new WeakMap,_AssistantStream_currentToolCallIndex=new WeakMap,_AssistantStream_currentToolCall=new WeakMap,_AssistantStream_currentEvent=new WeakMap,_AssistantStream_currentRunSnapshot=new WeakMap,_AssistantStream_currentRunStepSnapshot=new WeakMap,_AssistantStream_instances=new WeakSet,Symbol.asyncIterator)](){const pushQueue=[],readQueue=[];let done=!1;return this.on("event",event=>{const reader=readQueue.shift();reader?reader.resolve(event):pushQueue.push(event)}),this.on("end",()=>{done=!0;for(const reader of readQueue)reader.resolve(void 0);readQueue.length=0}),this.on("abort",err=>{done=!0;for(const reader of readQueue)reader.reject(err);readQueue.length=0}),this.on("error",err=>{done=!0;for(const reader of readQueue)reader.reject(err);readQueue.length=0}),{next:async()=>{if(!pushQueue.length)return done?{value:void 0,done:!0}:new Promise((resolve,reject)=>readQueue.push({resolve,reject})).then(chunk=>chunk?{value:chunk,done:!1}:{value:void 0,done:!0});return{value:pushQueue.shift(),done:!1}},return:async()=>(this.abort(),{value:void 0,done:!0})}}static fromReadableStream(stream){const runner=new _a;return runner._run(()=>runner._fromReadableStream(stream)),runner}async _fromReadableStream(readableStream,options){const signal=options?.signal;signal&&(signal.aborted&&this.controller.abort(),signal.addEventListener("abort",()=>this.controller.abort())),this._connected();const stream=Stream.fromReadableStream(readableStream,this.controller);for await(const event of stream)__classPrivateFieldGet(this,_AssistantStream_instances,"m",_AssistantStream_addEvent).call(this,event);if(stream.controller.signal?.aborted)throw new APIUserAbortError;return this._addRun(__classPrivateFieldGet(this,_AssistantStream_instances,"m",_AssistantStream_endRequest).call(this))}toReadableStream(){return new Stream(this[Symbol.asyncIterator].bind(this),this.controller).toReadableStream()}static createToolAssistantStream(runId,runs,params,options){const runner=new _a;return runner._run(()=>runner._runToolAssistantStream(runId,runs,params,{...options,headers:{...options?.headers,"X-Stainless-Helper-Method":"stream"}})),runner}async _createToolAssistantStream(run,runId,params,options){const signal=options?.signal;signal&&(signal.aborted&&this.controller.abort(),signal.addEventListener("abort",()=>this.controller.abort()));const body={...params,stream:!0},stream=await run.submitToolOutputs(runId,body,{...options,signal:this.controller.signal});this._connected();for await(const event of stream)__classPrivateFieldGet(this,_AssistantStream_instances,"m",_AssistantStream_addEvent).call(this,event);if(stream.controller.signal?.aborted)throw new APIUserAbortError;return this._addRun(__classPrivateFieldGet(this,_AssistantStream_instances,"m",_AssistantStream_endRequest).call(this))}static createThreadAssistantStream(params,thread,options){const runner=new _a;return runner._run(()=>runner._threadAssistantStream(params,thread,{...options,headers:{...options?.headers,"X-Stainless-Helper-Method":"stream"}})),runner}static createAssistantStream(threadId,runs,params,options){const runner=new _a;return runner._run(()=>runner._runAssistantStream(threadId,runs,params,{...options,headers:{...options?.headers,"X-Stainless-Helper-Method":"stream"}})),runner}currentEvent(){return __classPrivateFieldGet(this,_AssistantStream_currentEvent,"f")}currentRun(){return __classPrivateFieldGet(this,_AssistantStream_currentRunSnapshot,"f")}currentMessageSnapshot(){return __classPrivateFieldGet(this,_AssistantStream_messageSnapshot,"f")}currentRunStepSnapshot(){return __classPrivateFieldGet(this,_AssistantStream_currentRunStepSnapshot,"f")}async finalRunSteps(){return await this.done(),Object.values(__classPrivateFieldGet(this,_AssistantStream_runStepSnapshots,"f"))}async finalMessages(){return await this.done(),Object.values(__classPrivateFieldGet(this,_AssistantStream_messageSnapshots,"f"))}async finalRun(){if(await this.done(),!__classPrivateFieldGet(this,_AssistantStream_finalRun,"f"))throw Error("Final run was not received.");return __classPrivateFieldGet(this,_AssistantStream_finalRun,"f")}async _createThreadAssistantStream(thread,params,options){const signal=options?.signal;signal&&(signal.aborted&&this.controller.abort(),signal.addEventListener("abort",()=>this.controller.abort()));const body={...params,stream:!0},stream=await thread.createAndRun(body,{...options,signal:this.controller.signal});this._connected();for await(const event of stream)__classPrivateFieldGet(this,_AssistantStream_instances,"m",_AssistantStream_addEvent).call(this,event);if(stream.controller.signal?.aborted)throw new APIUserAbortError;return this._addRun(__classPrivateFieldGet(this,_AssistantStream_instances,"m",_AssistantStream_endRequest).call(this))}async _createAssistantStream(run,threadId,params,options){const signal=options?.signal;signal&&(signal.aborted&&this.controller.abort(),signal.addEventListener("abort",()=>this.controller.abort()));const body={...params,stream:!0},stream=await run.create(threadId,body,{...options,signal:this.controller.signal});this._connected();for await(const event of stream)__classPrivateFieldGet(this,_AssistantStream_instances,"m",_AssistantStream_addEvent).call(this,event);if(stream.controller.signal?.aborted)throw new APIUserAbortError;return this._addRun(__classPrivateFieldGet(this,_AssistantStream_instances,"m",_AssistantStream_endRequest).call(this))}static accumulateDelta(acc,delta){for(const[key,deltaValue]of Object.entries(delta)){if(!acc.hasOwnProperty(key)){acc[key]=deltaValue;continue}let accValue=acc[key];if(null!=accValue)if("index"!==key&&"type"!==key){if("string"==typeof accValue&&"string"==typeof deltaValue)accValue+=deltaValue;else if("number"==typeof accValue&&"number"==typeof deltaValue)accValue+=deltaValue;else{if(!isObj(accValue)||!isObj(deltaValue)){if(Array.isArray(accValue)&&Array.isArray(deltaValue)){if(accValue.every(x=>"string"==typeof x||"number"==typeof x)){accValue.push(...deltaValue);continue}for(const deltaEntry of deltaValue){if(!isObj(deltaEntry))throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);const index=deltaEntry.index;if(null==index)throw AssistantStream_console.error(deltaEntry),new Error("Expected array delta entry to have an `index` property");if("number"!=typeof index)throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index}`);const accEntry=accValue[index];null==accEntry?accValue.push(deltaEntry):accValue[index]=this.accumulateDelta(accEntry,deltaEntry)}continue}throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`)}accValue=this.accumulateDelta(accValue,deltaValue)}acc[key]=accValue}else acc[key]=deltaValue;else acc[key]=deltaValue}return acc}_addRun(run){return run}async _threadAssistantStream(params,thread,options){return await this._createThreadAssistantStream(thread,params,options)}async _runAssistantStream(threadId,runs,params,options){return await this._createAssistantStream(runs,threadId,params,options)}async _runToolAssistantStream(runId,runs,params,options){return await this._createToolAssistantStream(runs,runId,params,options)}}_a=AssistantStream,_AssistantStream_addEvent=function _AssistantStream_addEvent(event){if(!this.ended)switch(__classPrivateFieldSet(this,_AssistantStream_currentEvent,event,"f"),__classPrivateFieldGet(this,_AssistantStream_instances,"m",_AssistantStream_handleEvent).call(this,event),event.event){case"thread.created":break;case"thread.run.created":case"thread.run.queued":case"thread.run.in_progress":case"thread.run.requires_action":case"thread.run.completed":case"thread.run.incomplete":case"thread.run.failed":case"thread.run.cancelling":case"thread.run.cancelled":case"thread.run.expired":__classPrivateFieldGet(this,_AssistantStream_instances,"m",_AssistantStream_handleRun).call(this,event);break;case"thread.run.step.created":case"thread.run.step.in_progress":case"thread.run.step.delta":case"thread.run.step.completed":case"thread.run.step.failed":case"thread.run.step.cancelled":case"thread.run.step.expired":__classPrivateFieldGet(this,_AssistantStream_instances,"m",_AssistantStream_handleRunStep).call(this,event);break;case"thread.message.created":case"thread.message.in_progress":case"thread.message.delta":case"thread.message.completed":case"thread.message.incomplete":__classPrivateFieldGet(this,_AssistantStream_instances,"m",_AssistantStream_handleMessage).call(this,event);break;case"error":throw new Error("Encountered an error event in event processing - errors should be processed earlier")}},_AssistantStream_endRequest=function _AssistantStream_endRequest(){if(this.ended)throw new error_OpenAIError("stream has ended, this shouldn't happen");if(!__classPrivateFieldGet(this,_AssistantStream_finalRun,"f"))throw Error("Final run has not been received");return __classPrivateFieldGet(this,_AssistantStream_finalRun,"f")},_AssistantStream_handleMessage=function _AssistantStream_handleMessage(event){const[accumulatedMessage,newContent]=__classPrivateFieldGet(this,_AssistantStream_instances,"m",_AssistantStream_accumulateMessage).call(this,event,__classPrivateFieldGet(this,_AssistantStream_messageSnapshot,"f"));__classPrivateFieldSet(this,_AssistantStream_messageSnapshot,accumulatedMessage,"f"),__classPrivateFieldGet(this,_AssistantStream_messageSnapshots,"f")[accumulatedMessage.id]=accumulatedMessage;for(const content of newContent){const snapshotContent=accumulatedMessage.content[content.index];"text"==snapshotContent?.type&&this._emit("textCreated",snapshotContent.text)}switch(event.event){case"thread.message.created":this._emit("messageCreated",event.data);break;case"thread.message.in_progress":break;case"thread.message.delta":if(this._emit("messageDelta",event.data.delta,accumulatedMessage),event.data.delta.content)for(const content of event.data.delta.content){if("text"==content.type&&content.text){let textDelta=content.text,snapshot=accumulatedMessage.content[content.index];if(!snapshot||"text"!=snapshot.type)throw Error("The snapshot associated with this text delta is not text or missing");this._emit("textDelta",textDelta,snapshot.text)}if(content.index!=__classPrivateFieldGet(this,_AssistantStream_currentContentIndex,"f")){if(__classPrivateFieldGet(this,_AssistantStream_currentContent,"f"))switch(__classPrivateFieldGet(this,_AssistantStream_currentContent,"f").type){case"text":this._emit("textDone",__classPrivateFieldGet(this,_AssistantStream_currentContent,"f").text,__classPrivateFieldGet(this,_AssistantStream_messageSnapshot,"f"));break;case"image_file":this._emit("imageFileDone",__classPrivateFieldGet(this,_AssistantStream_currentContent,"f").image_file,__classPrivateFieldGet(this,_AssistantStream_messageSnapshot,"f"))}__classPrivateFieldSet(this,_AssistantStream_currentContentIndex,content.index,"f")}__classPrivateFieldSet(this,_AssistantStream_currentContent,accumulatedMessage.content[content.index],"f")}break;case"thread.message.completed":case"thread.message.incomplete":if(void 0!==__classPrivateFieldGet(this,_AssistantStream_currentContentIndex,"f")){const currentContent=event.data.content[__classPrivateFieldGet(this,_AssistantStream_currentContentIndex,"f")];if(currentContent)switch(currentContent.type){case"image_file":this._emit("imageFileDone",currentContent.image_file,__classPrivateFieldGet(this,_AssistantStream_messageSnapshot,"f"));break;case"text":this._emit("textDone",currentContent.text,__classPrivateFieldGet(this,_AssistantStream_messageSnapshot,"f"))}}__classPrivateFieldGet(this,_AssistantStream_messageSnapshot,"f")&&this._emit("messageDone",event.data),__classPrivateFieldSet(this,_AssistantStream_messageSnapshot,void 0,"f")}},_AssistantStream_handleRunStep=function _AssistantStream_handleRunStep(event){const accumulatedRunStep=__classPrivateFieldGet(this,_AssistantStream_instances,"m",_AssistantStream_accumulateRunStep).call(this,event);switch(__classPrivateFieldSet(this,_AssistantStream_currentRunStepSnapshot,accumulatedRunStep,"f"),event.event){case"thread.run.step.created":this._emit("runStepCreated",event.data);break;case"thread.run.step.delta":const delta=event.data.delta;if(delta.step_details&&"tool_calls"==delta.step_details.type&&delta.step_details.tool_calls&&"tool_calls"==accumulatedRunStep.step_details.type)for(const toolCall of delta.step_details.tool_calls)toolCall.index==__classPrivateFieldGet(this,_AssistantStream_currentToolCallIndex,"f")?this._emit("toolCallDelta",toolCall,accumulatedRunStep.step_details.tool_calls[toolCall.index]):(__classPrivateFieldGet(this,_AssistantStream_currentToolCall,"f")&&this._emit("toolCallDone",__classPrivateFieldGet(this,_AssistantStream_currentToolCall,"f")),__classPrivateFieldSet(this,_AssistantStream_currentToolCallIndex,toolCall.index,"f"),__classPrivateFieldSet(this,_AssistantStream_currentToolCall,accumulatedRunStep.step_details.tool_calls[toolCall.index],"f"),__classPrivateFieldGet(this,_AssistantStream_currentToolCall,"f")&&this._emit("toolCallCreated",__classPrivateFieldGet(this,_AssistantStream_currentToolCall,"f")));this._emit("runStepDelta",event.data.delta,accumulatedRunStep);break;case"thread.run.step.completed":case"thread.run.step.failed":case"thread.run.step.cancelled":case"thread.run.step.expired":__classPrivateFieldSet(this,_AssistantStream_currentRunStepSnapshot,void 0,"f");"tool_calls"==event.data.step_details.type&&__classPrivateFieldGet(this,_AssistantStream_currentToolCall,"f")&&(this._emit("toolCallDone",__classPrivateFieldGet(this,_AssistantStream_currentToolCall,"f")),__classPrivateFieldSet(this,_AssistantStream_currentToolCall,void 0,"f")),this._emit("runStepDone",event.data,accumulatedRunStep)}},_AssistantStream_handleEvent=function _AssistantStream_handleEvent(event){__classPrivateFieldGet(this,_AssistantStream_events,"f").push(event),this._emit("event",event)},_AssistantStream_accumulateRunStep=function _AssistantStream_accumulateRunStep(event){switch(event.event){case"thread.run.step.created":return __classPrivateFieldGet(this,_AssistantStream_runStepSnapshots,"f")[event.data.id]=event.data,event.data;case"thread.run.step.delta":let snapshot=__classPrivateFieldGet(this,_AssistantStream_runStepSnapshots,"f")[event.data.id];if(!snapshot)throw Error("Received a RunStepDelta before creation of a snapshot");let data=event.data;if(data.delta){const accumulated=_a.accumulateDelta(snapshot,data.delta);__classPrivateFieldGet(this,_AssistantStream_runStepSnapshots,"f")[event.data.id]=accumulated}return __classPrivateFieldGet(this,_AssistantStream_runStepSnapshots,"f")[event.data.id];case"thread.run.step.completed":case"thread.run.step.failed":case"thread.run.step.cancelled":case"thread.run.step.expired":case"thread.run.step.in_progress":__classPrivateFieldGet(this,_AssistantStream_runStepSnapshots,"f")[event.data.id]=event.data}if(__classPrivateFieldGet(this,_AssistantStream_runStepSnapshots,"f")[event.data.id])return __classPrivateFieldGet(this,_AssistantStream_runStepSnapshots,"f")[event.data.id];throw new Error("No snapshot available")},_AssistantStream_accumulateMessage=function _AssistantStream_accumulateMessage(event,snapshot){let newContent=[];switch(event.event){case"thread.message.created":return[event.data,newContent];case"thread.message.delta":if(!snapshot)throw Error("Received a delta with no existing snapshot (there should be one from message creation)");let data=event.data;if(data.delta.content)for(const contentElement of data.delta.content)if(contentElement.index in snapshot.content){let currentContent=snapshot.content[contentElement.index];snapshot.content[contentElement.index]=__classPrivateFieldGet(this,_AssistantStream_instances,"m",_AssistantStream_accumulateContent).call(this,contentElement,currentContent)}else snapshot.content[contentElement.index]=contentElement,newContent.push(contentElement);return[snapshot,newContent];case"thread.message.in_progress":case"thread.message.completed":case"thread.message.incomplete":if(snapshot)return[snapshot,newContent];throw Error("Received thread message event with no existing snapshot")}throw Error("Tried to accumulate a non-message event")},_AssistantStream_accumulateContent=function _AssistantStream_accumulateContent(contentElement,currentContent){return _a.accumulateDelta(currentContent,contentElement)},_AssistantStream_handleRun=function _AssistantStream_handleRun(event){switch(__classPrivateFieldSet(this,_AssistantStream_currentRunSnapshot,event.data,"f"),event.event){case"thread.run.created":case"thread.run.queued":case"thread.run.in_progress":case"thread.run.cancelling":break;case"thread.run.requires_action":case"thread.run.cancelled":case"thread.run.failed":case"thread.run.completed":case"thread.run.expired":case"thread.run.incomplete":__classPrivateFieldSet(this,_AssistantStream_finalRun,event.data,"f"),__classPrivateFieldGet(this,_AssistantStream_currentToolCall,"f")&&(this._emit("toolCallDone",__classPrivateFieldGet(this,_AssistantStream_currentToolCall,"f")),__classPrivateFieldSet(this,_AssistantStream_currentToolCall,void 0,"f"))}};class Runs extends APIResource{constructor(){super(...arguments),this.steps=new Steps(this._client)}create(threadID,params,options){const{include,...body}=params;return this._client.post(path`/threads/${threadID}/runs`,{query:{include},body,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers]),stream:params.stream??!1})}retrieve(runID,params,options){const{thread_id}=params;return this._client.get(path`/threads/${thread_id}/runs/${runID}`,{...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}update(runID,params,options){const{thread_id,...body}=params;return this._client.post(path`/threads/${thread_id}/runs/${runID}`,{body,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}list(threadID,query={},options){return this._client.getAPIList(path`/threads/${threadID}/runs`,CursorPage,{query,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}cancel(runID,params,options){const{thread_id}=params;return this._client.post(path`/threads/${thread_id}/runs/${runID}/cancel`,{...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}async createAndPoll(threadId,body,options){const run=await this.create(threadId,body,options);return await this.poll(run.id,{thread_id:threadId},options)}createAndStream(threadId,body,options){return AssistantStream.createAssistantStream(threadId,this._client.beta.threads.runs,body,options)}async poll(runId,params,options){const headers=buildHeaders([options?.headers,{"X-Stainless-Poll-Helper":"true","X-Stainless-Custom-Poll-Interval":options?.pollIntervalMs?.toString()??void 0}]);for(;;){const{data:run,response}=await this.retrieve(runId,params,{...options,headers:{...options?.headers,...headers}}).withResponse();switch(run.status){case"queued":case"in_progress":case"cancelling":let sleepInterval=5e3;if(options?.pollIntervalMs)sleepInterval=options.pollIntervalMs;else{const headerInterval=response.headers.get("openai-poll-after-ms");if(headerInterval){const headerIntervalMs=parseInt(headerInterval);isNaN(headerIntervalMs)||(sleepInterval=headerIntervalMs)}}await sleep(sleepInterval);break;case"requires_action":case"incomplete":case"cancelled":case"completed":case"failed":case"expired":return run}}}stream(threadId,body,options){return AssistantStream.createAssistantStream(threadId,this._client.beta.threads.runs,body,options)}submitToolOutputs(runID,params,options){const{thread_id,...body}=params;return this._client.post(path`/threads/${thread_id}/runs/${runID}/submit_tool_outputs`,{body,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers]),stream:params.stream??!1})}async submitToolOutputsAndPoll(runId,params,options){const run=await this.submitToolOutputs(runId,params,options);return await this.poll(run.id,params,options)}submitToolOutputsStream(runId,params,options){return AssistantStream.createToolAssistantStream(runId,this._client.beta.threads.runs,params,options)}}Runs.Steps=Steps;class Threads extends APIResource{constructor(){super(...arguments),this.runs=new Runs(this._client),this.messages=new messages_Messages(this._client)}create(body={},options){return this._client.post("/threads",{body,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}retrieve(threadID,options){return this._client.get(path`/threads/${threadID}`,{...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}update(threadID,body,options){return this._client.post(path`/threads/${threadID}`,{body,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}delete(threadID,options){return this._client.delete(path`/threads/${threadID}`,{...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}createAndRun(body,options){return this._client.post("/threads/runs",{body,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers]),stream:body.stream??!1})}async createAndRunPoll(body,options){const run=await this.createAndRun(body,options);return await this.runs.poll(run.id,{thread_id:run.thread_id},options)}createAndRunStream(body,options){return AssistantStream.createThreadAssistantStream(body,this._client.beta.threads,options)}}Threads.Runs=Runs,Threads.Messages=messages_Messages;class Beta extends APIResource{constructor(){super(...arguments),this.realtime=new Realtime(this._client),this.assistants=new Assistants(this._client),this.threads=new Threads(this._client)}}Beta.Realtime=Realtime,Beta.Assistants=Assistants,Beta.Threads=Threads;class completions_Completions extends APIResource{create(body,options){return this._client.post("/completions",{body,...options,stream:body.stream??!1})}}class Content extends APIResource{retrieve(fileID,params,options){const{container_id}=params;return this._client.get(path`/containers/${container_id}/files/${fileID}/content`,{...options,headers:buildHeaders([{Accept:"application/binary"},options?.headers]),__binaryResponse:!0})}}class Files extends APIResource{constructor(){super(...arguments),this.content=new Content(this._client)}create(containerID,body,options){return this._client.post(path`/containers/${containerID}/files`,multipartFormRequestOptions({body,...options},this._client))}retrieve(fileID,params,options){const{container_id}=params;return this._client.get(path`/containers/${container_id}/files/${fileID}`,options)}list(containerID,query={},options){return this._client.getAPIList(path`/containers/${containerID}/files`,CursorPage,{query,...options})}delete(fileID,params,options){const{container_id}=params;return this._client.delete(path`/containers/${container_id}/files/${fileID}`,{...options,headers:buildHeaders([{Accept:"*/*"},options?.headers])})}}Files.Content=Content;class Containers extends APIResource{constructor(){super(...arguments),this.files=new Files(this._client)}create(body,options){return this._client.post("/containers",{body,...options})}retrieve(containerID,options){return this._client.get(path`/containers/${containerID}`,options)}list(query={},options){return this._client.getAPIList("/containers",CursorPage,{query,...options})}delete(containerID,options){return this._client.delete(path`/containers/${containerID}`,{...options,headers:buildHeaders([{Accept:"*/*"},options?.headers])})}}Containers.Files=Files;class Embeddings extends APIResource{create(body,options){const hasUserProvidedEncodingFormat=!!body.encoding_format;let encoding_format=hasUserProvidedEncodingFormat?body.encoding_format:"base64";hasUserProvidedEncodingFormat&&loggerFor(this._client).debug("embeddings/user defined encoding_format:",body.encoding_format);const response=this._client.post("/embeddings",{body:{...body,encoding_format},...options});return hasUserProvidedEncodingFormat?response:(loggerFor(this._client).debug("embeddings/decoding base64 embeddings from base64"),response._thenUnwrap(response=>(response&&response.data&&response.data.forEach(embeddingBase64Obj=>{const embeddingBase64Str=embeddingBase64Obj.embedding;embeddingBase64Obj.embedding=(base64Str=>{if(void 0!==Buffer){const buf=Buffer.from(base64Str,"base64");return Array.from(new Float32Array(buf.buffer,buf.byteOffset,buf.length/Float32Array.BYTES_PER_ELEMENT))}{const binaryStr=atob(base64Str),len=binaryStr.length,bytes=new Uint8Array(len);for(let i=0;i<len;i++)bytes[i]=binaryStr.charCodeAt(i);return Array.from(new Float32Array(bytes.buffer))}})(embeddingBase64Str)}),response)))}}class OutputItems extends APIResource{retrieve(outputItemID,params,options){const{eval_id,run_id}=params;return this._client.get(path`/evals/${eval_id}/runs/${run_id}/output_items/${outputItemID}`,options)}list(runID,params,options){const{eval_id,...query}=params;return this._client.getAPIList(path`/evals/${eval_id}/runs/${runID}/output_items`,CursorPage,{query,...options})}}class runs_Runs extends APIResource{constructor(){super(...arguments),this.outputItems=new OutputItems(this._client)}create(evalID,body,options){return this._client.post(path`/evals/${evalID}/runs`,{body,...options})}retrieve(runID,params,options){const{eval_id}=params;return this._client.get(path`/evals/${eval_id}/runs/${runID}`,options)}list(evalID,query={},options){return this._client.getAPIList(path`/evals/${evalID}/runs`,CursorPage,{query,...options})}delete(runID,params,options){const{eval_id}=params;return this._client.delete(path`/evals/${eval_id}/runs/${runID}`,options)}cancel(runID,params,options){const{eval_id}=params;return this._client.post(path`/evals/${eval_id}/runs/${runID}`,options)}}runs_Runs.OutputItems=OutputItems;class Evals extends APIResource{constructor(){super(...arguments),this.runs=new runs_Runs(this._client)}create(body,options){return this._client.post("/evals",{body,...options})}retrieve(evalID,options){return this._client.get(path`/evals/${evalID}`,options)}update(evalID,body,options){return this._client.post(path`/evals/${evalID}`,{body,...options})}list(query={},options){return this._client.getAPIList("/evals",CursorPage,{query,...options})}delete(evalID,options){return this._client.delete(path`/evals/${evalID}`,options)}}Evals.Runs=runs_Runs;class files_Files extends APIResource{create(body,options){return this._client.post("/files",multipartFormRequestOptions({body,...options},this._client))}retrieve(fileID,options){return this._client.get(path`/files/${fileID}`,options)}list(query={},options){return this._client.getAPIList("/files",CursorPage,{query,...options})}delete(fileID,options){return this._client.delete(path`/files/${fileID}`,options)}content(fileID,options){return this._client.get(path`/files/${fileID}/content`,{...options,headers:buildHeaders([{Accept:"application/binary"},options?.headers]),__binaryResponse:!0})}async waitForProcessing(id,{pollInterval=5e3,maxWait=18e5}={}){const TERMINAL_STATES=new Set(["processed","error","deleted"]),start=Date.now();let file=await this.retrieve(id);for(;!file.status||!TERMINAL_STATES.has(file.status);)if(await sleep(pollInterval),file=await this.retrieve(id),Date.now()-start>maxWait)throw new APIConnectionTimeoutError({message:`Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`});return file}}class Methods extends APIResource{}class Graders extends APIResource{run(body,options){return this._client.post("/fine_tuning/alpha/graders/run",{body,...options})}validate(body,options){return this._client.post("/fine_tuning/alpha/graders/validate",{body,...options})}}class Alpha extends APIResource{constructor(){super(...arguments),this.graders=new Graders(this._client)}}Alpha.Graders=Graders;class Permissions extends APIResource{create(fineTunedModelCheckpoint,body,options){return this._client.getAPIList(path`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`,Page,{body,method:"post",...options})}retrieve(fineTunedModelCheckpoint,query={},options){return this._client.get(path`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`,{query,...options})}delete(permissionID,params,options){const{fine_tuned_model_checkpoint}=params;return this._client.delete(path`/fine_tuning/checkpoints/${fine_tuned_model_checkpoint}/permissions/${permissionID}`,options)}}class Checkpoints extends APIResource{constructor(){super(...arguments),this.permissions=new Permissions(this._client)}}Checkpoints.Permissions=Permissions;class checkpoints_Checkpoints extends APIResource{list(fineTuningJobID,query={},options){return this._client.getAPIList(path`/fine_tuning/jobs/${fineTuningJobID}/checkpoints`,CursorPage,{query,...options})}}class Jobs extends APIResource{constructor(){super(...arguments),this.checkpoints=new checkpoints_Checkpoints(this._client)}create(body,options){return this._client.post("/fine_tuning/jobs",{body,...options})}retrieve(fineTuningJobID,options){return this._client.get(path`/fine_tuning/jobs/${fineTuningJobID}`,options)}list(query={},options){return this._client.getAPIList("/fine_tuning/jobs",CursorPage,{query,...options})}cancel(fineTuningJobID,options){return this._client.post(path`/fine_tuning/jobs/${fineTuningJobID}/cancel`,options)}listEvents(fineTuningJobID,query={},options){return this._client.getAPIList(path`/fine_tuning/jobs/${fineTuningJobID}/events`,CursorPage,{query,...options})}pause(fineTuningJobID,options){return this._client.post(path`/fine_tuning/jobs/${fineTuningJobID}/pause`,options)}resume(fineTuningJobID,options){return this._client.post(path`/fine_tuning/jobs/${fineTuningJobID}/resume`,options)}}Jobs.Checkpoints=checkpoints_Checkpoints;class FineTuning extends APIResource{constructor(){super(...arguments),this.methods=new Methods(this._client),this.jobs=new Jobs(this._client),this.checkpoints=new Checkpoints(this._client),this.alpha=new Alpha(this._client)}}FineTuning.Methods=Methods,FineTuning.Jobs=Jobs,FineTuning.Checkpoints=Checkpoints,FineTuning.Alpha=Alpha;class GraderModels extends APIResource{}class graders_Graders extends APIResource{constructor(){super(...arguments),this.graderModels=new GraderModels(this._client)}}graders_Graders.GraderModels=GraderModels;class Images extends APIResource{createVariation(body,options){return this._client.post("/images/variations",multipartFormRequestOptions({body,...options},this._client))}edit(body,options){return this._client.post("/images/edits",multipartFormRequestOptions({body,...options},this._client))}generate(body,options){return this._client.post("/images/generations",{body,...options})}}class Models extends APIResource{retrieve(model,options){return this._client.get(path`/models/${model}`,options)}list(options){return this._client.getAPIList("/models",Page,options)}delete(model,options){return this._client.delete(path`/models/${model}`,options)}}class Moderations extends APIResource{create(body,options){return this._client.post("/moderations",{body,...options})}}function maybeParseResponse(response,params){return params&&function ResponsesParser_hasAutoParseableInput(params){if(isAutoParsableResponseFormat(params.text?.format))return!0;return!1}(params)?parseResponse(response,params):{...response,output_parsed:null,output:response.output.map(item=>"function_call"===item.type?{...item,parsed_arguments:null}:"message"===item.type?{...item,content:item.content.map(content=>({...content,parsed:null}))}:item)}}function parseResponse(response,params){const output=response.output.map(item=>{if("function_call"===item.type)return{...item,parsed_arguments:ResponsesParser_parseToolCall(params,item)};if("message"===item.type){const content=item.content.map(content=>"output_text"===content.type?{...content,parsed:parseTextFormat(params,content.text)}:content);return{...item,content}}return item}),parsed=Object.assign({},response,{output});return Object.getOwnPropertyDescriptor(response,"output_text")||addOutputText(parsed),Object.defineProperty(parsed,"output_parsed",{enumerable:!0,get(){for(const output of parsed.output)if("message"===output.type)for(const content of output.content)if("output_text"===content.type&&null!==content.parsed)return content.parsed;return null}}),parsed}function parseTextFormat(params,content){if("json_schema"!==params.text?.format?.type)return null;if("$parseRaw"in params.text?.format){const text_format=params.text?.format;return text_format.$parseRaw(content)}return JSON.parse(content)}function ResponsesParser_isAutoParsableTool(tool){return"auto-parseable-tool"===tool?.$brand}function getInputToolByName(input_tools,name){return input_tools.find(tool=>"function"===tool.type&&tool.name===name)}function ResponsesParser_parseToolCall(params,toolCall){const inputTool=getInputToolByName(params.tools??[],toolCall.name);return{...toolCall,...toolCall,parsed_arguments:ResponsesParser_isAutoParsableTool(inputTool)?inputTool.$parseRaw(toolCall.arguments):inputTool?.strict?JSON.parse(toolCall.arguments):null}}function addOutputText(rsp){const texts=[];for(const output of rsp.output)if("message"===output.type)for(const content of output.content)"output_text"===content.type&&texts.push(content.text);rsp.output_text=texts.join("")}class ResponseStream extends EventStream{constructor(params){super(),_ResponseStream_instances.add(this),_ResponseStream_params.set(this,void 0),_ResponseStream_currentResponseSnapshot.set(this,void 0),_ResponseStream_finalResponse.set(this,void 0),__classPrivateFieldSet(this,_ResponseStream_params,params,"f")}static createResponse(client,params,options){const runner=new ResponseStream(params);return runner._run(()=>runner._createOrRetrieveResponse(client,params,{...options,headers:{...options?.headers,"X-Stainless-Helper-Method":"stream"}})),runner}async _createOrRetrieveResponse(client,params,options){const signal=options?.signal;let stream;signal&&(signal.aborted&&this.controller.abort(),signal.addEventListener("abort",()=>this.controller.abort())),__classPrivateFieldGet(this,_ResponseStream_instances,"m",_ResponseStream_beginRequest).call(this);let starting_after=null;"response_id"in params?(stream=await client.responses.retrieve(params.response_id,{stream:!0},{...options,signal:this.controller.signal,stream:!0}),starting_after=params.starting_after??null):stream=await client.responses.create({...params,stream:!0},{...options,signal:this.controller.signal}),this._connected();for await(const event of stream)__classPrivateFieldGet(this,_ResponseStream_instances,"m",_ResponseStream_addEvent).call(this,event,starting_after);if(stream.controller.signal?.aborted)throw new APIUserAbortError;return __classPrivateFieldGet(this,_ResponseStream_instances,"m",_ResponseStream_endRequest).call(this)}[(_ResponseStream_params=new WeakMap,_ResponseStream_currentResponseSnapshot=new WeakMap,_ResponseStream_finalResponse=new WeakMap,_ResponseStream_instances=new WeakSet,_ResponseStream_beginRequest=function _ResponseStream_beginRequest(){this.ended||__classPrivateFieldSet(this,_ResponseStream_currentResponseSnapshot,void 0,"f")},_ResponseStream_addEvent=function _ResponseStream_addEvent(event,starting_after){if(this.ended)return;const maybeEmit=(name,event)=>{(null==starting_after||event.sequence_number>starting_after)&&this._emit(name,event)},response=__classPrivateFieldGet(this,_ResponseStream_instances,"m",_ResponseStream_accumulateResponse).call(this,event);switch(maybeEmit("event",event),event.type){case"response.output_text.delta":{const output=response.output[event.output_index];if(!output)throw new error_OpenAIError(`missing output at index ${event.output_index}`);if("message"===output.type){const content=output.content[event.content_index];if(!content)throw new error_OpenAIError(`missing content at index ${event.content_index}`);if("output_text"!==content.type)throw new error_OpenAIError(`expected content to be 'output_text', got ${content.type}`);maybeEmit("response.output_text.delta",{...event,snapshot:content.text})}break}case"response.function_call_arguments.delta":{const output=response.output[event.output_index];if(!output)throw new error_OpenAIError(`missing output at index ${event.output_index}`);"function_call"===output.type&&maybeEmit("response.function_call_arguments.delta",{...event,snapshot:output.arguments});break}default:maybeEmit(event.type,event)}},_ResponseStream_endRequest=function _ResponseStream_endRequest(){if(this.ended)throw new error_OpenAIError("stream has ended, this shouldn't happen");const snapshot=__classPrivateFieldGet(this,_ResponseStream_currentResponseSnapshot,"f");if(!snapshot)throw new error_OpenAIError("request ended without sending any events");__classPrivateFieldSet(this,_ResponseStream_currentResponseSnapshot,void 0,"f");const parsedResponse=function finalizeResponse(snapshot,params){return maybeParseResponse(snapshot,params)}(snapshot,__classPrivateFieldGet(this,_ResponseStream_params,"f"));return __classPrivateFieldSet(this,_ResponseStream_finalResponse,parsedResponse,"f"),parsedResponse},_ResponseStream_accumulateResponse=function _ResponseStream_accumulateResponse(event){let snapshot=__classPrivateFieldGet(this,_ResponseStream_currentResponseSnapshot,"f");if(!snapshot){if("response.created"!==event.type)throw new error_OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);return snapshot=__classPrivateFieldSet(this,_ResponseStream_currentResponseSnapshot,event.response,"f"),snapshot}switch(event.type){case"response.output_item.added":snapshot.output.push(event.item);break;case"response.content_part.added":{const output=snapshot.output[event.output_index];if(!output)throw new error_OpenAIError(`missing output at index ${event.output_index}`);"message"===output.type&&output.content.push(event.part);break}case"response.output_text.delta":{const output=snapshot.output[event.output_index];if(!output)throw new error_OpenAIError(`missing output at index ${event.output_index}`);if("message"===output.type){const content=output.content[event.content_index];if(!content)throw new error_OpenAIError(`missing content at index ${event.content_index}`);if("output_text"!==content.type)throw new error_OpenAIError(`expected content to be 'output_text', got ${content.type}`);content.text+=event.delta}break}case"response.function_call_arguments.delta":{const output=snapshot.output[event.output_index];if(!output)throw new error_OpenAIError(`missing output at index ${event.output_index}`);"function_call"===output.type&&(output.arguments+=event.delta);break}case"response.completed":__classPrivateFieldSet(this,_ResponseStream_currentResponseSnapshot,event.response,"f")}return snapshot},Symbol.asyncIterator)](){const pushQueue=[],readQueue=[];let done=!1;return this.on("event",event=>{const reader=readQueue.shift();reader?reader.resolve(event):pushQueue.push(event)}),this.on("end",()=>{done=!0;for(const reader of readQueue)reader.resolve(void 0);readQueue.length=0}),this.on("abort",err=>{done=!0;for(const reader of readQueue)reader.reject(err);readQueue.length=0}),this.on("error",err=>{done=!0;for(const reader of readQueue)reader.reject(err);readQueue.length=0}),{next:async()=>{if(!pushQueue.length)return done?{value:void 0,done:!0}:new Promise((resolve,reject)=>readQueue.push({resolve,reject})).then(event=>event?{value:event,done:!1}:{value:void 0,done:!0});return{value:pushQueue.shift(),done:!1}},return:async()=>(this.abort(),{value:void 0,done:!0})}}async finalResponse(){await this.done();const response=__classPrivateFieldGet(this,_ResponseStream_finalResponse,"f");if(!response)throw new error_OpenAIError("stream ended without producing a ChatCompletion");return response}}class InputItems extends APIResource{list(responseID,query={},options){return this._client.getAPIList(path`/responses/${responseID}/input_items`,CursorPage,{query,...options})}}class Responses extends APIResource{constructor(){super(...arguments),this.inputItems=new InputItems(this._client)}create(body,options){return this._client.post("/responses",{body,...options,stream:body.stream??!1})._thenUnwrap(rsp=>("object"in rsp&&"response"===rsp.object&&addOutputText(rsp),rsp))}retrieve(responseID,query={},options){return this._client.get(path`/responses/${responseID}`,{query,...options,stream:query?.stream??!1})._thenUnwrap(rsp=>("object"in rsp&&"response"===rsp.object&&addOutputText(rsp),rsp))}delete(responseID,options){return this._client.delete(path`/responses/${responseID}`,{...options,headers:buildHeaders([{Accept:"*/*"},options?.headers])})}parse(body,options){return this._client.responses.create(body,options)._thenUnwrap(response=>parseResponse(response,body))}stream(body,options){return ResponseStream.createResponse(this._client,body,options)}cancel(responseID,options){return this._client.post(path`/responses/${responseID}/cancel`,options)}}Responses.InputItems=InputItems;class Parts extends APIResource{create(uploadID,body,options){return this._client.post(path`/uploads/${uploadID}/parts`,multipartFormRequestOptions({body,...options},this._client))}}class Uploads extends APIResource{constructor(){super(...arguments),this.parts=new Parts(this._client)}create(body,options){return this._client.post("/uploads",{body,...options})}cancel(uploadID,options){return this._client.post(path`/uploads/${uploadID}/cancel`,options)}complete(uploadID,body,options){return this._client.post(path`/uploads/${uploadID}/complete`,{body,...options})}}Uploads.Parts=Parts;var Util_console=__webpack_require__("./node_modules/console-browserify/index.js");class FileBatches extends APIResource{create(vectorStoreID,body,options){return this._client.post(path`/vector_stores/${vectorStoreID}/file_batches`,{body,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}retrieve(batchID,params,options){const{vector_store_id}=params;return this._client.get(path`/vector_stores/${vector_store_id}/file_batches/${batchID}`,{...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}cancel(batchID,params,options){const{vector_store_id}=params;return this._client.post(path`/vector_stores/${vector_store_id}/file_batches/${batchID}/cancel`,{...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}async createAndPoll(vectorStoreId,body,options){const batch=await this.create(vectorStoreId,body);return await this.poll(vectorStoreId,batch.id,options)}listFiles(batchID,params,options){const{vector_store_id,...query}=params;return this._client.getAPIList(path`/vector_stores/${vector_store_id}/file_batches/${batchID}/files`,CursorPage,{query,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}async poll(vectorStoreID,batchID,options){const headers=buildHeaders([options?.headers,{"X-Stainless-Poll-Helper":"true","X-Stainless-Custom-Poll-Interval":options?.pollIntervalMs?.toString()??void 0}]);for(;;){const{data:batch,response}=await this.retrieve(batchID,{vector_store_id:vectorStoreID},{...options,headers}).withResponse();switch(batch.status){case"in_progress":let sleepInterval=5e3;if(options?.pollIntervalMs)sleepInterval=options.pollIntervalMs;else{const headerInterval=response.headers.get("openai-poll-after-ms");if(headerInterval){const headerIntervalMs=parseInt(headerInterval);isNaN(headerIntervalMs)||(sleepInterval=headerIntervalMs)}}await sleep(sleepInterval);break;case"failed":case"cancelled":case"completed":return batch}}}async uploadAndPoll(vectorStoreId,{files,fileIds=[]},options){if(null==files||0==files.length)throw new Error("No `files` provided to process. If you've already uploaded files you should use `.createAndPoll()` instead");const configuredConcurrency=options?.maxConcurrency??5,concurrencyLimit=Math.min(configuredConcurrency,files.length),client=this._client,fileIterator=files.values(),allFileIds=[...fileIds];const workers=Array(concurrencyLimit).fill(fileIterator).map(async function processFiles(iterator){for(let item of iterator){const fileObj=await client.files.create({file:item,purpose:"assistants"},options);allFileIds.push(fileObj.id)}});return await(async promises=>{const results=await Promise.allSettled(promises),rejected=results.filter(result=>"rejected"===result.status);if(rejected.length){for(const result of rejected)Util_console.error(result.reason);throw new Error(`${rejected.length} promise(s) failed - see the above errors`)}const values=[];for(const result of results)"fulfilled"===result.status&&values.push(result.value);return values})(workers),await this.createAndPoll(vectorStoreId,{file_ids:allFileIds})}}class vector_stores_files_Files extends APIResource{create(vectorStoreID,body,options){return this._client.post(path`/vector_stores/${vectorStoreID}/files`,{body,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}retrieve(fileID,params,options){const{vector_store_id}=params;return this._client.get(path`/vector_stores/${vector_store_id}/files/${fileID}`,{...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}update(fileID,params,options){const{vector_store_id,...body}=params;return this._client.post(path`/vector_stores/${vector_store_id}/files/${fileID}`,{body,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}list(vectorStoreID,query={},options){return this._client.getAPIList(path`/vector_stores/${vectorStoreID}/files`,CursorPage,{query,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}delete(fileID,params,options){const{vector_store_id}=params;return this._client.delete(path`/vector_stores/${vector_store_id}/files/${fileID}`,{...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}async createAndPoll(vectorStoreId,body,options){const file=await this.create(vectorStoreId,body,options);return await this.poll(vectorStoreId,file.id,options)}async poll(vectorStoreID,fileID,options){const headers=buildHeaders([options?.headers,{"X-Stainless-Poll-Helper":"true","X-Stainless-Custom-Poll-Interval":options?.pollIntervalMs?.toString()??void 0}]);for(;;){const fileResponse=await this.retrieve(fileID,{vector_store_id:vectorStoreID},{...options,headers}).withResponse(),file=fileResponse.data;switch(file.status){case"in_progress":let sleepInterval=5e3;if(options?.pollIntervalMs)sleepInterval=options.pollIntervalMs;else{const headerInterval=fileResponse.response.headers.get("openai-poll-after-ms");if(headerInterval){const headerIntervalMs=parseInt(headerInterval);isNaN(headerIntervalMs)||(sleepInterval=headerIntervalMs)}}await sleep(sleepInterval);break;case"failed":case"completed":return file}}}async upload(vectorStoreId,file,options){const fileInfo=await this._client.files.create({file,purpose:"assistants"},options);return this.create(vectorStoreId,{file_id:fileInfo.id},options)}async uploadAndPoll(vectorStoreId,file,options){const fileInfo=await this.upload(vectorStoreId,file,options);return await this.poll(vectorStoreId,fileInfo.id,options)}content(fileID,params,options){const{vector_store_id}=params;return this._client.getAPIList(path`/vector_stores/${vector_store_id}/files/${fileID}/content`,Page,{...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}}class VectorStores extends APIResource{constructor(){super(...arguments),this.files=new vector_stores_files_Files(this._client),this.fileBatches=new FileBatches(this._client)}create(body,options){return this._client.post("/vector_stores",{body,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}retrieve(vectorStoreID,options){return this._client.get(path`/vector_stores/${vectorStoreID}`,{...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}update(vectorStoreID,body,options){return this._client.post(path`/vector_stores/${vectorStoreID}`,{body,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}list(query={},options){return this._client.getAPIList("/vector_stores",CursorPage,{query,...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}delete(vectorStoreID,options){return this._client.delete(path`/vector_stores/${vectorStoreID}`,{...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}search(vectorStoreID,body,options){return this._client.getAPIList(path`/vector_stores/${vectorStoreID}/search`,Page,{body,method:"post",...options,headers:buildHeaders([{"OpenAI-Beta":"assistants=v2"},options?.headers])})}}VectorStores.Files=vector_stores_files_Files,VectorStores.FileBatches=FileBatches;var _Webhooks_instances,_Webhooks_validateSecret,_Webhooks_getRequiredHeader,webhooks_Buffer=__webpack_require__("./node_modules/buffer/index.js").Buffer;class Webhooks extends APIResource{constructor(){super(...arguments),_Webhooks_instances.add(this)}async unwrap(payload,headers,secret=this._client.webhookSecret,tolerance=300){return await this.verifySignature(payload,headers,secret,tolerance),JSON.parse(payload)}async verifySignature(payload,headers,secret=this._client.webhookSecret,tolerance=300){if("undefined"==typeof crypto||"function"!=typeof crypto.subtle.importKey||"function"!=typeof crypto.subtle.verify)throw new Error("Webhook signature verification is only supported when the `crypto` global is defined");__classPrivateFieldGet(this,_Webhooks_instances,"m",_Webhooks_validateSecret).call(this,secret);const headersObj=buildHeaders([headers]).values,signatureHeader=__classPrivateFieldGet(this,_Webhooks_instances,"m",_Webhooks_getRequiredHeader).call(this,headersObj,"webhook-signature"),timestamp=__classPrivateFieldGet(this,_Webhooks_instances,"m",_Webhooks_getRequiredHeader).call(this,headersObj,"webhook-timestamp"),webhookId=__classPrivateFieldGet(this,_Webhooks_instances,"m",_Webhooks_getRequiredHeader).call(this,headersObj,"webhook-id"),timestampSeconds=parseInt(timestamp,10);if(isNaN(timestampSeconds))throw new InvalidWebhookSignatureError("Invalid webhook timestamp format");const nowSeconds=Math.floor(Date.now()/1e3);if(nowSeconds-timestampSeconds>tolerance)throw new InvalidWebhookSignatureError("Webhook timestamp is too old");if(timestampSeconds>nowSeconds+tolerance)throw new InvalidWebhookSignatureError("Webhook timestamp is too new");const signatures=signatureHeader.split(" ").map(part=>part.startsWith("v1,")?part.substring(3):part),decodedSecret=secret.startsWith("whsec_")?webhooks_Buffer.from(secret.replace("whsec_",""),"base64"):webhooks_Buffer.from(secret,"utf-8"),signedPayload=webhookId?`${webhookId}.${timestamp}.${payload}`:`${timestamp}.${payload}`,key=await crypto.subtle.importKey("raw",decodedSecret,{name:"HMAC",hash:"SHA-256"},!1,["verify"]);for(const signature of signatures)try{const signatureBytes=webhooks_Buffer.from(signature,"base64");if(await crypto.subtle.verify("HMAC",key,signatureBytes,(new TextEncoder).encode(signedPayload)))return}catch{continue}throw new InvalidWebhookSignatureError("The given webhook signature does not match the expected signature")}}_Webhooks_instances=new WeakSet,_Webhooks_validateSecret=function _Webhooks_validateSecret(secret){if("string"!=typeof secret||0===secret.length)throw new Error("The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function")},_Webhooks_getRequiredHeader=function _Webhooks_getRequiredHeader(headers,name){if(!headers)throw new Error("Headers are required");const value=headers.get(name);if(null==value)throw new Error(`Missing required header: ${name}`);return value};var _OpenAI_instances,client_a,_OpenAI_encoder,_OpenAI_baseURLOverridden,client_console=__webpack_require__("./node_modules/console-browserify/index.js");class OpenAI{constructor({baseURL=readEnv("OPENAI_BASE_URL"),apiKey=readEnv("OPENAI_API_KEY"),organization=readEnv("OPENAI_ORG_ID")??null,project=readEnv("OPENAI_PROJECT_ID")??null,webhookSecret=readEnv("OPENAI_WEBHOOK_SECRET")??null,...opts}={}){if(_OpenAI_instances.add(this),_OpenAI_encoder.set(this,void 0),this.completions=new completions_Completions(this),this.chat=new Chat(this),this.embeddings=new Embeddings(this),this.files=new files_Files(this),this.images=new Images(this),this.audio=new Audio(this),this.moderations=new Moderations(this),this.models=new Models(this),this.fineTuning=new FineTuning(this),this.graders=new graders_Graders(this),this.vectorStores=new VectorStores(this),this.webhooks=new Webhooks(this),this.beta=new Beta(this),this.batches=new Batches(this),this.uploads=new Uploads(this),this.responses=new Responses(this),this.evals=new Evals(this),this.containers=new Containers(this),void 0===apiKey)throw new error_OpenAIError("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");const options={apiKey,organization,project,webhookSecret,...opts,baseURL:baseURL||"https://api.openai.com/v1"};if(!options.dangerouslyAllowBrowser&&"undefined"!=typeof window&&void 0!==window.document&&"undefined"!=typeof navigator)throw new error_OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");this.baseURL=options.baseURL,this.timeout=options.timeout??client_a.DEFAULT_TIMEOUT,this.logger=options.logger??client_console;this.logLevel="warn",this.logLevel=parseLogLevel(options.logLevel,"ClientOptions.logLevel",this)??parseLogLevel(readEnv("OPENAI_LOG"),"process.env['OPENAI_LOG']",this)??"warn",this.fetchOptions=options.fetchOptions,this.maxRetries=options.maxRetries??2,this.fetch=options.fetch??function getDefaultFetch(){if("undefined"!=typeof fetch)return fetch;throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`")}(),__classPrivateFieldSet(this,_OpenAI_encoder,FallbackEncoder,"f"),this._options=options,this.apiKey=apiKey,this.organization=organization,this.project=project,this.webhookSecret=webhookSecret}withOptions(options){return new this.constructor({...this._options,baseURL:this.baseURL,maxRetries:this.maxRetries,timeout:this.timeout,logger:this.logger,logLevel:this.logLevel,fetch:this.fetch,fetchOptions:this.fetchOptions,apiKey:this.apiKey,organization:this.organization,project:this.project,webhookSecret:this.webhookSecret,...options})}defaultQuery(){return this._options.defaultQuery}validateHeaders({values,nulls}){}authHeaders(opts){return buildHeaders([{Authorization:`Bearer ${this.apiKey}`}])}stringifyQuery(query){return stringify(query,{arrayFormat:"brackets"})}getUserAgent(){return`${this.constructor.name}/JS 5.8.2`}defaultIdempotencyKey(){return`stainless-node-retry-${uuid4()}`}makeStatusError(status,error,message,headers){return APIError.generate(status,error,message,headers)}buildURL(path,query,defaultBaseURL){const baseURL=!__classPrivateFieldGet(this,_OpenAI_instances,"m",_OpenAI_baseURLOverridden).call(this)&&defaultBaseURL||this.baseURL,url=(url=>startsWithSchemeRegexp.test(url))(path)?new URL(path):new URL(baseURL+(baseURL.endsWith("/")&&path.startsWith("/")?path.slice(1):path)),defaultQuery=this.defaultQuery();return function isEmptyObj(obj){if(!obj)return!0;for(const _k in obj)return!1;return!0}(defaultQuery)||(query={...defaultQuery,...query}),"object"==typeof query&&query&&!Array.isArray(query)&&(url.search=this.stringifyQuery(query)),url.toString()}async prepareOptions(options){}async prepareRequest(request,{url,options}){}get(path,opts){return this.methodRequest("get",path,opts)}post(path,opts){return this.methodRequest("post",path,opts)}patch(path,opts){return this.methodRequest("patch",path,opts)}put(path,opts){return this.methodRequest("put",path,opts)}delete(path,opts){return this.methodRequest("delete",path,opts)}methodRequest(method,path,opts){return this.request(Promise.resolve(opts).then(opts=>({method,path,...opts})))}request(options,remainingRetries=null){return new APIPromise(this,this.makeRequest(options,remainingRetries,void 0))}async makeRequest(optionsInput,retriesRemaining,retryOfRequestLogID){const options=await optionsInput,maxRetries=options.maxRetries??this.maxRetries;null==retriesRemaining&&(retriesRemaining=maxRetries),await this.prepareOptions(options);const{req,url,timeout}=this.buildRequest(options,{retryCount:maxRetries-retriesRemaining});await this.prepareRequest(req,{url,options});const requestLogID="log_"+(Math.random()*(1<<24)|0).toString(16).padStart(6,"0"),retryLogStr=void 0===retryOfRequestLogID?"":`, retryOf: ${retryOfRequestLogID}`,startTime=Date.now();if(loggerFor(this).debug(`[${requestLogID}] sending request`,formatRequestDetails({retryOfRequestLogID,method:options.method,url,options,headers:req.headers})),options.signal?.aborted)throw new APIUserAbortError;const controller=new AbortController,response=await this.fetchWithTimeout(url,req,timeout,controller).catch(castToError),headersTime=Date.now();if(response instanceof Error){const retryMessage=`retrying, ${retriesRemaining} attempts remaining`;if(options.signal?.aborted)throw new APIUserAbortError;const isTimeout=isAbortError(response)||/timed? ?out/i.test(String(response)+("cause"in response?String(response.cause):""));if(retriesRemaining)return loggerFor(this).info(`[${requestLogID}] connection ${isTimeout?"timed out":"failed"} - ${retryMessage}`),loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout?"timed out":"failed"} (${retryMessage})`,formatRequestDetails({retryOfRequestLogID,url,durationMs:headersTime-startTime,message:response.message})),this.retryRequest(options,retriesRemaining,retryOfRequestLogID??requestLogID);if(loggerFor(this).info(`[${requestLogID}] connection ${isTimeout?"timed out":"failed"} - error; no more retries left`),loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout?"timed out":"failed"} (error; no more retries left)`,formatRequestDetails({retryOfRequestLogID,url,durationMs:headersTime-startTime,message:response.message})),isTimeout)throw new APIConnectionTimeoutError;throw new APIConnectionError({cause:response})}const responseInfo=`[${requestLogID}${retryLogStr}${[...response.headers.entries()].filter(([name])=>"x-request-id"===name).map(([name,value])=>", "+name+": "+JSON.stringify(value)).join("")}] ${req.method} ${url} ${response.ok?"succeeded":"failed"} with status ${response.status} in ${headersTime-startTime}ms`;if(!response.ok){const shouldRetry=this.shouldRetry(response);if(retriesRemaining&&shouldRetry){const retryMessage=`retrying, ${retriesRemaining} attempts remaining`;return await async function CancelReadableStream(stream){if(null===stream||"object"!=typeof stream)return;if(stream[Symbol.asyncIterator])return void await(stream[Symbol.asyncIterator]().return?.());const reader=stream.getReader(),cancelPromise=reader.cancel();reader.releaseLock(),await cancelPromise}(response.body),loggerFor(this).info(`${responseInfo} - ${retryMessage}`),loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`,formatRequestDetails({retryOfRequestLogID,url:response.url,status:response.status,headers:response.headers,durationMs:headersTime-startTime})),this.retryRequest(options,retriesRemaining,retryOfRequestLogID??requestLogID,response.headers)}const retryMessage=shouldRetry?"error; no more retries left":"error; not retryable";loggerFor(this).info(`${responseInfo} - ${retryMessage}`);const errText=await response.text().catch(err=>castToError(err).message),errJSON=(text=>{try{return JSON.parse(text)}catch(err){return}})(errText),errMessage=errJSON?void 0:errText;loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`,formatRequestDetails({retryOfRequestLogID,url:response.url,status:response.status,headers:response.headers,message:errMessage,durationMs:Date.now()-startTime}));throw this.makeStatusError(response.status,errJSON,errMessage,response.headers)}return loggerFor(this).info(responseInfo),loggerFor(this).debug(`[${requestLogID}] response start`,formatRequestDetails({retryOfRequestLogID,url:response.url,status:response.status,headers:response.headers,durationMs:headersTime-startTime})),{response,options,controller,requestLogID,retryOfRequestLogID,startTime}}getAPIList(path,Page,opts){return this.requestAPIList(Page,{method:"get",path,...opts})}requestAPIList(Page,options){const request=this.makeRequest(options,null,void 0);return new PagePromise(this,request,Page)}async fetchWithTimeout(url,init,ms,controller){const{signal,method,...options}=init||{};signal&&signal.addEventListener("abort",()=>controller.abort());const timeout=setTimeout(()=>controller.abort(),ms),isReadableBody=globalThis.ReadableStream&&options.body instanceof globalThis.ReadableStream||"object"==typeof options.body&&null!==options.body&&Symbol.asyncIterator in options.body,fetchOptions={signal:controller.signal,...isReadableBody?{duplex:"half"}:{},method:"GET",...options};method&&(fetchOptions.method=method.toUpperCase());try{return await this.fetch.call(void 0,url,fetchOptions)}finally{clearTimeout(timeout)}}shouldRetry(response){const shouldRetryHeader=response.headers.get("x-should-retry");return"true"===shouldRetryHeader||"false"!==shouldRetryHeader&&(408===response.status||(409===response.status||(429===response.status||response.status>=500)))}async retryRequest(options,retriesRemaining,requestLogID,responseHeaders){let timeoutMillis;const retryAfterMillisHeader=responseHeaders?.get("retry-after-ms");if(retryAfterMillisHeader){const timeoutMs=parseFloat(retryAfterMillisHeader);Number.isNaN(timeoutMs)||(timeoutMillis=timeoutMs)}const retryAfterHeader=responseHeaders?.get("retry-after");if(retryAfterHeader&&!timeoutMillis){const timeoutSeconds=parseFloat(retryAfterHeader);timeoutMillis=Number.isNaN(timeoutSeconds)?Date.parse(retryAfterHeader)-Date.now():1e3*timeoutSeconds}if(!(timeoutMillis&&0<=timeoutMillis&&timeoutMillis<6e4)){const maxRetries=options.maxRetries??this.maxRetries;timeoutMillis=this.calculateDefaultRetryTimeoutMillis(retriesRemaining,maxRetries)}return await sleep(timeoutMillis),this.makeRequest(options,retriesRemaining-1,requestLogID)}calculateDefaultRetryTimeoutMillis(retriesRemaining,maxRetries){const numRetries=maxRetries-retriesRemaining;return Math.min(.5*Math.pow(2,numRetries),8)*(1-.25*Math.random())*1e3}buildRequest(inputOptions,{retryCount=0}={}){const options={...inputOptions},{method,path,query,defaultBaseURL}=options,url=this.buildURL(path,query,defaultBaseURL);"timeout"in options&&((name,n)=>{if("number"!=typeof n||!Number.isInteger(n))throw new error_OpenAIError(`${name} must be an integer`);if(n<0)throw new error_OpenAIError(`${name} must be a positive integer`)})("timeout",options.timeout),options.timeout=options.timeout??this.timeout;const{bodyHeaders,body}=this.buildBody({options});return{req:{method,headers:this.buildHeaders({options:inputOptions,method,bodyHeaders,retryCount}),...options.signal&&{signal:options.signal},...globalThis.ReadableStream&&body instanceof globalThis.ReadableStream&&{duplex:"half"},...body&&{body},...this.fetchOptions??{},...options.fetchOptions??{}},url,timeout:options.timeout}}buildHeaders({options,method,bodyHeaders,retryCount}){let idempotencyHeaders={};this.idempotencyHeader&&"get"!==method&&(options.idempotencyKey||(options.idempotencyKey=this.defaultIdempotencyKey()),idempotencyHeaders[this.idempotencyHeader]=options.idempotencyKey);const headers=buildHeaders([idempotencyHeaders,{Accept:"application/json","User-Agent":this.getUserAgent(),"X-Stainless-Retry-Count":String(retryCount),...options.timeout?{"X-Stainless-Timeout":String(Math.trunc(options.timeout/1e3))}:{},..._platformHeaders??(_platformHeaders=getPlatformProperties()),"OpenAI-Organization":this.organization,"OpenAI-Project":this.project},this.authHeaders(options),this._options.defaultHeaders,bodyHeaders,options.headers]);return this.validateHeaders(headers),headers.values}buildBody({options:{body,headers:rawHeaders}}){if(!body)return{bodyHeaders:void 0,body:void 0};const headers=buildHeaders([rawHeaders]);return ArrayBuffer.isView(body)||body instanceof ArrayBuffer||body instanceof DataView||"string"==typeof body&&headers.values.has("content-type")||body instanceof Blob||body instanceof FormData||body instanceof URLSearchParams||globalThis.ReadableStream&&body instanceof globalThis.ReadableStream?{bodyHeaders:void 0,body}:"object"==typeof body&&(Symbol.asyncIterator in body||Symbol.iterator in body&&"next"in body&&"function"==typeof body.next)?{bodyHeaders:void 0,body:ReadableStreamFrom(body)}:__classPrivateFieldGet(this,_OpenAI_encoder,"f").call(this,{body,headers})}}client_a=OpenAI,_OpenAI_encoder=new WeakMap,_OpenAI_instances=new WeakSet,_OpenAI_baseURLOverridden=function _OpenAI_baseURLOverridden(){return"https://api.openai.com/v1"!==this.baseURL},OpenAI.OpenAI=client_a,OpenAI.DEFAULT_TIMEOUT=6e5,OpenAI.OpenAIError=error_OpenAIError,OpenAI.APIError=APIError,OpenAI.APIConnectionError=APIConnectionError,OpenAI.APIConnectionTimeoutError=APIConnectionTimeoutError,OpenAI.APIUserAbortError=APIUserAbortError,OpenAI.NotFoundError=NotFoundError,OpenAI.ConflictError=ConflictError,OpenAI.RateLimitError=RateLimitError,OpenAI.BadRequestError=BadRequestError,OpenAI.AuthenticationError=AuthenticationError,OpenAI.InternalServerError=InternalServerError,OpenAI.PermissionDeniedError=PermissionDeniedError,OpenAI.UnprocessableEntityError=UnprocessableEntityError,OpenAI.InvalidWebhookSignatureError=InvalidWebhookSignatureError,OpenAI.toFile=async function toFile(value,name,options){if(checkFileSupport(),(value=>null!=value&&"object"==typeof value&&"string"==typeof value.name&&"number"==typeof value.lastModified&&isBlobLike(value))(value=await value))return value instanceof File?value:makeFile([await value.arrayBuffer()],value.name);if((value=>null!=value&&"object"==typeof value&&"string"==typeof value.url&&"function"==typeof value.blob)(value)){const blob=await value.blob();return name||(name=new URL(value.url).pathname.split(/[\\/]/).pop()),makeFile(await getBytes(blob),name,options)}const parts=await getBytes(value);if(name||(name=getName(value)),!options?.type){const type=parts.find(part=>"object"==typeof part&&"type"in part&&part.type);"string"==typeof type&&(options={...options,type})}return makeFile(parts,name,options)},OpenAI.Completions=completions_Completions,OpenAI.Chat=Chat,OpenAI.Embeddings=Embeddings,OpenAI.Files=files_Files,OpenAI.Images=Images,OpenAI.Audio=Audio,OpenAI.Moderations=Moderations,OpenAI.Models=Models,OpenAI.FineTuning=FineTuning,OpenAI.Graders=graders_Graders,OpenAI.VectorStores=VectorStores,OpenAI.Webhooks=Webhooks,OpenAI.Beta=Beta,OpenAI.Batches=Batches,OpenAI.Uploads=Uploads,OpenAI.Responses=Responses,OpenAI.Evals=Evals,OpenAI.Containers=Containers;__webpack_require__("./node_modules/process/browser.js");new Set(["/completions","/chat/completions","/embeddings","/audio/transcriptions","/audio/translations","/audio/speech","/images/generations","/batches","/images/edits"])}}]);