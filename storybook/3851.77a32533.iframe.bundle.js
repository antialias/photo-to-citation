/*! For license information please see 3851.77a32533.iframe.bundle.js.LICENSE.txt */
(self.webpackChunkapp_scaffold=self.webpackChunkapp_scaffold||[]).push([[3851],{"./node_modules/@tensorflow/tfjs-backend-wasm/dist/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{BackendWasm:()=>BackendWasm,getThreadsCount:()=>getThreadsCount,setThreadsCount:()=>setThreadsCount,setWasmPath:()=>setWasmPath,setWasmPaths:()=>setWasmPaths,version_wasm:()=>version});var CppDType,FusableActivation,dist=__webpack_require__("./node_modules/@tensorflow/tfjs-core/dist/index.js");let wasmFusedMatMul;!function(CppDType){CppDType[CppDType.float32=0]="float32",CppDType[CppDType.int32=1]="int32",CppDType[CppDType.bool=2]="bool",CppDType[CppDType.string=3]="string",CppDType[CppDType.complex64=4]="complex64"}(CppDType||(CppDType={})),function(FusableActivation){FusableActivation[FusableActivation.linear=0]="linear",FusableActivation[FusableActivation.relu=1]="relu",FusableActivation[FusableActivation.relu6=2]="relu6",FusableActivation[FusableActivation.prelu=3]="prelu",FusableActivation[FusableActivation.leakyrelu=4]="leakyrelu",FusableActivation[FusableActivation.sigmoid=5]="sigmoid",FusableActivation[FusableActivation.elu=6]="elu"}(FusableActivation||(FusableActivation={}));const _fusedMatMulConfig={kernelName:dist.Dr,backendName:"wasm",setupFunc:function setup(backend){wasmFusedMatMul=backend.wasm.cwrap(dist.Dr,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])},kernelFunc:function fusedBatchMatMul(args){const{inputs,backend,attrs}=args,{a,b,bias,preluActivationWeights}=inputs;if("float32"!==a.dtype||"float32"!==b.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");const{transposeA,transposeB,activation,leakyreluAlpha}=attrs,aId=backend.dataIdMap.get(a.dataId).id,bId=backend.dataIdMap.get(b.dataId).id;let biasId=0;if(null!=bias){const biasData=backend.dataIdMap.get(bias.dataId);if(1!==biasData.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${biasData.shape.length}.`);biasId=biasData.id}const preluActivationWeightsId=null==preluActivationWeights?0:backend.dataIdMap.get(preluActivationWeights.dataId).id,fusedActivation=FusableActivation[activation];if(null==fusedActivation)throw new Error(`${activation} activation not yet supported for FusedConv2D in the wasm backend.`);const leftDim=transposeA?a.shape[2]:a.shape[1],rightDim=transposeB?b.shape[1]:b.shape[2],batchDims=dist.ZEY.assertAndGetBroadcastShape(a.shape.slice(0,-2),b.shape.slice(0,-2)),out=backend.makeOutput([...batchDims,leftDim,rightDim],a.dtype),outId=backend.dataIdMap.get(out.dataId).id,aShapeBytes=new Uint8Array(new Int32Array(a.shape).buffer),bShapeBytes=new Uint8Array(new Int32Array(b.shape).buffer);return wasmFusedMatMul(aId,aShapeBytes,a.shape.length,bId,bShapeBytes,b.shape.length,transposeA,transposeB,fusedActivation,biasId,preluActivationWeightsId,leakyreluAlpha||0,outId),out}};function createUnaryKernelConfig(kernelName,outType){let wasmFunc;return{kernelName,backendName:"wasm",setupFunc:function setupFunc(backend){wasmFunc=backend.wasm.cwrap(kernelName,null,["number","number","number"])},kernelFunc:function kernelFunc(args){const{backend,inputs:{x}}=args,xId=backend.dataIdMap.get(x.dataId).id,out=backend.makeOutput(x.shape,outType||x.dtype),outId=backend.dataIdMap.get(out.dataId).id;return 0===dist.ZSL.sizeFromShape(out.shape)||wasmFunc(xId,CppDType[x.dtype],outId),out}}}const absConfig=createUnaryKernelConfig(dist.ljI),acosConfig=createUnaryKernelConfig(dist.Vvy),acoshConfig=createUnaryKernelConfig(dist.PH8);function createBinaryKernelConfig(kernelName,supportsFullBroadcast,dtype){let wasmFunc;return{kernelName,backendName:"wasm",setupFunc:function setupFunc(backend){wasmFunc=backend.wasm.cwrap(kernelName,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function kernelFunc(args){const{backend,inputs}=args,{a,b}=inputs,aId=backend.dataIdMap.get(a.dataId).id,bId=backend.dataIdMap.get(b.dataId).id,outputType=null!=dtype?dtype:a.dtype,newShape=dist.C0T.assertAndGetBroadcastShape(a.shape,b.shape),out=backend.makeOutput(newShape,outputType);if(0===dist.ZSL.sizeFromShape(newShape))return out;const aShapeBytes=new Uint8Array(new Int32Array(a.shape).buffer),bShapeBytes=new Uint8Array(new Int32Array(b.shape).buffer),outId=backend.dataIdMap.get(out.dataId).id;return wasmFunc(aId,aShapeBytes,a.shape.length,bId,bShapeBytes,b.shape.length,CppDType[a.dtype],outId),out}}}const addConfig=createBinaryKernelConfig(dist.OMN);let wasmFunc;const addNConfig={kernelName:dist.EkD,backendName:"wasm",setupFunc:function setupFunc(backend){wasmFunc=backend.wasm.cwrap(dist.EkD,null,["array","number","number","number"])},kernelFunc:function addn(args){const{inputs,backend}=args,out=backend.makeOutput(inputs[0].shape,inputs[0].dtype);if(0===dist.ZSL.sizeFromShape(out.shape))return out;const inputIds=inputs.map(x=>backend.dataIdMap.get(x.dataId).id),inputIdsBytes=new Uint8Array(new Int32Array(inputIds).buffer),outId=backend.dataIdMap.get(out.dataId).id;return wasmFunc(inputIdsBytes,inputIds.length,CppDType[out.dtype],outId),out}};function identity(args){const{inputs:{x},backend}=args;if("string"===x.dtype)return(0,dist.OEK)(backend.readSync(x.dataId),x.shape,x.dtype);const out=backend.makeOutput(x.shape,x.dtype),inVals=backend.typedArrayFromHeap(x);return backend.typedArrayFromHeap(out).set(inVals),out}const identityConfig={kernelName:dist.lzr,backendName:"wasm",kernelFunc:identity};let wasmTranspose;function transpose(args){const{inputs,backend,attrs}=args,[reducedShape,perm]=function removeOneSizeDims(shape,perm){const newShape=[],newPerm=[];for(let i=0;i<shape.length;++i)1!==shape[i]&&newShape.push(shape[i]),1!==shape[perm[i]]&&newPerm.push(perm[i]);for(let i=0;i<newPerm.length;++i){let minValIdx=-1;for(let j=0;j<newPerm.length;++j)newPerm[j]>=i&&(-1===minValIdx||newPerm[minValIdx]>newPerm[j])&&(minValIdx=j);newPerm[minValIdx]=i}return[newShape,newPerm]}(inputs.x.shape,attrs.perm);let permIsNoOp=!0;for(let i=0;i<perm.length;i++)perm[i]!==i&&(permIsNoOp=!1);const outShape=function computeOutShape(inShape,perm){const outShape=new Array(inShape.length);for(let i=0;i<outShape.length;i++)outShape[i]=inShape[perm[i]];return outShape}(inputs.x.shape,attrs.perm),x={dataId:inputs.x.dataId,shape:reducedShape,dtype:inputs.x.dtype};if(permIsNoOp){const cloned=identity({inputs,backend});return cloned.shape=outShape,cloned}const out=backend.makeOutput(outShape,x.dtype),xId=backend.dataIdMap.get(x.dataId).id,outId=backend.dataIdMap.get(out.dataId).id,permBytes=new Uint8Array(new Int32Array(perm).buffer),xShapeBytes=new Uint8Array(new Int32Array(x.shape).buffer);return wasmTranspose(xId,xShapeBytes,x.shape.length,CppDType[x.dtype],outId,permBytes,perm.length),out}const transposeConfig={kernelName:dist.wx0,backendName:"wasm",kernelFunc:transpose,setupFunc:function Transpose_setup(backend){wasmTranspose=backend.wasm.cwrap(dist.wx0,null,["number","array","number","number","number","array","number"])}};function permuteAxesAndTranspose(x,axis,backend){const xShape=x.shape,xRank=x.shape.length,originalAxes=dist.ZSL.parseAxisParam(axis,xShape);let axes=originalAxes;const permutedAxes=dist.C0T.getAxesPermutation(axes,xRank);let xTransposed=null,inputWasTransposed=!1;if(null!=permutedAxes){const newShape=new Array(xRank);for(let i=0;i<newShape.length;i++)newShape[i]=xShape[permutedAxes[i]];axes=dist.C0T.getInnerMostAxes(axes.length,xRank),xTransposed=transpose({inputs:{x},attrs:{perm:permutedAxes},backend});const xId=backend.dataIdMap.get(x.dataId).id;backend.dataIdMap.get(xTransposed.dataId).id!==xId&&(inputWasTransposed=!0)}return{transposed:xTransposed,originalAxes,axes,inputWasTransposed}}let wasmAll;const allConfig={kernelName:dist.u8Z,backendName:"wasm",setupFunc:function All_setup(backend){wasmAll=backend.wasm.cwrap(dist.u8Z,null,["number, number, number"])},kernelFunc:function All_all(args){const{backend,inputs,attrs}=args,{axis,keepDims}=attrs,{x}=inputs;let inputId=backend.dataIdMap.get(x.dataId).id,input=x;const{transposed,axes,originalAxes,inputWasTransposed}=permuteAxesAndTranspose(x,axis,backend);if(inputWasTransposed){input=transposed,inputId=backend.dataIdMap.get(transposed.dataId).id}const inputRank=input.shape.length;dist.C0T.assertAxesAreInnerMostDims("all",axes,inputRank);const[outShape,reduceShape]=dist.C0T.computeOutAndReduceShapes(input.shape,axes),reduceSize=dist.ZSL.sizeFromShape(reduceShape),out=backend.makeOutput(outShape,x.dtype);if(0!==dist.ZSL.sizeFromShape(input.shape)){const outId=backend.dataIdMap.get(out.dataId).id;wasmAll(inputId,reduceSize,outId)}if(inputWasTransposed&&backend.disposeData(transposed.dataId),keepDims){const newShape=dist.C0T.expandShapeToKeepDim(out.shape,originalAxes);out.shape=newShape}return out}};let wasmAny;const anyConfig={kernelName:dist.FSt,backendName:"wasm",setupFunc:function Any_setup(backend){wasmAny=backend.wasm.cwrap(dist.FSt,null,["number, number, number"])},kernelFunc:function any(args){const{backend,inputs,attrs}=args,{axis,keepDims}=attrs,{x}=inputs;let inputId=backend.dataIdMap.get(x.dataId).id,input=x;const{transposed,axes,originalAxes,inputWasTransposed}=permuteAxesAndTranspose(x,axis,backend);if(inputWasTransposed){input=transposed,inputId=backend.dataIdMap.get(transposed.dataId).id}const inputRank=input.shape.length;dist.C0T.assertAxesAreInnerMostDims("any",axes,inputRank);const[outShape,reduceShape]=dist.C0T.computeOutAndReduceShapes(input.shape,axes),reduceSize=dist.ZSL.sizeFromShape(reduceShape),out=backend.makeOutput(outShape,x.dtype);if(0!==dist.ZSL.sizeFromShape(input.shape)){const outId=backend.dataIdMap.get(out.dataId).id;wasmAny(inputId,reduceSize,outId)}if(inputWasTransposed&&backend.disposeData(transposed.dataId),keepDims){const newShape=dist.C0T.expandShapeToKeepDim(out.shape,originalAxes);out.shape=newShape}return out}};function createArgMinMaxKernelConfig(kernelName){let wasmFunc;return{kernelName,backendName:"wasm",setupFunc:function setupFunc(backend){wasmFunc=backend.wasm.cwrap(kernelName,null,["number","number","number","number","number"])},kernelFunc:function kernelFunc(args){const{backend,inputs,attrs}=args,{axis}=attrs,{x}=inputs,xId=backend.dataIdMap.get(x.dataId).id;let inputId=xId,input=x;const{transposed,axes,inputWasTransposed}=permuteAxesAndTranspose(x,axis,backend);if(inputWasTransposed){const transposedId=backend.dataIdMap.get(transposed.dataId).id;transposedId!==xId&&(input=transposed,inputId=transposedId)}const outShape=input.shape.slice(0,-1),out=backend.makeOutput(outShape,"int32"),outId=backend.dataIdMap.get(out.dataId).id,outerSize=dist.ZSL.sizeFromShape(out.shape),innerSize=input.shape[axes[0]];return wasmFunc(inputId,CppDType[input.dtype],outerSize,innerSize,outId),inputWasTransposed&&backend.disposeData(transposed.dataId),out}}}const argMaxConfig=createArgMinMaxKernelConfig(dist.Jp_),argMinConfig=createArgMinMaxKernelConfig(dist.p_m),asinConfig=createUnaryKernelConfig(dist.QKF),asinhConfig=createUnaryKernelConfig(dist.epO),atanConfig=createUnaryKernelConfig(dist.TyE),atan2Config=createBinaryKernelConfig(dist.lxb),atanhConfig=createUnaryKernelConfig(dist.zP9);let wasmAvgPool;const avgPoolConfig={kernelName:dist.ho8,backendName:"wasm",setupFunc:function AvgPool_setup(backend){wasmAvgPool=backend.wasm.cwrap(dist.ho8,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function avgPool(args){const{inputs,attrs,backend}=args,x=inputs.x,xId=backend.dataIdMap.get(x.dataId).id,{filterSize,strides,pad,dimRoundingMode}=attrs,convInfo=dist.C0T.computePool2DInfo(x.shape,filterSize,strides,1,pad,dimRoundingMode),filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,padTop=convInfo.padInfo.top,padRight=convInfo.padInfo.right,padBottom=convInfo.padInfo.bottom,padLeft=convInfo.padInfo.left,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,channels=convInfo.inChannels;if("channelsLast"!==convInfo.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${convInfo.dataFormat}'. Please use 'channelsLast'.`);if(1!==convInfo.dilationWidth||1!==convInfo.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${convInfo.dilationHeight}, ${convInfo.dilationWidth}].`);const out=backend.makeOutput(convInfo.outShape,"float32"),outId=backend.dataIdMap.get(out.dataId).id;return wasmAvgPool(xId,x.shape[0],x.shape[1],x.shape[2],filterHeight,filterWidth,padTop,padRight,padBottom,padLeft,strideHeight,strideWidth,channels,outId),out}};let wasmAvgPool3D;const avgPool3DConfig={kernelName:dist.cS,backendName:"wasm",setupFunc:function AvgPool3D_setup(backend){wasmAvgPool3D=backend.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function avgPool3D(args){const{inputs,backend,attrs}=args,{x}=inputs,{filterSize,strides,pad,dimRoundingMode,dataFormat}=attrs,convInfo=dist.C0T.computePool3DInfo(x.shape,filterSize,strides,1,pad,dimRoundingMode,dataFormat),out=backend.makeOutput(convInfo.outShape,x.dtype);return wasmAvgPool3D(backend.dataIdMap.get(x.dataId).id,backend.dataIdMap.get(out.dataId).id,convInfo.batchSize,convInfo.inChannels,convInfo.inDepth,convInfo.inHeight,convInfo.inWidth,convInfo.outDepth,convInfo.outHeight,convInfo.outWidth,convInfo.strideDepth,convInfo.strideHeight,convInfo.strideWidth,convInfo.dilationDepth,convInfo.dilationHeight,convInfo.dilationWidth,convInfo.effectiveFilterDepth,convInfo.effectiveFilterHeight,convInfo.effectiveFilterWidth,convInfo.padInfo.front,convInfo.padInfo.top,convInfo.padInfo.left),out}};let wasmAvgPool3DGrad;const avgPool3DGradConfig={kernelName:dist.wwC,backendName:"wasm",setupFunc:function AvgPool3DGrad_setup(backend){wasmAvgPool3DGrad=backend.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function avgPool3DGrad(args){const{inputs,backend,attrs}=args,{dy,input}=inputs,{filterSize,strides,pad,dimRoundingMode}=attrs,convInfo=dist.C0T.computePool3DInfo(input.shape,filterSize,strides,1,pad,dimRoundingMode),dx=backend.makeOutput(input.shape,input.dtype);return wasmAvgPool3DGrad(backend.dataIdMap.get(dy.dataId).id,backend.dataIdMap.get(dx.dataId).id,convInfo.batchSize,convInfo.inChannels,convInfo.inDepth,convInfo.inHeight,convInfo.inWidth,convInfo.outDepth,convInfo.outHeight,convInfo.outWidth,convInfo.strideDepth,convInfo.strideHeight,convInfo.strideWidth,convInfo.dilationDepth,convInfo.dilationHeight,convInfo.dilationWidth,convInfo.effectiveFilterDepth,convInfo.effectiveFilterHeight,convInfo.effectiveFilterWidth,convInfo.padInfo.front,convInfo.padInfo.top,convInfo.padInfo.left,convInfo.filterDepth,convInfo.filterHeight,convInfo.filterWidth),dx}};let wasmAvgPoolGrad;const avgPoolGradConfig={kernelName:dist.VCH,backendName:"wasm",setupFunc:function AvgPoolGrad_setup(backend){wasmAvgPoolGrad=backend.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function avgPoolGrad(args){const{inputs,backend,attrs}=args,{dy,input}=inputs,{filterSize,strides,pad}=attrs,convInfo=dist.C0T.computePool2DInfo(input.shape,filterSize,strides,1,pad),dx=backend.makeOutput(input.shape,input.dtype);return wasmAvgPoolGrad(backend.dataIdMap.get(dy.dataId).id,backend.dataIdMap.get(dx.dataId).id,convInfo.batchSize,convInfo.inChannels,convInfo.inHeight,convInfo.inWidth,convInfo.outHeight,convInfo.outWidth,convInfo.strideHeight,convInfo.strideWidth,convInfo.dilationHeight,convInfo.dilationWidth,convInfo.effectiveFilterHeight,convInfo.effectiveFilterWidth,convInfo.padInfo.top,convInfo.padInfo.left,convInfo.filterHeight,convInfo.filterWidth),dx}};function reshape(args){const{inputs,attrs}=args,{x}=inputs,{shape}=attrs,xSize=dist.ZSL.sizeFromShape(x.shape),$shape=dist.ZSL.inferFromImplicitShape(shape,xSize);return dist.ZSL.assert(xSize===dist.ZSL.sizeFromShape($shape),()=>`new shape: ${$shape}, old shape: ${x.shape}. New shape and old shape must have the same number of elements.`),args.backend.incRef(x.dataId),{dataId:x.dataId,shape:$shape,dtype:x.dtype}}const reshapeConfig={kernelName:dist.R23,backendName:"wasm",kernelFunc:reshape};let wasmBatchMatMul;const batchMatMulConfig={kernelName:dist.jAQ,backendName:"wasm",setupFunc:function BatchMatMul_setup(backend){wasmBatchMatMul=backend.wasm.cwrap(dist.jAQ,null,["number","array","number","number","array","number","number","number","number"])},kernelFunc:function batchMatMul(args){const{inputs,backend,attrs}=args,{a,b}=inputs,{transposeA,transposeB}=attrs;if("float32"!==a.dtype||"float32"!==b.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");const aRank=a.shape.length,bRank=b.shape.length,innerShapeA=transposeA?a.shape[aRank-2]:a.shape[aRank-1],innerShapeB=transposeB?b.shape[bRank-1]:b.shape[bRank-2],outerShapeA=transposeA?a.shape[aRank-1]:a.shape[aRank-2],outerShapeB=transposeB?b.shape[bRank-2]:b.shape[bRank-1],outerDimsA=a.shape.slice(0,-2),outerDimsB=b.shape.slice(0,-2),batchDimA=dist.ZSL.sizeFromShape(outerDimsA),batchDimB=dist.ZSL.sizeFromShape(outerDimsB),outShape=dist.ZEY.assertAndGetBroadcastShape(a.shape.slice(0,-2),b.shape.slice(0,-2)).concat([outerShapeA,outerShapeB]);dist.ZSL.assert(innerShapeA===innerShapeB,()=>`Error in matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${a.shape} and ${b.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);const b3dShape=transposeB?[batchDimB,outerShapeB,innerShapeB]:[batchDimB,innerShapeB,outerShapeB],a3d=reshape({inputs:{x:a},backend,attrs:{shape:transposeA?[batchDimA,innerShapeA,outerShapeA]:[batchDimA,outerShapeA,innerShapeA]}}),b3d=reshape({inputs:{x:b},backend,attrs:{shape:b3dShape}}),a3dId=backend.dataIdMap.get(a3d.dataId).id,b3dId=backend.dataIdMap.get(b3d.dataId).id,leftDim=transposeA?a3d.shape[2]:a3d.shape[1],rightDim=transposeB?b3d.shape[1]:b3d.shape[2],batchDim=Math.max(batchDimA,batchDimB),out=backend.makeOutput([batchDim,leftDim,rightDim],a3d.dtype),outId=backend.dataIdMap.get(out.dataId).id,aShapeBytes=new Uint8Array(new Int32Array(a3d.shape).buffer),bShapeBytes=new Uint8Array(new Int32Array(b3d.shape).buffer);return wasmBatchMatMul(a3dId,aShapeBytes,a3d.shape.length,b3dId,bShapeBytes,b3d.shape.length,transposeA,transposeB,outId),backend.disposeData(a3d.dataId),backend.disposeData(b3d.dataId),out.shape=outShape,out}};var Slice=__webpack_require__("./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Slice.js");function slice(args){const{inputs:{x},attrs:{begin,size},backend}=args,[begin_,size_]=dist.Kro.parseSliceParams(x,begin,size),isContinous=dist.Kro.isSliceContinous(x.shape,begin_,size_),xVals=backend.readSync(x.dataId),out=backend.makeOutput(size_,x.dtype),xStrides=dist.ZSL.computeStrides(x.shape),outData=backend.dataIdMap.get(out.dataId);if(isContinous){const flatOffset=dist.Kro.computeFlatOffset(begin_,xStrides);if("string"===x.dtype)outData.stringBytes=xVals.slice(flatOffset,flatOffset+dist.ZSL.sizeFromShape(size_));else{backend.typedArrayFromHeap(out).set(xVals.subarray(flatOffset,flatOffset+dist.ZSL.sizeFromShape(size_)))}return out}if("string"===x.dtype){const res=(0,Slice.HS)(xVals,begin_,size_,x.shape,x.dtype);return outData.stringBytes=res,out}const outVals=backend.typedArrayFromHeap(out),rank=x.shape.length;if(2===rank)!function slice2d(xVals,xStride,outVals,begin,size){let outOffset=0;const beginI=begin[0],beginJ=begin[1],endI=beginI+size[0];for(let i=beginI;i<endI;i++){const xOffset=i*xStride+beginJ;outVals.set(xVals.subarray(xOffset,xOffset+size[1]),outOffset),outOffset+=size[1]}}(xVals,xStrides[0],outVals,begin_,size_);else if(3===rank)!function slice3d(xVals,xStride1,xStride2,outVals,begin,size){let outOffset=0;const beginI=begin[0],beginJ=begin[1],beginK=begin[2],endI=beginI+size[0],endJ=beginJ+size[1];for(let i=beginI;i<endI;i++)for(let j=beginJ;j<endJ;j++){const xOffset=i*xStride1+j*xStride2+beginK;outVals.set(xVals.subarray(xOffset,xOffset+size[2]),outOffset),outOffset+=size[2]}}(xVals,xStrides[0],xStrides[1],outVals,begin_,size_);else if(4===rank)!function slice4d(xVals,xStride1,xStride2,xStride3,outVals,begin,size){let outOffset=0;const beginI=begin[0],beginJ=begin[1],beginK=begin[2],endI=beginI+size[0],endJ=beginJ+size[1],endK=beginK+size[2],beginL=begin[3];for(let i=beginI;i<endI;i++)for(let j=beginJ;j<endJ;j++)for(let k=beginK;k<endK;k++){const xOffset=i*xStride1+j*xStride2+k*xStride3+beginL;outVals.set(xVals.subarray(xOffset,xOffset+size[3]),outOffset),outOffset+=size[3]}}(xVals,xStrides[0],xStrides[1],xStrides[2],outVals,begin_,size_);else{const res=(0,Slice.HS)(xVals,begin_,size_,x.shape,x.dtype);outVals.set(res)}return out}const sliceConfig={kernelName:dist.JiE,backendName:"wasm",kernelFunc:slice};const batchToSpaceNDConfig={kernelName:dist.Ik2,backendName:"wasm",kernelFunc:function batchToSpaceND(args){const{inputs,backend,attrs}=args,{x}=inputs,{blockShape,crops}=attrs,prod=blockShape.reduce((a,b)=>a*b),reshaped=dist.C0T.getReshaped(x.shape,blockShape,prod),permuted=dist.C0T.getPermuted(reshaped.length,blockShape.length),reshapedPermuted=dist.C0T.getReshapedPermuted(x.shape,blockShape,prod),sliceBeginCoords=dist.C0T.getSliceBeginCoords(crops,blockShape.length),sliceSize=dist.C0T.getSliceSize(reshapedPermuted,crops,blockShape.length),xReshaped=reshape({inputs:{x},backend,attrs:{shape:reshaped}}),xTransposed=transpose({inputs:{x:xReshaped},backend,attrs:{perm:permuted}}),xTransposedReshaped=reshape({inputs:{x:xTransposed},backend,attrs:{shape:reshapedPermuted}}),result=slice({inputs:{x:xTransposedReshaped},backend,attrs:{begin:sliceBeginCoords,size:sliceSize}});return backend.disposeData(xReshaped.dataId),backend.disposeData(xTransposed.dataId),backend.disposeData(xTransposedReshaped.dataId),result}};let wasmBincount;const bincountConfig={kernelName:dist.N4F,backendName:"wasm",setupFunc:function Bincount_setup(backend){wasmBincount=backend.wasm.cwrap(dist.N4F,null,["number","number","boolean","number","number","number"])},kernelFunc:function bincount(args){const{backend,inputs,attrs}=args,{x,weights}=inputs,{size}=attrs,hasWeights=0!==weights.shape.reduce((p,v)=>p*v,1),outShape=1===x.shape.length?[size]:[x.shape[0],size],out=backend.makeOutput(outShape,weights.dtype);function tensorId(x){return backend.dataIdMap.get(x.dataId).id}return wasmBincount(tensorId(x),size,hasWeights,tensorId(weights),CppDType[weights.dtype],tensorId(out)),out}},bitwiseAndConfig=createBinaryKernelConfig(dist.HNs);const broadcastArgsConfig={kernelName:dist.vj7,backendName:"wasm",kernelFunc:function broadcastArgs(args){const{inputs,backend}=args,{s0,s1}=inputs,s0Vals=backend.typedArrayFromHeap(s0),s1Vals=backend.typedArrayFromHeap(s1),broadcastShape=dist.C0T.assertAndGetBroadcastShape(Array.from(s0Vals),Array.from(s1Vals));return backend.makeOutput([broadcastShape.length],"int32",void 0,new Int32Array(broadcastShape))}};function cast(args){const{inputs:{x},attrs:{dtype},backend}=args,out=backend.makeOutput(x.shape,dtype),inVals=backend.typedArrayFromHeap(x);return backend.typedArrayFromHeap(out).set(inVals),out}const castConfig={kernelName:dist.KXH,backendName:"wasm",kernelFunc:cast},ceilConfig=createUnaryKernelConfig(dist.QDP);let wasmClip;const clipByValueConfig={kernelName:dist.vaV,backendName:"wasm",setupFunc:function ClipByValue_setup(backend){wasmClip=backend.wasm.cwrap(dist.vaV,null,["number","number","number","number"])},kernelFunc:function clip(args){const{inputs,backend,attrs}=args,{x}=inputs,{clipValueMin,clipValueMax}=attrs,xId=backend.dataIdMap.get(x.dataId).id,out=backend.makeOutput(x.shape,x.dtype),outId=backend.dataIdMap.get(out.dataId).id;return wasmClip(xId,clipValueMin,clipValueMax,outId),out}};var Concat_impl=__webpack_require__("./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Concat_impl.js");function concat(args){const{inputs,backend}=args,axis=dist.ZSL.parseAxisParam(args.attrs.axis,inputs[0].shape)[0],shapes=inputs.map(t=>t.shape);dist.C0T.assertParamsConsistent(shapes,axis);let outShape=dist.C0T.computeOutShape(inputs.map(t=>t.shape),axis);const $inputs=inputs.filter(t=>dist.ZSL.sizeFromShape(t.shape)>0);if(1===$inputs.length)return identity({inputs:{x:$inputs[0]},backend});const out=backend.makeOutput(outShape,inputs[0].dtype);if(0===dist.ZSL.sizeFromShape(outShape))return out;if("string"===$inputs[0].dtype){const inputs2D=$inputs.map(t=>{const innerSize=dist.ZSL.sizeFromShape(t.shape.slice(axis));return reshape({inputs:{x:t},backend,attrs:{shape:[-1,innerSize]}})}),inputsValShapes=inputs2D.map(t=>({vals:backend.readSync(t.dataId),shape:t.shape}));outShape=dist.C0T.computeOutShape(inputs2D.map(t=>t.shape),1);const simplyConcat=1===inputs2D[0].shape[0],outVals=(0,Concat_impl.h)(inputsValShapes,outShape,inputs[0].dtype,simplyConcat),finalOutShape=dist.C0T.computeOutShape($inputs.map(t=>t.shape),axis);out.shape=finalOutShape;return backend.dataIdMap.get(out.dataId).stringBytes=dist.C0T.fromStringArrayToUint8(outVals),inputs2D.forEach(t=>backend.disposeData(t.dataId)),out}const batchDim=dist.ZSL.sizeFromShape($inputs[0].shape.slice(0,axis));let sumInnerDims=0;const innerDims=$inputs.map(input=>{const innerDim=dist.ZSL.sizeFromShape(input.shape.slice(axis));return sumInnerDims+=innerDim,innerDim}),inVals=$inputs.map(input=>backend.typedArrayFromHeap(input)),outVals=backend.typedArrayFromHeap(out);for(let b=0;b<batchDim;b++){let outOffset=b*sumInnerDims;for(let i=0;i<inVals.length;i++){const innerDim=innerDims[i],inOffset=b*innerDim,vals=inVals[i].subarray(inOffset,inOffset+innerDim);outVals.set(vals,outOffset),outOffset+=innerDim}}return out}const concatConfig={kernelName:dist.$dB,backendName:"wasm",kernelFunc:concat};let wasmConv2d;const conv2DConfig={kernelName:dist.p2J,backendName:"wasm",setupFunc:function Conv2D_setup(backend){wasmConv2d=backend.wasm.cwrap(dist.p2J,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function conv2d(args){const{inputs,attrs,backend}=args,{x,filter}=inputs,xId=backend.dataIdMap.get(x.dataId).id,filterId=backend.dataIdMap.get(filter.dataId).id,{strides,dilations,pad,dimRoundingMode,dataFormat}=attrs,$dataFormat=dist.C0T.convertConv2DDataFormat(dataFormat),convInfo=dist.C0T.computeConv2DInfo(x.shape,filter.shape,strides,dilations,pad,dimRoundingMode,!1,$dataFormat),filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,padTop=convInfo.padInfo.top,padRight=convInfo.padInfo.right,padBottom=convInfo.padInfo.bottom,padLeft=convInfo.padInfo.left,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,inputChannels=convInfo.inChannels,outputChannels=convInfo.outChannels,isSamePad="SAME"===convInfo.padInfo.type?1:0;if("channelsLast"!==convInfo.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${convInfo.dataFormat}'. Please use 'channelsLast'.`);const out=backend.makeOutput(convInfo.outShape,"float32"),outId=backend.dataIdMap.get(out.dataId).id;return wasmConv2d(xId,x.shape[0],x.shape[1],x.shape[2],filterId,filterHeight,filterWidth,padTop,padRight,padBottom,padLeft,isSamePad,dilationHeight,dilationWidth,strideHeight,strideWidth,inputChannels,outputChannels,outId),out}};let wasmConv2DBackpropInput;const conv2DBackpropInputConfig={kernelName:dist.jfg,backendName:"wasm",setupFunc:function Conv2DBackpropInput_setup(backend){wasmConv2DBackpropInput=backend.wasm.cwrap(dist.jfg,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function conv2DBackpropInput(args){const{backend,inputs,attrs}=args,{dy,filter}=inputs,{strides,pad,dataFormat,dimRoundingMode,inputShape}=attrs,$dataFormat=dist.C0T.convertConv2DDataFormat(dataFormat),convInfo=dist.C0T.computeConv2DInfo(inputShape,filter.shape,strides,1,pad,dimRoundingMode,!1,$dataFormat),{batchSize,filterHeight,filterWidth,inChannels,inHeight,inWidth,outChannels,outHeight,outWidth,strideHeight,strideWidth}=convInfo,topPad=filterHeight-1-convInfo.padInfo.top,leftPad=filterWidth-1-convInfo.padInfo.left,isChannelsLast="channelsLast"===convInfo.dataFormat,dxStrides=dist.ZSL.computeStrides(convInfo.inShape),dyStrides=dist.ZSL.computeStrides(dy.shape),[fltS0,fltS1,fltS2]=dist.ZSL.computeStrides(filter.shape),xBatchStride=dxStrides[0],xRowStride=isChannelsLast?dxStrides[1]:dxStrides[2],xColStride=isChannelsLast?dxStrides[2]:1,xChannelStride=isChannelsLast?1:dxStrides[1],yBatchStride=dyStrides[0],yRowStride=isChannelsLast?dyStrides[1]:dyStrides[2],yColStride=isChannelsLast?dyStrides[2]:1,yChannelStride=isChannelsLast?1:dyStrides[1],out=backend.makeOutput(convInfo.inShape,"float32"),outId=backend.dataIdMap.get(out.dataId).id,dyId=backend.dataIdMap.get(dy.dataId).id,filterId=backend.dataIdMap.get(filter.dataId).id;return wasmConv2DBackpropInput(dyId,filterId,batchSize,filterHeight,filterWidth,inHeight,inWidth,inChannels,outHeight,outWidth,outChannels,strideHeight,strideWidth,topPad,leftPad,fltS0,fltS1,fltS2,xBatchStride,xRowStride,xColStride,xChannelStride,yBatchStride,yRowStride,yColStride,yChannelStride,outId),out}};let wasmConv3D;const conv3DConfig={kernelName:dist.A1h,backendName:"wasm",setupFunc:function Conv3D_setup(backend){wasmConv3D=backend.wasm.cwrap(dist.A1h,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function conv3D(args){const{inputs,backend,attrs}=args,{x,filter}=inputs,{strides,pad,dilations}=attrs;if("float32"!==x.dtype)throw new Error(`Tensor x must have dtype float32, got ${x.dtype}`);if("float32"!==filter.dtype)throw new Error(`Tensor filter must have dtype float32, got ${filter.dtype}`);const convInfo=dist.C0T.computeConv3DInfo(x.shape,filter.shape,strides,dilations,pad),out=backend.makeOutput(convInfo.outShape,x.dtype);return wasmConv3D(backend.dataIdMap.get(x.dataId).id,backend.dataIdMap.get(filter.dataId).id,backend.dataIdMap.get(out.dataId).id,convInfo.batchSize,convInfo.inDepth,convInfo.inHeight,convInfo.inWidth,convInfo.inChannels,convInfo.outDepth,convInfo.outHeight,convInfo.outWidth,convInfo.outChannels,convInfo.strideDepth,convInfo.strideHeight,convInfo.strideWidth,convInfo.dilationDepth,convInfo.dilationHeight,convInfo.dilationWidth,convInfo.filterDepth,convInfo.filterHeight,convInfo.filterWidth,convInfo.padInfo.front,convInfo.padInfo.top,convInfo.padInfo.left),out}};let wasmConv3DBackpropFilterV2;const conv3DBackpropFilterV2Config={kernelName:dist.iGz,backendName:"wasm",setupFunc:function Conv3DBackpropFilterV2_setup(backend){wasmConv3DBackpropFilterV2=backend.wasm.cwrap(dist.iGz,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function conv3DBackpropFilterV2(args){const{inputs,backend,attrs}=args,{x,dy}=inputs,{strides,pad,filterShape}=attrs;if("float32"!==x.dtype)throw new Error(`Tensor dy must have dtype float32, got ${x.dtype}`);if("float32"!==dy.dtype)throw new Error(`Tensor filter must have dtype float32, got ${dy.dtype}`);const convInfo=dist.C0T.computeConv3DInfo(x.shape,filterShape,strides,1,pad),dw=backend.makeOutput(convInfo.filterShape,dy.dtype);return wasmConv3DBackpropFilterV2(backend.dataIdMap.get(x.dataId).id,backend.dataIdMap.get(dy.dataId).id,backend.dataIdMap.get(dw.dataId).id,convInfo.batchSize,convInfo.inDepth,convInfo.inHeight,convInfo.inWidth,convInfo.inChannels,convInfo.outDepth,convInfo.outHeight,convInfo.outWidth,convInfo.outChannels,convInfo.strideDepth,convInfo.strideHeight,convInfo.strideWidth,convInfo.dilationDepth,convInfo.dilationHeight,convInfo.dilationWidth,convInfo.filterDepth,convInfo.filterHeight,convInfo.filterWidth,convInfo.padInfo.front,convInfo.padInfo.top,convInfo.padInfo.left),dw}};let wasmConv3DBackpropInputV2;const conv3DBackpropInputV2Config={kernelName:dist.gC7,backendName:"wasm",setupFunc:function Conv3DBackpropInputV2_setup(backend){wasmConv3DBackpropInputV2=backend.wasm.cwrap(dist.gC7,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function conv3DBackpropInputV2(args){const{inputs,backend,attrs}=args,{dy,filter}=inputs,{pad,strides,inputShape}=attrs;if("float32"!==dy.dtype)throw new Error(`Tensor dy must have dtype float32, got ${dy.dtype}`);if("float32"!==filter.dtype)throw new Error(`Tensor filter must have dtype float32, got ${filter.dtype}`);const convInfo=dist.C0T.computeConv3DInfo(inputShape,filter.shape,strides,1,pad),dx=backend.makeOutput(convInfo.inShape,dy.dtype);return wasmConv3DBackpropInputV2(backend.dataIdMap.get(filter.dataId).id,backend.dataIdMap.get(dy.dataId).id,backend.dataIdMap.get(dx.dataId).id,convInfo.batchSize,convInfo.inDepth,convInfo.inHeight,convInfo.inWidth,convInfo.inChannels,convInfo.outDepth,convInfo.outHeight,convInfo.outWidth,convInfo.outChannels,convInfo.strideDepth,convInfo.strideHeight,convInfo.strideWidth,convInfo.dilationDepth,convInfo.dilationHeight,convInfo.dilationWidth,convInfo.filterDepth,convInfo.filterHeight,convInfo.filterWidth,convInfo.padInfo.front,convInfo.padInfo.top,convInfo.padInfo.left),dx}},cosConfig=createUnaryKernelConfig(dist.Mn0),coshConfig=createUnaryKernelConfig(dist.MnK);var InterpolationMethod;let wasmCropAndResize;!function(InterpolationMethod){InterpolationMethod[InterpolationMethod.bilinear=0]="bilinear",InterpolationMethod[InterpolationMethod.nearest=1]="nearest"}(InterpolationMethod||(InterpolationMethod={}));const cropAndResizeConfig={kernelName:dist.MRQ,backendName:"wasm",setupFunc:function CropAndResize_setup(backend){wasmCropAndResize=backend.wasm.cwrap(dist.MRQ,null,["number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function cropAndResize(args){const{backend,inputs,attrs}=args,{method,extrapolationValue,cropSize}=attrs,{image,boxes,boxInd}=inputs,numBoxes=boxes.shape[0],[cropHeight,cropWidth]=cropSize,outShape=[numBoxes,cropHeight,cropWidth,image.shape[3]];let castedData,imagesData=backend.dataIdMap.get(image.dataId);"float32"!==image.dtype&&(castedData=cast({backend,inputs:{x:image},attrs:{dtype:"float32"}}),imagesData=backend.dataIdMap.get(castedData.dataId));const imagesId=imagesData.id,boxesId=backend.dataIdMap.get(boxes.dataId).id,boxIndId=backend.dataIdMap.get(boxInd.dataId).id,out=backend.makeOutput(outShape,"float32"),outId=backend.dataIdMap.get(out.dataId).id,imagesShapeBytes=new Uint8Array(new Int32Array(image.shape).buffer);return wasmCropAndResize(imagesId,boxesId,boxIndId,numBoxes,imagesShapeBytes,cropHeight,cropWidth,InterpolationMethod[method],extrapolationValue,outId),null!=castedData&&backend.disposeData(castedData.dataId),out}};let wasmCumprod;const cumprodConfig={kernelName:dist.jj_,backendName:"wasm",setupFunc:function Cumprod_setup(backend){wasmCumprod=backend.wasm.cwrap(dist.jj_,null,["number","number","number","number","number","number"])},kernelFunc:function cumprod(args){const{inputs,backend,attrs}=args,{x}=inputs,{axis,exclusive,reverse}=attrs,xRank=x.shape.length;dist.ZSL.assert("float32"===x.dtype||"int32"===x.dtype,()=>`cumprod does not support ${x.dtype} tensors in the WASM backend`);const permutation=dist.C0T.getAxesPermutation([axis],xRank);let permutedX=x;null!==permutation&&(permutedX=transpose({inputs:{x},attrs:{perm:permutation},backend}));const permutedAxis=dist.C0T.getInnerMostAxes(1,xRank)[0];dist.C0T.assertAxesAreInnerMostDims("cumprod",[permutedAxis],xRank);const permutedOut=backend.makeOutput(permutedX.shape,permutedX.dtype),finalDim=permutedX.shape[permutedAxis],permutedXId=backend.dataIdMap.get(permutedX.dataId).id,permutedOutId=backend.dataIdMap.get(permutedOut.dataId).id;wasmCumprod(permutedXId,exclusive?1:0,reverse?1:0,finalDim,permutedOutId,CppDType[x.dtype]);let out=permutedOut;if(null!==permutation){out=transpose({inputs:{x:permutedOut},attrs:{perm:dist.C0T.getUndoAxesPermutation(permutation)},backend}),backend.disposeData(permutedX.dataId),backend.disposeData(permutedOut.dataId)}return out}};let wasmCumsum;const cumsumConfig={kernelName:dist.nY8,backendName:"wasm",setupFunc:function Cumsum_setup(backend){wasmCumsum=backend.wasm.cwrap(dist.nY8,null,["number","number","number","number","number","number"])},kernelFunc:function cumsum(args){const{inputs,backend,attrs}=args,{x}=inputs,{axis,exclusive,reverse}=attrs,xRank=x.shape.length;dist.ZSL.assert("float32"===x.dtype||"int32"===x.dtype,()=>`cumsum does not support ${x.dtype} tensors in the WASM backend`);const permutation=dist.C0T.getAxesPermutation([axis],xRank);let permutedX=x;null!==permutation&&(permutedX=transpose({inputs:{x},attrs:{perm:permutation},backend}));const permutedAxis=dist.C0T.getInnerMostAxes(1,xRank)[0];dist.C0T.assertAxesAreInnerMostDims("cumsum",[permutedAxis],xRank);const permutedOut=backend.makeOutput(permutedX.shape,permutedX.dtype),finalDim=permutedX.shape[permutedAxis],permutedXId=backend.dataIdMap.get(permutedX.dataId).id,permutedOutId=backend.dataIdMap.get(permutedOut.dataId).id;wasmCumsum(permutedXId,exclusive?1:0,reverse?1:0,finalDim,permutedOutId,CppDType[x.dtype]);let out=permutedOut;if(null!==permutation){out=transpose({inputs:{x:permutedOut},attrs:{perm:dist.C0T.getUndoAxesPermutation(permutation)},backend}),backend.disposeData(permutedX.dataId),backend.disposeData(permutedOut.dataId)}return out}};let wasmDenseBincount;const denseBincountConfig={kernelName:dist.wNW,backendName:"wasm",setupFunc:function DenseBincount_setup(backend){wasmDenseBincount=backend.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])},kernelFunc:function denseBincount(args){const{backend,inputs,attrs}=args,{x,weights}=inputs,{size,binaryOutput}=attrs,hasWeights=0!==weights.shape.reduce((p,v)=>p*v,1),outShape=1===x.shape.length?[size]:[x.shape[0],size],out=backend.makeOutput(outShape,weights.dtype);function tensorId(x){return backend.dataIdMap.get(x.dataId).id}return wasmDenseBincount(tensorId(x),new Uint8Array(new Int32Array(x.shape).buffer),x.shape.length,size,hasWeights,tensorId(weights),CppDType[weights.dtype],binaryOutput,tensorId(out)),out}};let wasmDepthToSpace;const depthToSpaceConfig={kernelName:dist.TMz,backendName:"wasm",setupFunc:function DepthToSpace_setup(backend){wasmDepthToSpace=backend.wasm.cwrap(dist.TMz,null,["number","number","number","array","number","array","array","number","number"])},kernelFunc:function depthToSpace(args){const{backend,inputs,attrs}=args,{x}=inputs,{blockSize,dataFormat}=attrs,batchSize=x.shape[0],outputHeight=("NHWC"===dataFormat?x.shape[1]:x.shape[2])*blockSize,outputWidth=("NHWC"===dataFormat?x.shape[2]:x.shape[3])*blockSize,outputDepth=("NHWC"===dataFormat?x.shape[3]:x.shape[1])/(blockSize*blockSize),outputShape="NHWC"===dataFormat?[batchSize,outputHeight,outputWidth,outputDepth]:[batchSize,outputDepth,outputHeight,outputWidth],out=backend.makeOutput(outputShape,"float32"),xId=backend.dataIdMap.get(x.dataId).id,xStridesBytes=new Uint8Array(new Int32Array(dist.ZSL.computeStrides(x.shape)).buffer),outputShapeBytes=new Uint8Array(new Int32Array(outputShape).buffer),outStridesBytes=new Uint8Array(new Int32Array(dist.ZSL.computeStrides(outputShape)).buffer),outId=backend.dataIdMap.get(out.dataId).id;return wasmDepthToSpace(xId,blockSize,"NHWC"===dataFormat?1:0,xStridesBytes,x.shape.length-1,outputShapeBytes,outStridesBytes,outputShape.length,outId),out}};let wasmDepthwiseConv2d;const depthwiseConv2dNativeConfig={kernelName:dist.tGH,backendName:"wasm",setupFunc:function DepthwiseConv2dNative_setup(backend){wasmDepthwiseConv2d=backend.wasm.cwrap(dist.tGH,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function depthwiseConv2d(args){const{inputs,attrs,backend}=args,{x,filter}=inputs,xId=backend.dataIdMap.get(x.dataId).id,filterId=backend.dataIdMap.get(filter.dataId).id,{strides,dilations,pad,dimRoundingMode}=attrs,$dilations=null==dilations?[1,1]:dilations,convInfo=dist.C0T.computeConv2DInfo(x.shape,filter.shape,strides,$dilations,pad,dimRoundingMode,!0),filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,padTop=convInfo.padInfo.top,padRight=convInfo.padInfo.right,padBottom=convInfo.padInfo.bottom,padLeft=convInfo.padInfo.left,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,inputChannels=convInfo.inChannels,outputChannels=convInfo.outChannels,isSamePad="SAME"===convInfo.padInfo.type?1:0;if("channelsLast"!==convInfo.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${convInfo.dataFormat}'. Please use 'channelsLast'.`);const out=backend.makeOutput(convInfo.outShape,"float32"),outId=backend.dataIdMap.get(out.dataId).id;return wasmDepthwiseConv2d(xId,x.shape[0],x.shape[1],x.shape[2],filterId,filterHeight,filterWidth,padTop,padRight,padBottom,padLeft,isSamePad,dilationHeight,dilationWidth,strideHeight,strideWidth,inputChannels,outputChannels,outId),out}};let wasmDiag;const diagConfig={kernelName:dist.ORI,backendName:"wasm",setupFunc:function Diag_setup(backend){wasmDiag=backend.wasm.cwrap("Diag",null,["number","number","number","number"])},kernelFunc:function diag(args){const{inputs,backend}=args,{x}=inputs,xSize=dist.ZSL.sizeFromShape(x.shape),out=backend.makeOutput([...x.shape,...x.shape],x.dtype);return wasmDiag(backend.dataIdMap.get(x.dataId).id,CppDType[x.dtype],xSize,backend.dataIdMap.get(out.dataId).id),out}};let wasmDilation2D;const dilation2DConfig={kernelName:dist.jxD,backendName:"wasm",setupFunc:function Dilation2D_setup(backend){wasmDilation2D=backend.wasm.cwrap(dist.jxD,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function dilation2D(args){const{inputs,backend,attrs}=args,{x,filter}=inputs,{strides,pad,dilations}=attrs;if(x.dtype!==filter.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${x.dtype} and ${filter.dtype}`);const dilationInfo=dist.C0T.computeDilation2DInfo(x.shape,filter.shape,strides,pad,"NHWC",dilations),out=backend.makeOutput(dilationInfo.outShape,x.dtype);return wasmDilation2D(backend.dataIdMap.get(x.dataId).id,backend.dataIdMap.get(filter.dataId).id,backend.dataIdMap.get(out.dataId).id,CppDType[x.dtype],dilationInfo.batchSize,dilationInfo.inChannels,dilationInfo.inHeight,dilationInfo.inWidth,dilationInfo.outHeight,dilationInfo.outWidth,dilationInfo.strideHeight,dilationInfo.strideWidth,dilationInfo.dilationHeight,dilationInfo.dilationWidth,dilationInfo.filterHeight,dilationInfo.filterWidth,dilationInfo.padInfo.top,dilationInfo.padInfo.left),out}};let wasmDilation2DBackpropFilter;const dilation2DBackpropFilterConfig={kernelName:dist.pk0,backendName:"wasm",setupFunc:function Dilation2DBackpropFilter_setup(backend){wasmDilation2DBackpropFilter=backend.wasm.cwrap(dist.pk0,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function dilation2DBackpropFilter(args){const{inputs,backend,attrs}=args,{x,filter,dy}=inputs,{strides,pad,dilations}=attrs;if(x.dtype!==filter.dtype||x.dtype!==dy.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${x.dtype}, ${filter.dtype}, and ${dy.dtype}`);const dilationInfo=dist.C0T.computeDilation2DInfo(x.shape,filter.shape,strides,pad,"NHWC",dilations),gradients=backend.makeOutput(filter.shape,filter.dtype);return wasmDilation2DBackpropFilter(backend.dataIdMap.get(x.dataId).id,backend.dataIdMap.get(filter.dataId).id,backend.dataIdMap.get(dy.dataId).id,backend.dataIdMap.get(gradients.dataId).id,CppDType[x.dtype],dilationInfo.batchSize,dilationInfo.inChannels,dilationInfo.inHeight,dilationInfo.inWidth,dilationInfo.outHeight,dilationInfo.outWidth,dilationInfo.strideHeight,dilationInfo.strideWidth,dilationInfo.dilationHeight,dilationInfo.dilationWidth,dilationInfo.filterHeight,dilationInfo.filterWidth,dilationInfo.padInfo.top,dilationInfo.padInfo.left),gradients}};let wasmDilation2DBackpropInput;const dilation2DBackpropInputConfig={kernelName:dist.bP9,backendName:"wasm",setupFunc:function Dilation2DBackpropInput_setup(backend){wasmDilation2DBackpropInput=backend.wasm.cwrap(dist.bP9,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function dilation2DBackpropInput(args){const{inputs,backend,attrs}=args,{x,filter,dy}=inputs,{strides,pad,dilations}=attrs;if(x.dtype!==filter.dtype||x.dtype!==dy.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${x.dtype}, ${filter.dtype}, and ${dy.dtype}`);const dilationInfo=dist.C0T.computeDilation2DInfo(x.shape,filter.shape,strides,pad,"NHWC",dilations),gradients=backend.makeOutput(x.shape,x.dtype);return wasmDilation2DBackpropInput(backend.dataIdMap.get(x.dataId).id,backend.dataIdMap.get(filter.dataId).id,backend.dataIdMap.get(dy.dataId).id,backend.dataIdMap.get(gradients.dataId).id,CppDType[x.dtype],dilationInfo.batchSize,dilationInfo.inChannels,dilationInfo.inHeight,dilationInfo.inWidth,dilationInfo.outHeight,dilationInfo.outWidth,dilationInfo.strideHeight,dilationInfo.strideWidth,dilationInfo.dilationHeight,dilationInfo.dilationWidth,dilationInfo.filterHeight,dilationInfo.filterWidth,dilationInfo.padInfo.top,dilationInfo.padInfo.left),gradients}},eluConfig=createUnaryKernelConfig(dist.Pah);let wasmEluGrad;const eluGradConfig={kernelName:dist.rsH,backendName:"wasm",setupFunc:function EluGrad_setup(backend){wasmEluGrad=backend.wasm.cwrap(dist.rsH,null,["number","number","number"])},kernelFunc:function eluGrad(args){const{inputs,backend}=args,{dy,y}=inputs,out=backend.makeOutput(y.shape,"float32"),tensorId=x=>backend.dataIdMap.get(x.dataId).id;return wasmEluGrad(tensorId(y),tensorId(dy),tensorId(out)),out}},equalConfig=createBinaryKernelConfig(dist.BRl,0,"bool"),erfConfig=createUnaryKernelConfig(dist._s9),expConfig=createUnaryKernelConfig(dist.ox3,"float32");function expandDims(args){const{inputs,attrs,backend}=args,{input}=inputs,{dim}=attrs,inputRank=input.shape.length,newShape=input.shape.slice();let $dim=dim;return dim<0&&(dist.ZSL.assert(-(inputRank+1)<=dim,()=>`Axis must be in the interval [${-(inputRank+1)}, ${inputRank}]`),$dim=inputRank+dim+1),newShape.splice($dim,0,1),reshape({inputs:{x:input},backend,attrs:{shape:newShape}})}const expandDimsConfig={kernelName:dist.ybN,backendName:"wasm",kernelFunc:expandDims},expm1Config=createUnaryKernelConfig(dist.ybj,"float32");function fill(args){const{attrs:{shape,value},backend}=args;let{attrs:{dtype}}=args;dtype=dtype||dist.ZSL.inferDtype(value);const out=backend.makeOutput(shape,dtype);return backend.typedArrayFromHeap(out).fill(value),out}const fillConfig={kernelName:dist.SQl,backendName:"wasm",kernelFunc:fill};let wasmFlipLeftRight;const flipLeftRightConfig={kernelName:dist.BxF,backendName:"wasm",kernelFunc:function flipLeftRight(args){const{inputs,backend}=args,{image}=inputs,out=backend.makeOutput(image.shape,image.dtype),imageId=backend.dataIdMap.get(image.dataId).id,outId=backend.dataIdMap.get(out.dataId).id,[batch,imageHeight,imageWidth,numChannels]=image.shape;return wasmFlipLeftRight(imageId,batch,imageHeight,imageWidth,numChannels,outId),out},setupFunc:function FlipLeftRight_setup(backend){wasmFlipLeftRight=backend.wasm.cwrap(dist.BxF,null,["number","number","number","number","number","number"])}},floorConfig=createUnaryKernelConfig(dist.ZgB),floorDivConfig=createBinaryKernelConfig(dist.ElG);let wasmBatchNorm;const fusedBatchNormConfig={kernelName:dist.i5R,backendName:"wasm",setupFunc:function FusedBatchNorm_setup(backend){wasmBatchNorm=backend.wasm.cwrap(dist.i5R,null,["number","number","number","number","number","number","number"])},kernelFunc:function fusedBatchNorm(args){const{backend,inputs,attrs}=args,{varianceEpsilon}=attrs,{x,mean,variance,offset,scale}=inputs,xId=backend.dataIdMap.get(x.dataId).id,meanId=backend.dataIdMap.get(mean.dataId).id,varianceId=backend.dataIdMap.get(variance.dataId).id,offsetId=null!=offset?backend.dataIdMap.get(offset.dataId).id:0,scaleId=null!=scale?backend.dataIdMap.get(scale.dataId).id:0,out=backend.makeOutput(x.shape,x.dtype);if(0===dist.ZSL.sizeFromShape(x.shape))return out;const outId=backend.dataIdMap.get(out.dataId).id;return wasmBatchNorm(xId,meanId,varianceId,offsetId,scaleId,varianceEpsilon,outId),out}};let wasmFusedConv2d;const fusedConv2DConfig={kernelName:dist.aAr,backendName:"wasm",setupFunc:function FusedConv2D_setup(backend){wasmFusedConv2d=backend.wasm.cwrap(dist.aAr,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function fusedConv2d(args){const{inputs,attrs,backend}=args,{x,filter,bias,preluActivationWeights}=inputs,{strides,pad,dilations,dataFormat,dimRoundingMode,activation,leakyreluAlpha}=attrs,convInfo=dist.C0T.computeConv2DInfo(x.shape,filter.shape,strides,dilations,pad,dimRoundingMode),fusedActivation=FusableActivation[activation];if(null==fusedActivation)throw new Error(`${activation} activation not yet supported for FusedConv2D in the wasm backend.`);const xId=backend.dataIdMap.get(x.dataId).id,filterId=backend.dataIdMap.get(filter.dataId).id,outputChannels=convInfo.outChannels;let biasId=0;if(null!=bias){const biasData=backend.dataIdMap.get(bias.dataId);if(1!==biasData.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${biasData.shape.length}.`);if(biasData.shape[0]!==outputChannels)throw new Error(`FusedConv2D bias shape (${biasData.shape}) does not match the number of output channels (${outputChannels})`);biasId=biasData.id}const filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,padTop=convInfo.padInfo.top,padRight=convInfo.padInfo.right,padBottom=convInfo.padInfo.bottom,padLeft=convInfo.padInfo.left,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,inputChannels=convInfo.inChannels,isSamePad="SAME"===convInfo.padInfo.type?1:0,batchSize=convInfo.batchSize,inHeight=convInfo.inHeight,inWidth=convInfo.inWidth;if("NHWC"!==dataFormat)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${dataFormat}'. Please use 'NHWC'.`);const out=backend.makeOutput(convInfo.outShape,"float32"),outId=backend.dataIdMap.get(out.dataId).id,preluActivationWeightsId=null==preluActivationWeights?0:backend.dataIdMap.get(preluActivationWeights.dataId).id;return wasmFusedConv2d(xId,batchSize,inHeight,inWidth,filterId,filterHeight,filterWidth,biasId,padTop,padRight,padBottom,padLeft,isSamePad,dilationHeight,dilationWidth,strideHeight,strideWidth,inputChannels,outputChannels,fusedActivation,preluActivationWeightsId,leakyreluAlpha||0,outId),out}};let wasmFusedDepthwiseConv2d;const fusedDepthwiseConv2DConfig={kernelName:dist.T7M,backendName:"wasm",setupFunc:function FusedDepthwiseConv2D_setup(backend){wasmFusedDepthwiseConv2d=backend.wasm.cwrap(dist.T7M,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function fusedDepthwiseConv2d(args){const{inputs,attrs,backend}=args,{x,filter,bias,preluActivationWeights}=inputs,{strides,pad,dilations,dataFormat,dimRoundingMode,activation,leakyreluAlpha}=attrs,convInfo=dist.C0T.computeConv2DInfo(x.shape,filter.shape,strides,dilations,pad,dimRoundingMode,!0),fusedActivation=FusableActivation[activation];if(null==fusedActivation)throw new Error(`${activation} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);const xId=backend.dataIdMap.get(x.dataId).id,filterId=backend.dataIdMap.get(filter.dataId).id,outputChannels=convInfo.outChannels;let biasId=0;if(null!=bias){const biasData=backend.dataIdMap.get(bias.dataId);if(1!==biasData.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${biasData.shape.length}.`);if(biasData.shape[0]!==outputChannels)throw new Error(`FusedDepthwiseConv2D bias shape (${biasData.shape}) does not match the number of output channels (${outputChannels})`);biasId=biasData.id}const filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,padTop=convInfo.padInfo.top,padRight=convInfo.padInfo.right,padBottom=convInfo.padInfo.bottom,padLeft=convInfo.padInfo.left,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,inputChannels=convInfo.inChannels,isSamePad="SAME"===convInfo.padInfo.type?1:0,batchSize=convInfo.batchSize,inHeight=convInfo.inHeight,inWidth=convInfo.inWidth;if("NHWC"!==dataFormat)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${dataFormat}'. Please use 'NHWC'.`);const out=backend.makeOutput(convInfo.outShape,"float32"),outId=backend.dataIdMap.get(out.dataId).id,preluActivationWeightsId=null==preluActivationWeights?0:backend.dataIdMap.get(preluActivationWeights.dataId).id;return wasmFusedDepthwiseConv2d(xId,batchSize,inHeight,inWidth,filterId,filterHeight,filterWidth,biasId,padTop,padRight,padBottom,padLeft,isSamePad,dilationHeight,dilationWidth,strideHeight,strideWidth,inputChannels,outputChannels,fusedActivation,preluActivationWeightsId,leakyreluAlpha||0,outId),out}};let wasmGatherNd;const gatherNdConfig={kernelName:dist.O4G,backendName:"wasm",setupFunc:function GatherNd_setup(backend){wasmGatherNd=backend.wasm.cwrap(dist.O4G,null,["number","number","number","number","number","number","array","number"])},kernelFunc:function gatherNd(args){const{backend,inputs}=args,{params,indices}=inputs,[resultShape,numSlices,sliceSize,strides]=dist.FJy.prepareAndValidate(params,indices),out=backend.makeOutput(resultShape,params.dtype);if(0===numSlices)return out;const indicesShape=indices.shape,sliceRank=indicesShape[indicesShape.length-1],xId=backend.dataIdMap.get(params.dataId).id,indicesId=backend.dataIdMap.get(indices.dataId).id,stridesBytes=new Uint8Array(new Int32Array(strides).buffer),outId=backend.dataIdMap.get(out.dataId).id;return wasmGatherNd(xId,CppDType[params.dtype],indicesId,numSlices,sliceRank,sliceSize,stridesBytes,outId),out}};let wasmGather;const gatherV2Config={kernelName:dist.mxL,backendName:"wasm",setupFunc:function GatherV2_setup(backend){wasmGather=backend.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])},kernelFunc:function gatherV2(args){const{backend,inputs,attrs}=args,{x,indices}=inputs,{axis,batchDims}=attrs,parsedAxis=dist.ZSL.parseAxisParam(axis,x.shape)[0],indicesVals=backend.readSync(indices.dataId),axisDim=x.shape[parsedAxis];for(let i=0;i<indicesVals.length;++i){const index=indicesVals[i];dist.ZSL.assert(index<=axisDim-1&&index>=0,()=>`GatherV2: the index value ${index} is not in [0, ${axisDim-1}]`)}const shapeInfo=dist.C0T.segment_util.collectGatherOpShapeInfo(x,indices,parsedAxis,batchDims),flattenX=reshape({inputs:{x},attrs:{shape:[shapeInfo.batchSize,shapeInfo.outerSize,shapeInfo.dimSize,shapeInfo.sliceSize]},backend}),indicesSize=dist.ZSL.sizeFromShape(indices.shape),flattenIndex=reshape({inputs:{x:indices},attrs:{shape:[shapeInfo.batchSize,indicesSize/shapeInfo.batchSize]},backend}),flattenOutputShape=[shapeInfo.batchSize,shapeInfo.outerSize,indicesSize/shapeInfo.batchSize,shapeInfo.sliceSize],out=backend.makeOutput(flattenOutputShape,x.dtype);if(0===dist.ZSL.sizeFromShape(x.shape))return out;const stridesSize=flattenX.shape.length-1,xId=backend.dataIdMap.get(flattenX.dataId).id,indicesId=backend.dataIdMap.get(flattenIndex.dataId).id,outId=backend.dataIdMap.get(out.dataId).id,xStridesBytes=new Uint8Array(new Int32Array(dist.ZSL.computeStrides(flattenX.shape)).buffer),outStridesBytes=new Uint8Array(new Int32Array(dist.ZSL.computeStrides(flattenOutputShape)).buffer);return wasmGather(xId,CppDType[x.dtype],xStridesBytes,stridesSize,indicesId,shapeInfo.batchSize,outStridesBytes,outId),backend.disposeData(flattenX.dataId),backend.disposeData(flattenIndex.dataId),out.shape=shapeInfo.outputShape,out}},greaterConfig=createBinaryKernelConfig(dist.XhZ,0,"bool"),greaterEqualConfig=createBinaryKernelConfig(dist.lLS,0,"bool"),isFiniteConfig=createUnaryKernelConfig(dist.gIW,"bool"),isInfConfig=createUnaryKernelConfig(dist.E3$,"bool"),isNaNConfig=createUnaryKernelConfig(dist.iPs,"bool");let LeakyRelu_wasmFunc;const leakyReluConfig={kernelName:dist.X0$,backendName:"wasm",setupFunc:function LeakyRelu_setupFunc(backend){LeakyRelu_wasmFunc=backend.wasm.cwrap(dist.X0$,null,["number","number","number","number"])},kernelFunc:function leakyRelu(args){const{inputs:{x},attrs:{alpha},backend}=args,xId=backend.dataIdMap.get(x.dataId).id,out=backend.makeOutput(x.shape,"float32");if(0!==dist.ZSL.sizeFromShape(x.shape)){const outId=backend.dataIdMap.get(out.dataId).id;LeakyRelu_wasmFunc(xId,CppDType[x.dtype],alpha,outId)}return out}},lessConfig=createBinaryKernelConfig(dist.mIA,0,"bool"),lessEqualConfig=createBinaryKernelConfig(dist.CwD,0,"bool");let wasmLinSpace;const linSpaceConfig={kernelName:dist.mnI,backendName:"wasm",setupFunc:function LinSpace_setup(backend){wasmLinSpace=backend.wasm.cwrap(dist.mnI,null,["number","number","number","number"])},kernelFunc:function linSpace(args){const{attrs,backend}=args,{start,stop,num}=attrs,numInt=Math.floor(num),out=backend.makeOutput([numInt],"float32");return wasmLinSpace(backend.dataIdMap.get(out.dataId).id,start,stop,numInt),out}},logConfig=createUnaryKernelConfig(dist.tG8),log1pConfig=createUnaryKernelConfig(dist.Cg$),logicalAndConfig=createBinaryKernelConfig(dist.RUm,0,"bool"),logicalNotConfig=createUnaryKernelConfig(dist.nZd),logicalOrConfig=createBinaryKernelConfig(dist.LXA,0,"bool"),logicalXorConfig=createBinaryKernelConfig(dist.RW8,0,"bool");let wasmLRN;const lrnConfig={kernelName:dist.jM4,backendName:"wasm",setupFunc:function LRN_setup(backend){wasmLRN=backend.wasm.cwrap(dist.jM4,null,["number","number","number","number","number","number","number"])},kernelFunc:function lrn(args){const{inputs,backend,attrs}=args,{x}=inputs,{depthRadius,bias,alpha,beta}=attrs;if("float32"!==x.dtype)throw new Error("LRN error: x must have dtype float32");const out=backend.makeOutput(x.shape,x.dtype);return wasmLRN(backend.dataIdMap.get(x.dataId).id,backend.dataIdMap.get(out.dataId).id,x.shape[3],depthRadius,bias,alpha,beta),out}};let wasmLRNGrad;const lrnGradConfig={kernelName:dist.ToN,backendName:"wasm",setupFunc:function LRNGrad_setup(backend){wasmLRNGrad=backend.wasm.cwrap(dist.ToN,null,["number","number","number","number","number","number","number","number","number"])},kernelFunc:function lrnGrad(args){const{inputs,backend,attrs}=args,{x,y,dy}=inputs,{depthRadius,bias,alpha,beta}=attrs;if("float32"!==x.dtype||"float32"!==y.dtype||"float32"!==dy.dtype)throw new Error("LRNGrad error: x, y, and dy must have dtype float32");const dx=backend.makeOutput(x.shape,x.dtype);return wasmLRNGrad(backend.dataIdMap.get(x.dataId).id,backend.dataIdMap.get(y.dataId).id,backend.dataIdMap.get(dy.dataId).id,backend.dataIdMap.get(dx.dataId).id,dy.shape[3],depthRadius,bias,alpha,beta),dx}};let wasmMax;const maxConfig={kernelName:dist.VAI,backendName:"wasm",setupFunc:function Max_setup(backend){wasmMax=backend.wasm.cwrap(dist.VAI,null,["number","number","number","number"])},kernelFunc:function max(args){const{backend,inputs,attrs}=args,{reductionIndices:axis,keepDims}=attrs,{x}=inputs;let inputId=backend.dataIdMap.get(x.dataId).id,input=x;const{transposed,axes,originalAxes,inputWasTransposed}=permuteAxesAndTranspose(x,axis,backend);if(inputWasTransposed){input=transposed,inputId=backend.dataIdMap.get(transposed.dataId).id}const inputRank=input.shape.length;dist.C0T.assertAxesAreInnerMostDims("max",axes,inputRank);const[outShape,reduceShape]=dist.C0T.computeOutAndReduceShapes(input.shape,axes),reduceSize=dist.ZSL.sizeFromShape(reduceShape),out=backend.makeOutput(outShape,x.dtype);if(0!==dist.ZSL.sizeFromShape(input.shape)){const outId=backend.dataIdMap.get(out.dataId).id;wasmMax(inputId,CppDType[x.dtype],reduceSize,outId)}if(inputWasTransposed&&backend.disposeData(transposed.dataId),keepDims){const newShape=dist.C0T.expandShapeToKeepDim(out.shape,originalAxes);out.shape=newShape}return out}},maximumConfig=createBinaryKernelConfig(dist.LDN);let wasmMaxPool;const maxPoolConfig={kernelName:dist.t3d,backendName:"wasm",setupFunc:function MaxPool_setup(backend){wasmMaxPool=backend.wasm.cwrap(dist.t3d,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function maxPool(args){const{inputs,attrs,backend}=args,x=inputs.x,xId=backend.dataIdMap.get(x.dataId).id;dist.ZSL.assert("float32"===x.dtype,()=>`Error in MaxPool: only float32 input is supported. Got ${x.dtype}.`);const{filterSize,strides,pad,dimRoundingMode}=attrs,convInfo=dist.C0T.computePool2DInfo(x.shape,filterSize,strides,1,pad,dimRoundingMode),filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,padTop=convInfo.padInfo.top,padRight=convInfo.padInfo.right,padBottom=convInfo.padInfo.bottom,padLeft=convInfo.padInfo.left,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,inputChannels=convInfo.inChannels,outputChannels=convInfo.outChannels;if("channelsLast"!==convInfo.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${convInfo.dataFormat}'. Please use 'channelsLast'.`);const out=backend.makeOutput(convInfo.outShape,"float32"),outId=backend.dataIdMap.get(out.dataId).id;return wasmMaxPool(xId,x.shape[0],x.shape[1],x.shape[2],filterHeight,filterWidth,padTop,padRight,padBottom,padLeft,dilationHeight,dilationWidth,strideHeight,strideWidth,inputChannels,outputChannels,outId),out}};let wasmMaxPool3D;const maxPool3DConfig={kernelName:dist.ySp,backendName:"wasm",setupFunc:function MaxPool3D_setup(backend){wasmMaxPool3D=backend.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function maxPool3D(args){const{inputs,backend,attrs}=args,{x}=inputs,{filterSize,strides,pad,dimRoundingMode,dataFormat}=attrs,convInfo=dist.C0T.computePool3DInfo(x.shape,filterSize,strides,1,pad,dimRoundingMode,dataFormat),out=backend.makeOutput(convInfo.outShape,x.dtype);return wasmMaxPool3D(backend.dataIdMap.get(x.dataId).id,backend.dataIdMap.get(out.dataId).id,convInfo.batchSize,convInfo.inChannels,convInfo.inDepth,convInfo.inHeight,convInfo.inWidth,convInfo.outDepth,convInfo.outHeight,convInfo.outWidth,convInfo.strideDepth,convInfo.strideHeight,convInfo.strideWidth,convInfo.dilationDepth,convInfo.dilationHeight,convInfo.dilationWidth,convInfo.effectiveFilterDepth,convInfo.effectiveFilterHeight,convInfo.effectiveFilterWidth,convInfo.padInfo.front,convInfo.padInfo.top,convInfo.padInfo.left),out}};let wasmMaxPool3DGrad;const maxPool3DGradConfig={kernelName:dist.cHb,backendName:"wasm",setupFunc:function MaxPool3DGrad_setup(backend){wasmMaxPool3DGrad=backend.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function maxPool3DGrad(args){const{inputs,backend,attrs}=args,{dy,input}=inputs,{filterSize,strides,pad,dimRoundingMode}=attrs,convInfo=dist.C0T.computePool3DInfo(input.shape,filterSize,strides,1,pad,dimRoundingMode),dx=backend.makeOutput(input.shape,input.dtype);return wasmMaxPool3DGrad(backend.dataIdMap.get(input.dataId).id,backend.dataIdMap.get(dy.dataId).id,backend.dataIdMap.get(dx.dataId).id,convInfo.batchSize,convInfo.inChannels,convInfo.inDepth,convInfo.inHeight,convInfo.inWidth,convInfo.outDepth,convInfo.outHeight,convInfo.outWidth,convInfo.strideDepth,convInfo.strideHeight,convInfo.strideWidth,convInfo.dilationDepth,convInfo.dilationHeight,convInfo.dilationWidth,convInfo.effectiveFilterDepth,convInfo.effectiveFilterHeight,convInfo.effectiveFilterWidth,convInfo.padInfo.front,convInfo.padInfo.top,convInfo.padInfo.left),dx}};let wasmMaxPoolGrad;const maxPoolGradConfig={kernelName:dist.RXX,backendName:"wasm",setupFunc:function MaxPoolGrad_setup(backend){wasmMaxPoolGrad=backend.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function maxPoolGrad(args){const{inputs,backend,attrs}=args,{dy,input}=inputs,{filterSize,strides,pad,dimRoundingMode}=attrs,convInfo=dist.C0T.computePool2DInfo(input.shape,filterSize,strides,1,pad,dimRoundingMode),dx=backend.makeOutput(input.shape,input.dtype);return wasmMaxPoolGrad(backend.dataIdMap.get(input.dataId).id,backend.dataIdMap.get(dy.dataId).id,backend.dataIdMap.get(dx.dataId).id,convInfo.batchSize,convInfo.inChannels,convInfo.inHeight,convInfo.inWidth,convInfo.outHeight,convInfo.outWidth,convInfo.strideHeight,convInfo.strideWidth,convInfo.dilationHeight,convInfo.dilationWidth,convInfo.effectiveFilterHeight,convInfo.effectiveFilterWidth,convInfo.padInfo.top,convInfo.padInfo.left),dx}};let wasmMaxPoolWithArgmax;const maxPoolWithArgmaxConfig={kernelName:dist.TL8,backendName:"wasm",setupFunc:function MaxPoolWithArgmax_setup(backend){wasmMaxPoolWithArgmax=backend.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function maxPoolWithArgmax(args){const{inputs,backend,attrs}=args,{x}=inputs,{filterSize,strides,pad,includeBatchInIndex}=attrs;dist.ZSL.assert(4===x.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${x.shape.length}.`);const dilations=[1,1];dist.ZSL.assert(dist.C0T.eitherStridesOrDilationsAreOne(strides,dilations),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);const convInfo=dist.C0T.computePool2DInfo(x.shape,filterSize,strides,[1,1],pad),pooled=backend.makeOutput(convInfo.outShape,x.dtype),indexes=backend.makeOutput(convInfo.outShape,"int32");return wasmMaxPoolWithArgmax(backend.dataIdMap.get(x.dataId).id,backend.dataIdMap.get(pooled.dataId).id,backend.dataIdMap.get(indexes.dataId).id,CppDType[x.dtype],includeBatchInIndex,convInfo.batchSize,convInfo.inChannels,convInfo.inHeight,convInfo.inWidth,convInfo.outHeight,convInfo.outWidth,convInfo.strideHeight,convInfo.strideWidth,convInfo.dilationHeight,convInfo.dilationWidth,convInfo.effectiveFilterHeight,convInfo.effectiveFilterWidth,convInfo.padInfo.top,convInfo.padInfo.left),[pooled,indexes]}};let wasmMean;const meanConfig={kernelName:dist.g5A,backendName:"wasm",setupFunc:function Mean_setup(backend){wasmMean=backend.wasm.cwrap(dist.g5A,null,["number, number, number"])},kernelFunc:function mean(args){const{backend,inputs,attrs}=args,{axis,keepDims}=attrs,{x}=inputs,xId=backend.dataIdMap.get(x.dataId).id;let inputId=xId,input=x;const{transposed,axes,originalAxes,inputWasTransposed}=permuteAxesAndTranspose(x,axis,backend);let reductionAxes=axes;if(inputWasTransposed){const transposedId=backend.dataIdMap.get(transposed.dataId).id;transposedId!==xId&&(input=transposed,inputId=transposedId,reductionAxes=dist.C0T.getInnerMostAxes(reductionAxes.length,input.shape.length))}dist.C0T.assertAxesAreInnerMostDims("mean",reductionAxes,input.shape.length);const[outShape,reduceShape]=dist.C0T.computeOutAndReduceShapes(input.shape,reductionAxes),reduceSize=dist.ZSL.sizeFromShape(reduceShape);let castedInput=input;"float32"!==input.dtype&&(castedInput=cast({backend,inputs:{x:input},attrs:{dtype:"float32"}}),inputId=backend.dataIdMap.get(castedInput.dataId).id);const out=backend.makeOutput(outShape,"float32");if(0!==dist.ZSL.sizeFromShape(input.shape)){const outId=backend.dataIdMap.get(out.dataId).id;wasmMean(inputId,reduceSize,outId)}if(inputWasTransposed&&backend.disposeData(transposed.dataId),keepDims){const newShape=dist.C0T.expandShapeToKeepDim(out.shape,originalAxes);out.shape=newShape}return"float32"!==input.dtype&&backend.disposeData(castedInput.dataId),out}};let wasmMin;const minConfig={kernelName:dist.lNG,backendName:"wasm",setupFunc:function Min_setup(backend){wasmMin=backend.wasm.cwrap(dist.lNG,null,["number","number","number","number"])},kernelFunc:function min(args){const{backend,inputs,attrs}=args,{axis,keepDims}=attrs,{x}=inputs,xId=backend.dataIdMap.get(x.dataId).id;let inputId=xId,input=x;const{transposed,axes,originalAxes,inputWasTransposed}=permuteAxesAndTranspose(x,axis,backend);if(inputWasTransposed){const transposedId=backend.dataIdMap.get(transposed.dataId).id;transposedId!==xId&&(input=transposed,inputId=transposedId)}const inputRank=input.shape.length;dist.C0T.assertAxesAreInnerMostDims("min",axes,inputRank);const[outShape,reduceShape]=dist.C0T.computeOutAndReduceShapes(input.shape,axes),reduceSize=dist.ZSL.sizeFromShape(reduceShape),out=backend.makeOutput(outShape,input.dtype);if(0!==dist.ZSL.sizeFromShape(input.shape)){const outId=backend.dataIdMap.get(out.dataId).id;wasmMin(inputId,CppDType[x.dtype],reduceSize,outId)}if(inputWasTransposed&&backend.disposeData(transposed.dataId),keepDims){const newShape=dist.C0T.expandShapeToKeepDim(out.shape,originalAxes);out.shape=newShape}return out}},minimumConfig=createBinaryKernelConfig(dist.LG0);var MirrorPaddingMode;let wasmMirrorPad;!function(MirrorPaddingMode){MirrorPaddingMode[MirrorPaddingMode.reflect=0]="reflect",MirrorPaddingMode[MirrorPaddingMode.symmetric=1]="symmetric"}(MirrorPaddingMode||(MirrorPaddingMode={}));const mirrorPadConfig={kernelName:dist.x7F,backendName:"wasm",kernelFunc:function mirrorPad(args){const{inputs:{x},backend,attrs:{paddings,mode}}=args,outShape=paddings.map((p,i)=>p[0]+x.shape[i]+p[1]),xId=backend.dataIdMap.get(x.dataId).id,out=backend.makeOutput(outShape,x.dtype),outId=backend.dataIdMap.get(out.dataId).id,xShapeBytes=new Uint8Array(new Int32Array(x.shape).buffer),prePaddingsFlat=paddings.map(padTuple=>padTuple[0]),postPaddingsFlat=paddings.map(padTuple=>padTuple[1]),prePaddingsBytes=new Uint8Array(new Int32Array(prePaddingsFlat).buffer),postPaddingsBytes=new Uint8Array(new Int32Array(postPaddingsFlat).buffer);return wasmMirrorPad(xId,xShapeBytes,x.shape.length,CppDType[x.dtype],prePaddingsBytes,postPaddingsBytes,MirrorPaddingMode[mode],outId),out},setupFunc:function MirrorPad_setup(backend){wasmMirrorPad=backend.wasm.cwrap(dist.x7F,null,["number","array","number","number","array","array","number","number"])}};let Softmax_wasmFunc;function softmax(args){const{backend,inputs:{logits},attrs:{dim}}=args,xId=backend.dataIdMap.get(logits.dataId).id,out=backend.makeOutput(logits.shape,logits.dtype),outId=backend.dataIdMap.get(out.dataId).id,channels=logits.shape[dim],batch=dist.ZSL.sizeFromShape(logits.shape)/channels;return 0===dist.ZSL.sizeFromShape(out.shape)||Softmax_wasmFunc(xId,outId,channels,batch),out}const softmaxConfig={kernelName:dist.rFG,backendName:"wasm",setupFunc:function Softmax_setup(backend){Softmax_wasmFunc=backend.wasm.cwrap(dist.rFG,null,["number","number","number","number"])},kernelFunc:softmax};let wasmMultinomial;const multinomialConfig={kernelName:dist.WT3,backendName:"wasm",setupFunc:function Multinomial_setup(backend){wasmMultinomial=backend.wasm.cwrap(dist.WT3,null,["number","number","number","number","number","number"])},kernelFunc:function multinomial(args){const{inputs,backend,attrs}=args,{logits}=inputs,{numSamples,seed,normalized}=attrs;if("float32"!==logits.dtype)throw new Error(`Tensor logits must have dtype float32, got ${logits.dtype}`);const probabilities=normalized?logits:softmax({inputs:{logits},backend,attrs:{dim:logits.shape.length-1}}),[batchSize,numEvents]=probabilities.shape,out=backend.makeOutput([batchSize,numSamples],"int32");return wasmMultinomial(backend.dataIdMap.get(probabilities.dataId).id,batchSize,numEvents,numSamples,seed,backend.dataIdMap.get(out.dataId).id),normalized||backend.disposeData(probabilities.dataId),out}},modConfig=createBinaryKernelConfig(dist.BLA),multiplyConfig=createBinaryKernelConfig(dist.xu7),negConfig=createUnaryKernelConfig(dist.l0G);function parseResultStruct(backend,resOffset){const result=new Int32Array(backend.wasm.HEAPU8.buffer,resOffset,4),pSelectedIndices=result[0],selectedSize=result[1],pSelectedScores=result[2],pValidOutputs=result[3];return backend.wasm._free(resOffset),{pSelectedIndices,selectedSize,pSelectedScores,pValidOutputs}}let NonMaxSuppressionV3_wasmFunc;const nonMaxSuppressionV3Config={kernelName:dist.SDM,backendName:"wasm",setupFunc:function NonMaxSuppressionV3_setup(backend){NonMaxSuppressionV3_wasmFunc=backend.wasm.cwrap(dist.SDM,"number",["number","number","number","number","number"])},kernelFunc:function kernelFunc(args){const{backend,inputs,attrs}=args,{iouThreshold,maxOutputSize,scoreThreshold}=attrs,{boxes,scores}=inputs,boxesId=backend.dataIdMap.get(boxes.dataId).id,scoresId=backend.dataIdMap.get(scores.dataId).id,resOffset=NonMaxSuppressionV3_wasmFunc(boxesId,scoresId,maxOutputSize,iouThreshold,scoreThreshold),{pSelectedIndices,selectedSize,pSelectedScores,pValidOutputs}=parseResultStruct(backend,resOffset);return backend.wasm._free(pSelectedScores),backend.wasm._free(pValidOutputs),backend.makeOutput([selectedSize],"int32",pSelectedIndices)}};let NonMaxSuppressionV4_wasmFunc;const nonMaxSuppressionV4Config={kernelName:dist.Zl4,backendName:"wasm",setupFunc:function NonMaxSuppressionV4_setup(backend){NonMaxSuppressionV4_wasmFunc=backend.wasm.cwrap(dist.Zl4,"number",["number","number","number","number","number","bool"])},kernelFunc:function nonMaxSuppressionV4(args){const{backend,inputs,attrs}=args,{iouThreshold,maxOutputSize,scoreThreshold,padToMaxOutputSize}=attrs,{boxes,scores}=inputs,boxesId=backend.dataIdMap.get(boxes.dataId).id,scoresId=backend.dataIdMap.get(scores.dataId).id,resOffset=NonMaxSuppressionV4_wasmFunc(boxesId,scoresId,maxOutputSize,iouThreshold,scoreThreshold,padToMaxOutputSize),{pSelectedIndices,selectedSize,pSelectedScores,pValidOutputs}=parseResultStruct(backend,resOffset);return backend.wasm._free(pSelectedScores),[backend.makeOutput([selectedSize],"int32",pSelectedIndices),backend.makeOutput([],"int32",pValidOutputs)]}};let NonMaxSuppressionV5_wasmFunc;const nonMaxSuppressionV5Config={kernelName:dist.e0f,backendName:"wasm",setupFunc:function NonMaxSuppressionV5_setup(backend){NonMaxSuppressionV5_wasmFunc=backend.wasm.cwrap(dist.e0f,"number",["number","number","number","number","number","number"])},kernelFunc:function NonMaxSuppressionV5_kernelFunc(args){const{backend,inputs,attrs}=args,{iouThreshold,maxOutputSize,scoreThreshold,softNmsSigma}=attrs,{boxes,scores}=inputs,boxesId=backend.dataIdMap.get(boxes.dataId).id,scoresId=backend.dataIdMap.get(scores.dataId).id,resOffset=NonMaxSuppressionV5_wasmFunc(boxesId,scoresId,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma),{pSelectedIndices,selectedSize,pSelectedScores,pValidOutputs}=parseResultStruct(backend,resOffset);return backend.wasm._free(pValidOutputs),[backend.makeOutput([selectedSize],"int32",pSelectedIndices),backend.makeOutput([selectedSize],"float32",pSelectedScores)]}},notEqualConfig=createBinaryKernelConfig(dist.ylV,0,"bool");let wasmOneHot;const oneHotConfig={kernelName:dist.urI,backendName:"wasm",setupFunc:function OneHot_setup(backend){wasmOneHot=backend.wasm.cwrap(dist.urI,null,["number","number","number","number","number"])},kernelFunc:function oneHot(args){const{inputs,backend,attrs}=args,{indices}=inputs,{dtype,depth,onValue,offValue}=attrs,out=backend.makeOutput([...indices.shape,depth],dtype),outId=backend.dataIdMap.get(out.dataId).id,indicesId=backend.dataIdMap.get(indices.dataId).id;return wasmOneHot(indicesId,depth,onValue,offValue,outId),out}};const onesLikeConfig={kernelName:dist.LWX,backendName:"wasm",kernelFunc:function onesLike(args){const{inputs:{x},backend}=args,out=backend.makeOutput(x.shape,x.dtype);return backend.typedArrayFromHeap(out).fill(1),out}};const packConfig={kernelName:dist.mM$,backendName:"wasm",kernelFunc:function pack(args){const{inputs,backend,attrs}=args,{axis}=attrs;if(1===inputs.length)return expandDims({inputs:{input:inputs[0]},backend,attrs:{dim:axis}});const shape=inputs[0].shape,dtype=inputs[0].dtype;inputs.forEach(t=>{dist.ZSL.assertShapesMatch(shape,t.shape,"All tensors passed to stack must have matching shapes"),dist.ZSL.assert(dtype===t.dtype,()=>"All tensors passed to stack must have matching dtypes")});const intermediateTensorInfos=[],result=concat({inputs:inputs.map(t=>{const expandedT=expandDims({inputs:{input:t},backend,attrs:{dim:axis}});return intermediateTensorInfos.push(expandedT),expandedT}),backend,attrs:{axis}});return intermediateTensorInfos.forEach(t=>backend.disposeData(t.dataId)),result}};let wasmPadV2;const padV2Config={kernelName:dist.ODT,backendName:"wasm",kernelFunc:function pad(args){const{inputs:{x},backend,attrs:{paddings,constantValue}}=args,outShape=paddings.map((p,i)=>p[0]+x.shape[i]+p[1]);if(0===dist.ZSL.sizeFromShape(x.shape))return fill({backend,attrs:{shape:outShape,value:constantValue,dtype:x.dtype}});const xId=backend.dataIdMap.get(x.dataId).id,out=backend.makeOutput(outShape,x.dtype),outId=backend.dataIdMap.get(out.dataId).id,xShapeBytes=new Uint8Array(new Int32Array(x.shape).buffer),prePaddingsFlat=paddings.map(padTuple=>padTuple[0]),postPaddingsFlat=paddings.map(padTuple=>padTuple[1]),prePaddingsBytes=new Uint8Array(new Int32Array(prePaddingsFlat).buffer),postPaddingsBytes=new Uint8Array(new Int32Array(postPaddingsFlat).buffer);return wasmPadV2(xId,xShapeBytes,x.shape.length,CppDType[x.dtype],prePaddingsBytes,postPaddingsBytes,constantValue,outId),out},setupFunc:function PadV2_setup(backend){wasmPadV2=backend.wasm.cwrap(dist.ODT,null,["number","array","number","number","array","array","number","number"])}},powConfig=createBinaryKernelConfig(dist.pyJ);let wasmPrelu;const preluConfig={kernelName:dist.Ncv,backendName:"wasm",setupFunc:function Prelu_setup(backend){wasmPrelu=backend.wasm.cwrap(dist.Ncv,null,["number","number","number"])},kernelFunc:function prelu(args){const{inputs,backend}=args,{x,alpha}=inputs,xId=backend.dataIdMap.get(x.dataId).id,weightsId=backend.dataIdMap.get(alpha.dataId).id;let inputId=xId;const input=x;let castedInput=input;"float32"!==input.dtype&&(castedInput=cast({backend,inputs:{x},attrs:{dtype:"float32"}}),inputId=backend.dataIdMap.get(castedInput.dataId).id);const out=backend.makeOutput(x.shape,"float32"),outId=backend.dataIdMap.get(out.dataId).id;return wasmPrelu(inputId,weightsId,outId),"float32"!==input.dtype&&backend.disposeData(castedInput.dataId),out}};let wasmProd;const prodConfig={kernelName:dist.kdj,backendName:"wasm",setupFunc:function Prod_setup(backend){wasmProd=backend.wasm.cwrap(dist.kdj,null,["number","number","number","number"])},kernelFunc:function prod(args){const{backend,inputs,attrs}=args,{axis,keepDims}=attrs,{x}=inputs,xId=backend.dataIdMap.get(x.dataId).id;let inputId=xId,input=x;const{transposed,axes,originalAxes,inputWasTransposed}=permuteAxesAndTranspose(x,axis,backend);let reductionAxes=axes;if(inputWasTransposed){const transposedId=backend.dataIdMap.get(transposed.dataId).id;transposedId!==xId&&(input=transposed,inputId=transposedId,reductionAxes=dist.C0T.getInnerMostAxes(reductionAxes.length,input.shape.length))}dist.C0T.assertAxesAreInnerMostDims("prod",reductionAxes,input.shape.length);const[outShape,reduceShape]=dist.C0T.computeOutAndReduceShapes(input.shape,reductionAxes),reduceSize=dist.ZSL.sizeFromShape(reduceShape),out=backend.makeOutput(outShape,input.dtype);if(0!==dist.ZSL.sizeFromShape(input.shape)){const outId=backend.dataIdMap.get(out.dataId).id;wasmProd(inputId,reduceSize,CppDType[out.dtype],outId)}if(inputWasTransposed&&backend.disposeData(transposed.dataId),keepDims){const newShape=dist.C0T.expandShapeToKeepDim(out.shape,originalAxes);out.shape=newShape}return out}};var Range_impl=__webpack_require__("./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Range_impl.js");const rangeConfig={kernelName:dist.Q6t,backendName:"wasm",kernelFunc:args=>{const{backend,attrs}=args,{start,stop,step,dtype}=attrs,values=(0,Range_impl.q)(start,stop,step,dtype),out=backend.makeOutput([values.length],dtype);return backend.typedArrayFromHeap(out).set(values),out}},realDivConfig=createBinaryKernelConfig(dist.sDr),reciprocalConfig=createUnaryKernelConfig(dist.huO),reluConfig=createUnaryKernelConfig(dist.fUj),relu6Config=createUnaryKernelConfig(dist.P_L);let wasmResizeBilinear;const resizeBilinearConfig={kernelName:dist.hgw,backendName:"wasm",setupFunc:function ResizeBilinear_setup(backend){wasmResizeBilinear=backend.wasm.cwrap(dist.hgw,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function resizeBilinear(args){const{backend,inputs,attrs}=args,{images}=inputs,{alignCorners,halfPixelCenters,size}=attrs,[newHeight,newWidth]=size,[batch,oldHeight,oldWidth,numChannels]=images.shape,outShape=[batch,newHeight,newWidth,numChannels];let castedData,xData=backend.dataIdMap.get(images.dataId);"float32"!==xData.dtype&&(castedData=cast({backend,inputs:{x:images},attrs:{dtype:"float32"}}),xData=backend.dataIdMap.get(castedData.dataId));const xId=xData.id,out=backend.makeOutput(outShape,"float32");if(0===dist.ZSL.sizeFromShape(images.shape))return out;const outId=backend.dataIdMap.get(out.dataId).id;return wasmResizeBilinear(xId,batch,oldHeight,oldWidth,numChannels,newHeight,newWidth,alignCorners?1:0,halfPixelCenters?1:0,outId),null!=castedData&&backend.disposeData(castedData.dataId),out}};let wasmResizeBilinearGrad;const resizeBilinearGradConfig={kernelName:dist.FCQ,backendName:"wasm",setupFunc:function ResizeBilinearGrad_setup(backend){wasmResizeBilinearGrad=backend.wasm.cwrap(dist.FCQ,null,["number","number","number","array","array","boolean"])},kernelFunc:function resizeBilinearGrad(args){const{inputs,backend,attrs}=args,{images,dy}=inputs,{alignCorners}=attrs,dx=backend.makeOutput(images.shape,"float32");let castedData,xData=backend.dataIdMap.get(images.dataId);return"float32"!==xData.dtype&&(castedData=cast({backend,inputs:{x:images},attrs:{dtype:"float32"}}),xData=backend.dataIdMap.get(castedData.dataId)),wasmResizeBilinearGrad(backend.dataIdMap.get(images.dataId).id,backend.dataIdMap.get(dy.dataId).id,backend.dataIdMap.get(dx.dataId).id,new Uint8Array(new Int32Array(images.shape).buffer),new Uint8Array(new Int32Array(dy.shape).buffer),alignCorners),null!=castedData&&backend.disposeData(castedData.dataId),dx}};let wasmResizeNearestNeighbor;const resizeNearestNeighborConfig={kernelName:dist.jOE,backendName:"wasm",setupFunc:function ResizeNearestNeighbor_setup(backend){wasmResizeNearestNeighbor=backend.wasm.cwrap(dist.jOE,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function resizeNearestNeighbor(args){const{backend,inputs,attrs}=args,{images}=inputs,{alignCorners,halfPixelCenters,size}=attrs,[newHeight,newWidth]=size,[batch,oldHeight,oldWidth,numChannels]=images.shape,outShape=[batch,newHeight,newWidth,numChannels],out=backend.makeOutput(outShape,"float32");if(0===dist.ZSL.sizeFromShape(images.shape))return out;let castedData,xData=backend.dataIdMap.get(images.dataId);"float32"!==xData.dtype&&(castedData=cast({backend,inputs:{x:images},attrs:{dtype:"float32"}}),xData=backend.dataIdMap.get(castedData.dataId));const xId=xData.id,outId=backend.dataIdMap.get(out.dataId).id;return wasmResizeNearestNeighbor(xId,batch,oldHeight,oldWidth,numChannels,newHeight,newWidth,alignCorners?1:0,halfPixelCenters?1:0,outId),null!=castedData&&backend.disposeData(castedData.dataId),out}};let wasmResizeNearestNeighborGrad;const resizeNearestNeighborGradConfig={kernelName:dist.XQy,backendName:"wasm",setupFunc:function ResizeNearestNeighborGrad_setup(backend){wasmResizeNearestNeighborGrad=backend.wasm.cwrap(dist.XQy,null,["number","number","number","array","array","boolean"])},kernelFunc:function resizeNearestNeighborGrad(args){const{inputs,backend,attrs}=args,{images,dy}=inputs,{alignCorners}=attrs,dx=backend.makeOutput(images.shape,"float32");let castedData,xData=backend.dataIdMap.get(images.dataId);return"float32"!==xData.dtype&&(castedData=cast({backend,inputs:{x:images},attrs:{dtype:"float32"}}),xData=backend.dataIdMap.get(castedData.dataId)),wasmResizeNearestNeighborGrad(backend.dataIdMap.get(images.dataId).id,backend.dataIdMap.get(dy.dataId).id,backend.dataIdMap.get(dx.dataId).id,new Uint8Array(new Int32Array(images.shape).buffer),new Uint8Array(new Int32Array(dy.shape).buffer),alignCorners),null!=castedData&&backend.disposeData(castedData.dataId),dx}};let wasmReverse;const reverseConfig={kernelName:dist.D7i,backendName:"wasm",kernelFunc:function reverse(args){const{inputs,backend,attrs}=args,{x}=inputs,{dims}=attrs,axes=dist.ZSL.parseAxisParam(dims,x.shape);if(0===x.shape.length)return identity({inputs:{x},backend});const out=backend.makeOutput(x.shape,x.dtype),xId=backend.dataIdMap.get(x.dataId).id,outId=backend.dataIdMap.get(out.dataId).id,axesBytes=new Uint8Array(new Int32Array(axes).buffer),outShapeBytes=new Uint8Array(new Int32Array(x.shape).buffer);wasmReverse(xId,axesBytes,axes.length,outShapeBytes,x.shape.length,outId);const reshaped=reshape({inputs:{x:out},attrs:{shape:x.shape},backend});return backend.disposeData(out.dataId),reshaped},setupFunc:function Reverse_setup(backend){wasmReverse=backend.wasm.cwrap(dist.D7i,null,["number","array","number","array","number","number"])}};let wasmRotate;const rotateWithOffsetConfig={kernelName:dist.BK4,backendName:"wasm",kernelFunc:function rotateWithOffset(args){const{inputs,backend,attrs}=args,{image}=inputs,{radians,fillValue,center}=attrs,out=backend.makeOutput(image.shape,image.dtype),imageId=backend.dataIdMap.get(image.dataId).id,outId=backend.dataIdMap.get(out.dataId).id,[batch,imageHeight,imageWidth,numChannels]=image.shape,[centerX,centerY]=dist.C0T.getImageCenter(center,imageHeight,imageWidth),fillValues="number"==typeof fillValue?[fillValue,fillValue,fillValue,0===fillValue?0:255]:[...fillValue,255],fillBytes=new Uint8Array(new Int32Array(fillValues).buffer);return wasmRotate(imageId,batch,imageHeight,imageWidth,numChannels,radians,centerX,centerY,fillBytes,fillValues.length,outId),out},setupFunc:function RotateWithOffset_setup(backend){wasmRotate=backend.wasm.cwrap(dist.BK4,null,["number","number","number","number","number","number","number","number","array","number","number"])}},roundConfig=createUnaryKernelConfig(dist.hVg),rsqrtConfig=createUnaryKernelConfig(dist.TOR);let wasmScatterNd;const scatterNdConfig={kernelName:dist.pJc,backendName:"wasm",setupFunc:function ScatterNd_setup(backend){wasmScatterNd=backend.wasm.cwrap(dist.pJc,null,["number","number","number","number","number","number","array","number","number"])},kernelFunc:function scatterNd(args){const{backend,inputs,attrs}=args,{indices,updates}=inputs,{shape}=attrs,out=backend.makeOutput(shape,updates.dtype);if(0===dist.ZSL.sizeFromShape(shape))return out;const{sliceRank,numUpdates,sliceSize,strides,outputSize}=dist.g23.calculateShapes(updates,indices,shape),indicesId=backend.dataIdMap.get(indices.dataId).id,updatesId=backend.dataIdMap.get(updates.dataId).id,stridesBytes=new Uint8Array(new Int32Array(strides).buffer),outId=backend.dataIdMap.get(out.dataId).id;return wasmScatterNd(indicesId,updatesId,CppDType[updates.dtype],sliceRank,numUpdates,sliceSize,stridesBytes,outputSize,outId),out}};let wasmSearchSorted;const searchSortedConfig={kernelName:dist.uWl,backendName:"wasm",setupFunc:function SearchSorted_setup(backend){wasmSearchSorted=backend.wasm.cwrap(dist.uWl,null,["number","number","number","number","number","number","bool","number"])},kernelFunc:function searchSorted(args){const{inputs,backend,attrs}=args,{sortedSequence,values}=inputs,{side}=attrs;if(sortedSequence.dtype!==values.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${sortedSequence.dtype} and ${values.dtype}`);const out=backend.makeOutput(values.shape,"int32");function tensorId(x){return backend.dataIdMap.get(x.dataId).id}return wasmSearchSorted(tensorId(sortedSequence),tensorId(values),sortedSequence.shape[0],sortedSequence.shape[1],values.shape[1],CppDType[sortedSequence.dtype],"left"===side,tensorId(out)),out}};let wasmSelect;const selectConfig={kernelName:dist.l6P,backendName:"wasm",kernelFunc:function Select_select(args){const{inputs,backend}=args,{condition,t,e}=inputs,conditionId=backend.dataIdMap.get(condition.dataId).id,tId=backend.dataIdMap.get(t.dataId).id,eId=backend.dataIdMap.get(e.dataId).id,out=backend.makeOutput(t.shape,t.dtype),outId=backend.dataIdMap.get(out.dataId).id,cRank=condition.shape.length,tRank=t.shape.length,offset=0===cRank||cRank>1||1===tRank?1:dist.ZSL.sizeFromShape(t.shape.slice(1));return wasmSelect(conditionId,tId,eId,offset,outId),out},setupFunc:function Select_setup(backend){wasmSelect=backend.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}},seluConfig=createUnaryKernelConfig(dist.u$b);let Sigmoid_wasmFunc;const sigmoidConfig={kernelName:"Sigmoid",backendName:"wasm",setupFunc:function Sigmoid_setup(backend){Sigmoid_wasmFunc=backend.wasm.cwrap(dist.vI1,null,["number","number"])},kernelFunc:function sigmoid(args){const{backend,inputs:{x}}=args,xId=backend.dataIdMap.get(x.dataId).id,out=backend.makeOutput(x.shape,x.dtype),outId=backend.dataIdMap.get(out.dataId).id;return 0===dist.ZSL.sizeFromShape(out.shape)||Sigmoid_wasmFunc(xId,outId),out}},signConfig=createUnaryKernelConfig(dist.YVe),sinConfig=createUnaryKernelConfig(dist.hql),sinhConfig=createUnaryKernelConfig(dist.J3C),softplusConfig=createUnaryKernelConfig(dist.Fin);const spaceToBatchNDConfig={kernelName:dist.A8B,backendName:"wasm",kernelFunc:function spaceToBatchND(args){const{inputs,backend,attrs}=args,{x}=inputs,{blockShape,paddings}=attrs,prod=dist.ZSL.sizeFromShape(blockShape),completePaddings=[[0,0]];completePaddings.push(...paddings);for(let i=1+blockShape.length;i<x.shape.length;++i)completePaddings.push([0,0]);const paddedX=padV2Config.kernelFunc({inputs:{x},backend,attrs:{paddings:completePaddings,constantValue:0}}),reshapedPaddedShape=dist.C0T.getReshaped(paddedX.shape,blockShape,prod,!1),permutedReshapedPaddedPermutation=dist.C0T.getPermuted(reshapedPaddedShape.length,blockShape.length,!1),flattenShape=dist.C0T.getReshapedPermuted(paddedX.shape,blockShape,prod,!1),paddedXReshaped=reshape({inputs:{x:paddedX},backend,attrs:{shape:reshapedPaddedShape}}),paddedXT=transpose({inputs:{x:paddedXReshaped},backend,attrs:{perm:permutedReshapedPaddedPermutation}}),result=reshape({inputs:{x:paddedXT},backend,attrs:{shape:flattenShape}});return backend.disposeData(paddedX.dataId),backend.disposeData(paddedXReshaped.dataId),backend.disposeData(paddedXT.dataId),result}};let wasmSparseFillEmptyRows;const sparseFillEmptyRowsConfig={kernelName:dist.C8s,backendName:"wasm",setupFunc:function SparseFillEmptyRows_setup(backend){wasmSparseFillEmptyRows=backend.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function sparseFillEmptyRows(args){const{backend,inputs}=args,{indices,values,denseShape,defaultValue}=inputs,indicesCount=indices.shape[0],rank=indices.shape[1],denseRows=backend.readSync(denseShape.dataId)[0],maxOutputIndicesShape=[indicesCount+denseRows,rank],indicesId=backend.dataIdMap.get(indices.dataId).id,valuesId=backend.dataIdMap.get(values.dataId).id,defaultValueId=backend.dataIdMap.get(defaultValue.dataId).id,outputIndices=backend.makeOutput(maxOutputIndicesShape,indices.dtype),outputIndicesId=backend.dataIdMap.get(outputIndices.dataId).id,outputValues=backend.makeOutput(maxOutputIndicesShape.slice(0,1),values.dtype),outputValuesId=backend.dataIdMap.get(outputValues.dataId).id,emptyRowIndicator=backend.makeOutput([denseRows],"bool"),emptyRowIndicatorId=backend.dataIdMap.get(emptyRowIndicator.dataId).id,reverseIndexMap=backend.makeOutput([indicesCount],indices.dtype),reverseIndexMapId=backend.dataIdMap.get(reverseIndexMap.dataId).id,exceptionValues=backend.makeOutput([4],"int32"),exceptionValuesId=backend.dataIdMap.get(exceptionValues.dataId).id,outputRows=wasmSparseFillEmptyRows(indicesId,valuesId,CppDType[values.dtype],indicesCount,denseRows,rank,defaultValueId,outputIndicesId,outputValuesId,emptyRowIndicatorId,reverseIndexMapId,exceptionValuesId),exceptionValuesArray=backend.readSync(exceptionValues.dataId);let exceptionMessage;switch(exceptionValuesArray[0]){case 1:exceptionMessage=dist.C0T.getSparseFillEmptyRowsIndicesDenseShapeMismatch(exceptionValuesArray[1]);break;case 2:exceptionMessage=dist.C0T.getSparseFillEmptyRowsNegativeIndexErrorMessage(exceptionValuesArray[1],exceptionValuesArray[2]);break;case 3:exceptionMessage=dist.C0T.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(exceptionValuesArray[1],exceptionValuesArray[2],exceptionValuesArray[3]);break;default:exceptionMessage=""}if(backend.disposeData(exceptionValues.dataId),exceptionMessage)throw backend.disposeData(outputIndices.dataId),backend.disposeData(outputValues.dataId),backend.disposeData(emptyRowIndicator.dataId),backend.disposeData(reverseIndexMap.dataId),new Error(exceptionMessage);let resizedIndices=outputIndices,resizedValues=outputValues;return outputRows!==maxOutputIndicesShape[0]&&(resizedIndices=slice({inputs:{x:outputIndices},attrs:{begin:0,size:[outputRows,rank]},backend}),resizedValues=slice({inputs:{x:outputValues},attrs:{begin:0,size:outputRows},backend}),backend.disposeData(outputIndices.dataId),backend.disposeData(outputValues.dataId)),[resizedIndices,resizedValues,emptyRowIndicator,reverseIndexMap]}};let wasmSparseReshape;const sparseReshapeConfig={kernelName:dist.BoJ,backendName:"wasm",setupFunc:function SparseReshape_setup(backend){wasmSparseReshape=backend.wasm.cwrap(dist.BoJ,null,["number","number","number","number","number","number","number"])},kernelFunc:function sparseReshape(args){const{backend,inputs}=args,{inputIndices,inputShape,newShape}=inputs;if(2!==inputIndices.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${inputIndices.shape}`);if(1!==inputShape.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${inputShape.shape}`);if(1!==newShape.shape.length)throw new Error(`Target shape should be a vector but received shape ${newShape.shape}`);const inputIndicesId=backend.dataIdMap.get(inputIndices.dataId).id,inputShapeId=backend.dataIdMap.get(inputShape.dataId).id,newShapeId=backend.dataIdMap.get(newShape.dataId).id,nnz=inputIndices.shape[0],outputRank=dist.ZSL.sizeFromShape(newShape.shape),newIndices=backend.makeOutput([nnz,outputRank],inputIndices.dtype),newIndicesId=backend.dataIdMap.get(newIndices.dataId).id,outputShape=backend.makeOutput([outputRank],newShape.dtype),outputShapeId=backend.dataIdMap.get(outputShape.dataId).id,exceptionValues=backend.makeOutput([3],"int32"),exceptionValuesId=backend.dataIdMap.get(exceptionValues.dataId).id;wasmSparseReshape(inputIndicesId,inputShapeId,newShapeId,nnz,newIndicesId,outputShapeId,exceptionValuesId);const exceptionValuesArray=backend.readSync(exceptionValues.dataId);let exceptionMessage;switch(exceptionValuesArray[0]){case 0:exceptionMessage=dist.C0T.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(exceptionValuesArray[1],exceptionValuesArray[2]);break;case 1:exceptionMessage=dist.C0T.getSparseReshapeNegativeOutputDimErrorMessage(exceptionValuesArray[1],exceptionValuesArray[2]);break;case 2:exceptionMessage=dist.C0T.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{const inputShapeValues=Array.from(backend.readSync(inputShape.dataId)),outputShapeValues=Array.from(backend.readSync(outputShape.dataId));exceptionMessage=dist.C0T.getSparseReshapeInputOutputMultipleErrorMessage(inputShapeValues,outputShapeValues);break}case 4:{const inputShapeValues=Array.from(backend.readSync(inputShape.dataId)),outputShapeValues=Array.from(backend.readSync(outputShape.dataId));exceptionMessage=dist.C0T.getSparseReshapeInputOutputMismatchErrorMessage(inputShapeValues,outputShapeValues);break}default:exceptionMessage=""}if(backend.disposeData(exceptionValues.dataId),exceptionMessage)throw backend.disposeData(newIndices.dataId),backend.disposeData(outputShape.dataId),new Error(exceptionMessage);return[newIndices,outputShape]}};let wasmSparseSegmentReduction;function SparseSegmentReduction_setup(backend){wasmSparseSegmentReduction=backend.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function sparseSegmentReduction(args,isMean){const{backend,inputs}=args,{data,indices,segmentIds}=inputs,numIndices=indices.shape[0],segmentIdsBack=backend.readSync(segmentIds.dataId,numIndices-1,numIndices)[0],outputRows=numIndices>0?segmentIdsBack+1:0;if(outputRows<0)throw new Error(dist.C0T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const outputShape=data.shape.slice();outputShape[0]=outputRows;const dataId=backend.dataIdMap.get(data.dataId).id,indicesId=backend.dataIdMap.get(indices.dataId).id,segmentIdsId=backend.dataIdMap.get(segmentIds.dataId).id,output=backend.makeOutput(outputShape,data.dtype),outputId=backend.dataIdMap.get(output.dataId).id,exceptionValues=backend.makeOutput([4],"int32"),exceptionValuesId=backend.dataIdMap.get(exceptionValues.dataId).id;wasmSparseSegmentReduction(dataId,CppDType[data.dtype],data.shape[0],indicesId,segmentIdsId,outputId,exceptionValuesId,isMean,0);const exceptionValuesArray=backend.readSync(exceptionValues.dataId);let exceptionMessage;switch(exceptionValuesArray[0]){case 0:exceptionMessage=dist.C0T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break;case 1:exceptionMessage=dist.C0T.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break;case 2:exceptionMessage=dist.C0T.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(exceptionValuesArray[1],exceptionValuesArray[2]);break;case 3:exceptionMessage=dist.C0T.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(exceptionValuesArray[1],exceptionValuesArray[2],exceptionValuesArray[3]);break;default:exceptionMessage=""}if(backend.disposeData(exceptionValues.dataId),exceptionMessage)throw backend.disposeData(output.dataId),new Error(exceptionMessage);return output}const sparseSegmentMeanConfig={kernelName:dist.L6G,backendName:"wasm",setupFunc:SparseSegmentReduction_setup,kernelFunc:function sparseSegmentMean(args){return sparseSegmentReduction(args,!0)}};const sparseSegmentSumConfig={kernelName:dist.DvZ,backendName:"wasm",setupFunc:SparseSegmentReduction_setup,kernelFunc:function sparseSegmentSum(args){return sparseSegmentReduction(args,!1)}};let wasmSparseToDense;const sparseToDenseConfig={kernelName:dist.jgd,backendName:"wasm",setupFunc:function SparseToDense_setup(backend){wasmSparseToDense=backend.wasm.cwrap(dist.jgd,null,["number","number","number","number","number","number","number","number","array","number","number"])},kernelFunc:function sparseToDense(args){const{backend,inputs,attrs}=args,{sparseIndices,sparseValues,defaultValue}=inputs,{outputShape}=attrs,out=backend.makeOutput(outputShape,defaultValue.dtype);if(0===dist.ZSL.sizeFromShape(outputShape))return out;const{sliceRank,numUpdates,sliceSize,strides,outputSize}=dist.C0T.calculateShapes(sparseValues,sparseIndices,outputShape),sparseIndicesId=backend.dataIdMap.get(sparseIndices.dataId).id,sparseValuesId=backend.dataIdMap.get(sparseValues.dataId).id,defaultValueId=backend.dataIdMap.get(defaultValue.dataId).id,stridesBytes=new Uint8Array(new Int32Array(strides).buffer),outId=backend.dataIdMap.get(out.dataId).id;return wasmSparseToDense(sparseIndicesId,sparseValuesId,sparseValues.shape.length,defaultValueId,CppDType[defaultValue.dtype],sliceRank,numUpdates,sliceSize,stridesBytes,outputSize,outId),out}};const splitVConfig={kernelName:dist.Blb,backendName:"wasm",kernelFunc:function splitV(args){const{inputs,attrs,backend}=args,{x}=inputs,{numOrSizeSplits,axis}=attrs,$axis=dist.ZSL.parseAxisParam(axis,x.shape)[0],splitSizes=dist.C0T.prepareSplitSize(x,numOrSizeSplits,$axis),begin=new Array(x.shape.length).fill(0),size=x.shape.slice();return splitSizes.map(s=>{const xSliceSize=[...size];xSliceSize[$axis]=s;const xSlice=slice({inputs:{x},attrs:{begin,size:xSliceSize},backend});return begin[$axis]+=s,xSlice})}},sqrtConfig=createUnaryKernelConfig(dist.dFH),squareConfig=createUnaryKernelConfig(dist.M6A),squaredDifferenceConfig=createBinaryKernelConfig(dist.Ddj);let wasmStep;const stepConfig={kernelName:dist.pnw,backendName:"wasm",setupFunc:function Step_setup(backend){wasmStep=backend.wasm.cwrap(dist.pnw,null,["number","number","number","number"])},kernelFunc:function step(args){const{backend,inputs,attrs}=args,{alpha}=attrs,{x}=inputs,xId=backend.dataIdMap.get(x.dataId).id,out=backend.makeOutput(x.shape,x.dtype),outId=backend.dataIdMap.get(out.dataId).id;return wasmStep(xId,alpha,CppDType[x.dtype],outId),out}};let wasmStridedSlice;const stridedSliceConfig={kernelName:dist.UcO,backendName:"wasm",setupFunc:function StridedSlice_setup(backend){wasmStridedSlice=backend.wasm.cwrap(dist.UcO,null,["number","array","number","array","array","array","array","array","number","number"])},kernelFunc:function stridedSlice(args){const{backend,inputs,attrs}=args,{x}=inputs,{begin,end,strides,beginMask,endMask,ellipsisMask,newAxisMask,shrinkAxisMask}=attrs,{finalShapeSparse,finalShape,isIdentity,sliceDim0,isSimpleSlice,begin:$begin,end:$end,strides:$strides}=dist.Kro.sliceInfo(x.shape,begin,end,strides,beginMask,endMask,ellipsisMask,newAxisMask,shrinkAxisMask);let result;if(isIdentity)result=reshape({inputs:{x},backend,attrs:{shape:finalShape}});else if(sliceDim0||isSimpleSlice){dist.ZSL.assert(x.shape.length>=1,()=>`Input must have rank at least 1, got: ${x.shape.length}`);const size=dist.Kro.computeOutShape($begin,$end,$strides),sliced=slice({inputs:{x},backend,attrs:{begin:$begin,size}});result=reshape({inputs:{x:sliced},backend,attrs:{shape:finalShape}}),backend.disposeData(sliced.dataId)}else{const out=backend.makeOutput(finalShapeSparse,"float32"),xId=backend.dataIdMap.get(x.dataId).id,xStridesBytes=new Uint8Array(new Int32Array(dist.ZSL.computeStrides(x.shape)).buffer),beginBytes=new Uint8Array(new Int32Array($begin).buffer),endBytes=new Uint8Array(new Int32Array($end).buffer),stridesBytes=new Uint8Array(new Int32Array($strides).buffer),outputShapeBytes=new Uint8Array(new Int32Array(finalShapeSparse).buffer),outStridesBytes=new Uint8Array(new Int32Array(dist.ZSL.computeStrides(finalShapeSparse)).buffer),outId=backend.dataIdMap.get(out.dataId).id;wasmStridedSlice(xId,xStridesBytes,x.shape.length,beginBytes,endBytes,stridesBytes,outputShapeBytes,outStridesBytes,finalShapeSparse.length,outId),result=reshape({inputs:{x:out},backend,attrs:{shape:finalShape}}),backend.disposeData(out.dataId)}return result}};var StringNGrams_impl=__webpack_require__("./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StringNGrams_impl.js");const stringNGramsConfig={kernelName:dist.YAb,backendName:"wasm",kernelFunc:function stringNGrams(args){const{backend,inputs,attrs}=args,{data,dataSplits}=inputs,{separator,nGramWidths,leftPad,rightPad,padWidth,preserveShortSequences}=attrs,$data=backend.readSync(data.dataId),$dataSplits=backend.readSync(dataSplits.dataId),[nGrams,nGramsSplits]=(0,StringNGrams_impl.G)($data,$dataSplits,separator,nGramWidths,leftPad,rightPad,padWidth,preserveShortSequences),nGramsOut=backend.makeOutput([nGrams.length],"string");backend.dataIdMap.get(nGramsOut.dataId).stringBytes=nGrams;const nGramsSplitsOut=backend.makeOutput(dataSplits.shape,"int32");return backend.typedArrayFromHeap(nGramsSplitsOut).set(nGramsSplits),[nGramsOut,nGramsSplitsOut]}};var StringSplit_impl=__webpack_require__("./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StringSplit_impl.js");const stringSplitConfig={kernelName:dist.iW0,backendName:"wasm",kernelFunc:function stringSplit(args){const{backend,inputs,attrs}=args,{input,delimiter}=inputs,{skipEmpty}=attrs,inputVals=backend.readSync(input.dataId),delimiterVals=backend.readSync(delimiter.dataId),[indices,values,shape]=(0,StringSplit_impl.S)(inputVals,delimiterVals[0],skipEmpty),outputSize=values.length,indicesOut=backend.makeOutput([outputSize,2],"int32");backend.typedArrayFromHeap(indicesOut).set(indices);const valuesOut=backend.makeOutput([outputSize],"string");backend.dataIdMap.get(valuesOut.dataId).stringBytes=values;const shapeOut=backend.makeOutput([2],"int32");return backend.typedArrayFromHeap(shapeOut).set(shape),[indicesOut,valuesOut,shapeOut]}};var StringToHashBucketFast_impl=__webpack_require__("./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StringToHashBucketFast_impl.js");const stringToHashBucketFastConfig={kernelName:dist.$jE,backendName:"wasm",kernelFunc:function stringToHashBucketFast(args){const{backend,inputs,attrs}=args,{input}=inputs,{numBuckets}=attrs,inputVals=backend.readSync(input.dataId),values=(0,StringToHashBucketFast_impl.f)(inputVals,numBuckets),out=backend.makeOutput(input.shape,"int32");return backend.typedArrayFromHeap(out).set(values),out}},subConfig=createBinaryKernelConfig(dist.PbM);let wasmSum;const sumConfig={kernelName:dist.WuN,backendName:"wasm",setupFunc:function Sum_setup(backend){wasmSum=backend.wasm.cwrap(dist.WuN,null,["number","number","number","number"])},kernelFunc:function sum(args){const{backend,inputs,attrs}=args,{axis,keepDims}=attrs,{x}=inputs,xId=backend.dataIdMap.get(x.dataId).id;let inputId=xId,input=x;const{transposed,axes,originalAxes,inputWasTransposed}=permuteAxesAndTranspose(x,axis,backend);let reductionAxes=axes;if(inputWasTransposed){const transposedId=backend.dataIdMap.get(transposed.dataId).id;transposedId!==xId&&(input=transposed,inputId=transposedId,reductionAxes=dist.C0T.getInnerMostAxes(reductionAxes.length,input.shape.length))}dist.C0T.assertAxesAreInnerMostDims("sum",reductionAxes,input.shape.length);const[outShape,reduceShape]=dist.C0T.computeOutAndReduceShapes(input.shape,reductionAxes),reduceSize=dist.ZSL.sizeFromShape(reduceShape),out=backend.makeOutput(outShape,input.dtype);if(0!==dist.ZSL.sizeFromShape(input.shape)){const outId=backend.dataIdMap.get(out.dataId).id;wasmSum(inputId,reduceSize,CppDType[out.dtype],outId)}if(inputWasTransposed&&backend.disposeData(transposed.dataId),keepDims){const newShape=dist.C0T.expandShapeToKeepDim(out.shape,originalAxes);out.shape=newShape}return out}},tanConfig=createUnaryKernelConfig(dist.oFs),tanhConfig=createUnaryKernelConfig(dist.iuW);let wasmTensorScatterUpdate;const tensorScatterUpdateConfig={kernelName:dist.X4r,backendName:"wasm",setupFunc:function TensorScatterUpdate_setup(backend){wasmTensorScatterUpdate=backend.wasm.cwrap(dist.X4r,null,["number","number","number","number","number","number","array","number","number","number"])},kernelFunc:function tensorScatterUpdate(args){const{backend,inputs,attrs}=args,{tensor,indices,updates}=inputs,{}=attrs,out=backend.makeOutput(tensor.shape,tensor.dtype);if(0===dist.ZSL.sizeFromShape(tensor.shape))return out;const{sliceRank,numUpdates,sliceSize,strides,outputSize}=dist.g23.calculateShapes(updates,indices,tensor.shape),indicesId=backend.dataIdMap.get(indices.dataId).id,updatesId=backend.dataIdMap.get(updates.dataId).id,tensorId=backend.dataIdMap.get(tensor.dataId).id,stridesBytes=new Uint8Array(new Int32Array(strides).buffer),outId=backend.dataIdMap.get(out.dataId).id;return wasmTensorScatterUpdate(indicesId,updatesId,CppDType[updates.dtype],sliceRank,numUpdates,sliceSize,stridesBytes,outputSize,outId,tensorId),out}};let wasmTile;const tileConfig={kernelName:dist.FAs,backendName:"wasm",setupFunc:function Tile_setup(backend){wasmTile=backend.wasm.cwrap(dist.FAs,null,["number","array","number","array","number","number"])},kernelFunc:function tile(args){const{inputs,backend,attrs}=args,{x}=inputs,xId=backend.dataIdMap.get(x.dataId).id,{reps}=attrs,newShape=new Array(x.shape.length);for(let i=0;i<newShape.length;i++)newShape[i]=x.shape[i]*reps[i];const xShapeBytes=new Uint8Array(new Int32Array(x.shape).buffer),newShapeBytes=new Uint8Array(new Int32Array(newShape).buffer),out=backend.makeOutput(newShape,x.dtype),outId=backend.dataIdMap.get(out.dataId).id;return wasmTile(xId,xShapeBytes,x.shape.length,newShapeBytes,newShape.length,CppDType[out.dtype],outId),out}};let wasmTopK;const topKConfig={kernelName:dist.TBb,backendName:"wasm",setupFunc:function TopK_setup(backend){wasmTopK=backend.wasm.cwrap(dist.TBb,null,["number","array","number","number","number","bool","number","number"])},kernelFunc:({inputs,backend,attrs})=>{const{x}=inputs,{k,sorted}=attrs,xId=backend.dataIdMap.get(x.dataId).id,xShapeBytes=new Uint8Array(new Int32Array(x.shape).buffer),outputShape=x.shape.slice();outputShape[outputShape.length-1]=k;const outValues=backend.makeOutput(outputShape,x.dtype),outValuesId=backend.dataIdMap.get(outValues.dataId).id,outIndices=backend.makeOutput(outputShape,"int32"),outIndicesId=backend.dataIdMap.get(outIndices.dataId).id;return wasmTopK(xId,xShapeBytes,x.shape.length,CppDType[x.dtype],k,sorted,outValuesId,outIndicesId),[outValues,outIndices]}};let wasmTransform;const transformConfig={kernelName:dist.dLy,backendName:"wasm",setupFunc:function Transform_setup(backend){wasmTransform=backend.wasm.cwrap(dist.dLy,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])},kernelFunc:function transform(args){const{backend,inputs,attrs}=args,{image,transforms}=inputs,{interpolation,fillMode,fillValue,outputShape}=attrs,[batch,imageHeight,imageWidth,numChannels]=image.shape,[outHeight,outWidth]=null!=outputShape?outputShape:[imageHeight,imageWidth],outShape=[batch,outHeight,outWidth,numChannels],inputStrides=new Uint8Array(new Int32Array(dist.ZSL.computeStrides(image.shape)).buffer),outputStrides=new Uint8Array(new Int32Array(dist.ZSL.computeStrides(outShape)).buffer),out=backend.makeOutput(outShape,image.dtype),outId=backend.dataIdMap.get(out.dataId).id,imageId=backend.dataIdMap.get(image.dataId).id,transformsId=backend.dataIdMap.get(transforms.dataId).id,interpolationModeId="nearest"===interpolation?1:2;let fillModeId;switch(fillMode){case"constant":default:fillModeId=1;break;case"reflect":fillModeId=2;break;case"wrap":fillModeId=3;break;case"nearest":fillModeId=4}return wasmTransform(imageId,transformsId,transforms.shape[0]>1,batch,outHeight,outWidth,numChannels,imageWidth,imageHeight,inputStrides,image.shape.length-1,outputStrides,outShape.length-1,interpolationModeId,fillModeId,fillValue,outId),out}};var Unique_impl=__webpack_require__("./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Unique_impl.js");const uniqueConfig={kernelName:dist.EwU,backendName:"wasm",kernelFunc:function unique(args){const{inputs,attrs,backend}=args,{axis}=attrs,{x}=inputs,{outputValues,outputShape,indices}=(0,Unique_impl.w)(backend.readSync(x.dataId),axis,x.shape,x.dtype);return[backend.makeOutput(outputShape,x.dtype,void 0,outputValues),backend.makeOutput([indices.length],"int32",void 0,indices)]}};const unpackConfig={kernelName:dist.dXR,backendName:"wasm",kernelFunc:function unpack(args){const{inputs,backend,attrs}=args,{value}=inputs;let{axis}=attrs;axis<0&&(axis+=value.shape.length);const numOutputs=value.shape[axis],rank=value.shape.length,outShape=new Array(rank-1);let outIndex=0;for(let i=0;i<rank;i++)i!==axis&&(outShape[outIndex++]=value.shape[i]);const outs=new Array(numOutputs),begin=new Array(rank).fill(0),size=value.shape.slice();size[axis]=1;for(let i=0;i<outs.length;i++)begin[axis]=i,outs[i]=slice({inputs:{x:value},attrs:{begin,size},backend});return outs.map(({dataId,dtype})=>({dataId,dtype,shape:outShape}))}};const zerosLikeConfig={kernelName:dist.xJ3,backendName:"wasm",kernelFunc:function zerosLike(args){const{inputs:{x},backend}=args,out=backend.makeOutput(x.shape,x.dtype);return backend.typedArrayFromHeap(out).fill(0),out}},kernelConfigs=[_fusedMatMulConfig,absConfig,acosConfig,acoshConfig,addConfig,addNConfig,allConfig,anyConfig,argMaxConfig,argMinConfig,asinConfig,asinhConfig,atanConfig,atan2Config,atanhConfig,avgPoolConfig,avgPoolGradConfig,avgPool3DConfig,avgPool3DGradConfig,batchMatMulConfig,batchToSpaceNDConfig,bincountConfig,bitwiseAndConfig,broadcastArgsConfig,castConfig,ceilConfig,clipByValueConfig,concatConfig,conv2DConfig,conv2DBackpropInputConfig,conv3DConfig,conv3DBackpropFilterV2Config,conv3DBackpropInputV2Config,cosConfig,coshConfig,cropAndResizeConfig,cumprodConfig,cumsumConfig,denseBincountConfig,depthToSpaceConfig,depthwiseConv2dNativeConfig,diagConfig,dilation2DConfig,dilation2DBackpropFilterConfig,dilation2DBackpropInputConfig,eluConfig,eluGradConfig,equalConfig,erfConfig,expConfig,expandDimsConfig,expm1Config,fillConfig,flipLeftRightConfig,floorConfig,floorDivConfig,fusedBatchNormConfig,fusedConv2DConfig,fusedDepthwiseConv2DConfig,gatherNdConfig,gatherV2Config,greaterConfig,greaterEqualConfig,identityConfig,isFiniteConfig,isInfConfig,isNaNConfig,leakyReluConfig,lessConfig,lessEqualConfig,linSpaceConfig,log1pConfig,logConfig,logicalAndConfig,logicalNotConfig,logicalOrConfig,logicalXorConfig,lrnConfig,lrnGradConfig,maxConfig,maximumConfig,maxPoolConfig,maxPool3DConfig,maxPool3DGradConfig,maxPoolGradConfig,maxPoolWithArgmaxConfig,meanConfig,minConfig,minimumConfig,mirrorPadConfig,multinomialConfig,modConfig,multiplyConfig,negConfig,nonMaxSuppressionV3Config,nonMaxSuppressionV4Config,nonMaxSuppressionV5Config,notEqualConfig,oneHotConfig,onesLikeConfig,packConfig,padV2Config,powConfig,preluConfig,prodConfig,rangeConfig,realDivConfig,reciprocalConfig,reluConfig,relu6Config,reshapeConfig,resizeBilinearConfig,resizeBilinearGradConfig,resizeNearestNeighborConfig,resizeNearestNeighborGradConfig,reverseConfig,rotateWithOffsetConfig,roundConfig,rsqrtConfig,scatterNdConfig,searchSortedConfig,selectConfig,seluConfig,sigmoidConfig,signConfig,sinConfig,sinhConfig,sliceConfig,softmaxConfig,softplusConfig,spaceToBatchNDConfig,sparseFillEmptyRowsConfig,sparseReshapeConfig,sparseSegmentMeanConfig,sparseSegmentSumConfig,sparseToDenseConfig,splitVConfig,sqrtConfig,squareConfig,squaredDifferenceConfig,stepConfig,stridedSliceConfig,stringNGramsConfig,stringSplitConfig,stringToHashBucketFastConfig,subConfig,sumConfig,tanConfig,tanhConfig,tensorScatterUpdateConfig,tileConfig,topKConfig,transformConfig,transposeConfig,uniqueConfig,unpackConfig,zerosLikeConfig];for(const kernelConfig of kernelConfigs)(0,dist.tAK)(kernelConfig);const ENV=(0,dist._K2)();ENV.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch(e){return!1}}),ENV.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(ENV.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(e){return!1}});var tfjs_backend_wasm_threaded_simd=__webpack_require__("./node_modules/@tensorflow/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm-threaded-simd.js"),tfjs_backend_wasm_threaded_simd_default=__webpack_require__.n(tfjs_backend_wasm_threaded_simd),tfjs_backend_wasm_threaded_simd_worker=__webpack_require__("./node_modules/@tensorflow/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm-threaded-simd.worker.js"),tfjs_backend_wasm=__webpack_require__("./node_modules/@tensorflow/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm.js"),tfjs_backend_wasm_default=__webpack_require__.n(tfjs_backend_wasm);const wasmFactoryThreadedSimd=tfjs_backend_wasm_threaded_simd_default()||tfjs_backend_wasm_threaded_simd,wasmFactory=tfjs_backend_wasm_default()||tfjs_backend_wasm;class BackendWasm extends dist.uI_{constructor(wasm){super(),this.wasm=wasm,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(threadsCount),actualThreadsCount=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new dist.GJx(this,(0,dist.Hi9)())}write(values,shape,dtype){const dataId={id:this.dataIdNextNumber++};return this.move(dataId,values,shape,dtype,1),dataId}numDataIds(){return this.dataIdMap.numDataIds()}async time(f){const start=dist.ZSL.now();f();return{kernelMs:dist.ZSL.now()-start}}move(dataId,values,shape,dtype,refCount){const id=this.dataIdNextNumber++;if("string"===dtype){const stringBytes=values;return void this.dataIdMap.set(dataId,{id,stringBytes,shape,dtype,memoryOffset:null,refCount})}const size=dist.ZSL.sizeFromShape(shape),numBytes=size*dist.ZSL.bytesPerElement(dtype),memoryOffset=this.wasm._malloc(numBytes)>>>0;this.dataIdMap.set(dataId,{id,memoryOffset,shape,dtype,refCount}),this.wasm.tfjs.registerTensor(id,size,memoryOffset),null!=values&&this.wasm.HEAPU8.set(new Uint8Array(values.buffer,values.byteOffset,numBytes),memoryOffset)}async read(dataId){return this.readSync(dataId)}readSync(dataId,start,end){const{memoryOffset,dtype,shape,stringBytes}=this.dataIdMap.get(dataId);if("string"===dtype)return null!=start&&0!==start||!(null==end||end>=stringBytes.length)?stringBytes.slice(start,end):stringBytes;start=start||0,end=end||dist.ZSL.sizeFromShape(shape);const bytesPerElement=dist.ZSL.bytesPerElement(dtype);return function typedArrayFromBuffer(buffer,dtype){switch(dtype){case"float32":return new Float32Array(buffer);case"int32":return new Int32Array(buffer);case"bool":return new Uint8Array(buffer);default:throw new Error(`Unknown dtype ${dtype}`)}}(this.wasm.HEAPU8.slice(memoryOffset+start*bytesPerElement,memoryOffset+end*bytesPerElement).buffer,dtype)}disposeData(dataId,force=!1){if(this.dataIdMap.has(dataId)){const data=this.dataIdMap.get(dataId);if(data.refCount--,!force&&data.refCount>0)return!1;this.wasm._free(data.memoryOffset),this.wasm.tfjs.disposeData(data.id),this.dataIdMap.delete(dataId)}return!0}refCount(dataId){if(this.dataIdMap.has(dataId)){return this.dataIdMap.get(dataId).refCount}return 0}incRef(dataId){const data=this.dataIdMap.get(dataId);null!=data&&data.refCount++}floatPrecision(){return 32}getMemoryOffset(dataId){return this.dataIdMap.get(dataId).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(shape,dtype,memoryOffset,values){let dataId;if(null==memoryOffset)dataId=this.write(null!=values?values:null,shape,dtype);else{const id=this.dataIdNextNumber++;dataId={id},this.dataIdMap.set(dataId,{id,memoryOffset,shape,dtype,refCount:1});const size=dist.ZSL.sizeFromShape(shape);this.wasm.tfjs.registerTensor(id,size,memoryOffset)}return{dataId,shape,dtype}}typedArrayFromHeap({shape,dtype,dataId}){const buffer=this.wasm.HEAPU8.buffer,{memoryOffset}=this.dataIdMap.get(dataId),size=dist.ZSL.sizeFromShape(shape);switch(dtype){case"float32":return new Float32Array(buffer,memoryOffset,size);case"int32":return new Int32Array(buffer,memoryOffset,size);case"bool":return new Uint8Array(buffer,memoryOffset,size);default:throw new Error(`Unknown dtype ${dtype}`)}}}function getPathToWasmBinary(simdSupported,threadsSupported,wasmModuleFolder){if(null!=wasmPath)return wasmPath;let path="tfjs-backend-wasm.wasm";return simdSupported&&threadsSupported?path="tfjs-backend-wasm-threaded-simd.wasm":simdSupported&&(path="tfjs-backend-wasm-simd.wasm"),null!=wasmFileMap&&null!=wasmFileMap[path]?wasmFileMap[path]:wasmModuleFolder+path}async function init(){const[simdSupported,threadsSupported]=await Promise.all([(0,dist._K2)().getAsync("WASM_HAS_SIMD_SUPPORT"),(0,dist._K2)().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((resolve,reject)=>{const factoryConfig={locateFile:(path,prefix)=>{if(path.endsWith(".worker.js")){const response=tfjs_backend_wasm_threaded_simd_worker.$.replace(/\n/g,"\\n"),blob=new Blob([response],{type:"application/javascript"});return URL.createObjectURL(blob)}return path.endsWith(".wasm")?getPathToWasmBinary(simdSupported,threadsSupported,null!=wasmPathPrefix?wasmPathPrefix:prefix):prefix+path}};customFetch&&(factoryConfig.instantiateWasm=function createInstantiateWasmFunc(path){return(imports,callback)=>(dist.ZSL.fetch(path,{credentials:"same-origin"}).then(response=>{response.ok||imports.env.a(`failed to load wasm binary file at '${path}'`),response.arrayBuffer().then(binary=>{WebAssembly.instantiate(binary,imports).then(output=>{callback(output.instance,output.module)})})}),{})}(getPathToWasmBinary(simdSupported,threadsSupported,null!=wasmPathPrefix?wasmPathPrefix:"")));let wasm,initialized=!1;factoryConfig.onAbort=()=>{if(initialized)return;if(initAborted)return;initAborted=!0;reject({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})},threadsSupported&&simdSupported&&null==wasmPath?(factoryConfig.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+wasmFactoryThreadedSimd.toString()],{type:"text/javascript"}),wasm=wasmFactoryThreadedSimd(factoryConfig)):wasm=wasmFactory(factoryConfig),wasm.then(module=>{initialized=!0,initAborted=!1;module.tfjs={init:module.cwrap("init",null,[]),initWithThreadsCount:module.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:module.cwrap("get_threads_count","number",[]),registerTensor:module.cwrap("register_tensor",null,["number","number","number"]),disposeData:module.cwrap("dispose_data",null,["number"]),dispose:module.cwrap("dispose",null,[])},resolve({wasm:module})}).catch(reject)})}const wasmBinaryNames=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"];let wasmPath=null,wasmPathPrefix=null,wasmFileMap={},initAborted=!1,customFetch=!1;function setWasmPath(path,usePlatformFetch=!1){if((0,dist.fLc)("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),initAborted)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");wasmPath=path,customFetch=usePlatformFetch}function setWasmPaths(prefixOrFileMap,usePlatformFetch=!1){if(initAborted)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof prefixOrFileMap)wasmPathPrefix=prefixOrFileMap;else{wasmFileMap=prefixOrFileMap;const missingPaths=wasmBinaryNames.filter(name=>null==wasmFileMap[name]);if(missingPaths.length>0)throw new Error(`There were no entries found for the following binaries: ${missingPaths.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}customFetch=usePlatformFetch}let threadsCount=-1,actualThreadsCount=-1;function setThreadsCount(numThreads){threadsCount=numThreads}function getThreadsCount(){if(-1===actualThreadsCount)throw new Error("WASM backend not initialized.");return actualThreadsCount}const version="4.22.0";(0,dist.gJX)("wasm",async()=>{const{wasm}=await init();return new BackendWasm(wasm)},2)},"./node_modules/@tensorflow/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm-threaded-simd.js":(module,__unused_webpack_exports,__webpack_require__)=>{var _scriptDir,process=__webpack_require__("./node_modules/process/browser.js"),console=__webpack_require__("./node_modules/console-browserify/index.js"),WasmBackendModuleThreadedSimd=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(WasmBackendModuleThreadedSimd){function GROWABLE_HEAP_I8(){return wasmMemory.buffer!=buffer&&updateGlobalBufferAndViews(wasmMemory.buffer),HEAP8}function GROWABLE_HEAP_U8(){return wasmMemory.buffer!=buffer&&updateGlobalBufferAndViews(wasmMemory.buffer),HEAPU8}function GROWABLE_HEAP_I32(){return wasmMemory.buffer!=buffer&&updateGlobalBufferAndViews(wasmMemory.buffer),HEAP32}function GROWABLE_HEAP_U32(){return wasmMemory.buffer!=buffer&&updateGlobalBufferAndViews(wasmMemory.buffer),HEAPU32}function GROWABLE_HEAP_F64(){return wasmMemory.buffer!=buffer&&updateGlobalBufferAndViews(wasmMemory.buffer),HEAPF64}var readyPromiseResolve,readyPromiseReject,beforeListeners,Module=void 0!==(WasmBackendModuleThreadedSimd=WasmBackendModuleThreadedSimd||{})?WasmBackendModuleThreadedSimd:{};Module.ready=new Promise(function(resolve,reject){readyPromiseResolve=resolve,readyPromiseReject=reject}),void 0!==process&&process.listeners&&(beforeListeners={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var read_,readAsync,readBinary,moduleOverrides=Object.assign({},Module),arguments_=[],quit_=(status,toThrow)=>{throw toThrow},ENVIRONMENT_IS_WEB="object"==typeof window,ENVIRONMENT_IS_WORKER="function"==typeof importScripts,ENVIRONMENT_IS_NODE="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,ENVIRONMENT_IS_PTHREAD=Module.ENVIRONMENT_IS_PTHREAD||!1,scriptDirectory="";function locateFile(path){return Module.locateFile?Module.locateFile(path,scriptDirectory):scriptDirectory+path}if(ENVIRONMENT_IS_NODE){var fs=__webpack_require__("?ee47"),nodePath=__webpack_require__("?633a");let nodeWorkerThreads;scriptDirectory=ENVIRONMENT_IS_WORKER?nodePath.dirname(scriptDirectory)+"/":"//",read_=(filename,binary)=>(filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename),fs.readFileSync(filename,binary?void 0:"utf8")),readBinary=filename=>{var ret=read_(filename,!0);return ret.buffer||(ret=new Uint8Array(ret)),ret},readAsync=(filename,onload,onerror)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename),fs.readFile(filename,function(err,data){err?onerror(err):onload(data.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),arguments_=process.argv.slice(2),process.on("uncaughtException",function(ex){if(!(ex instanceof ExitStatus))throw ex}),process.on("unhandledRejection",function(reason){throw reason}),quit_=(status,toThrow)=>{if(keepRuntimeAlive())throw process.exitCode=status,toThrow;!function logExceptionOnExit(e){e instanceof ExitStatus||err("exiting due to exception: "+e)}(toThrow),process.exit(status)},Module.inspect=function(){return"[Emscripten Module object]"};try{nodeWorkerThreads=__webpack_require__("?6cf7")}catch(e){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),e}__webpack_require__.g.Worker=nodeWorkerThreads.Worker}else(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)&&(ENVIRONMENT_IS_WORKER?scriptDirectory=self.location.href:"undefined"!=typeof document&&document.currentScript&&(scriptDirectory=document.currentScript.src),void 0!==_scriptDir&&_scriptDir&&(scriptDirectory=_scriptDir),scriptDirectory=0!==scriptDirectory.indexOf("blob:")?scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1):"",ENVIRONMENT_IS_NODE||(read_=url=>{var xhr=new XMLHttpRequest;return xhr.open("GET",url,!1),xhr.send(null),xhr.responseText},ENVIRONMENT_IS_WORKER&&(readBinary=url=>{var xhr=new XMLHttpRequest;return xhr.open("GET",url,!1),xhr.responseType="arraybuffer",xhr.send(null),new Uint8Array(xhr.response)}),readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,!0),xhr.responseType="arraybuffer",xhr.onload=()=>{200==xhr.status||0==xhr.status&&xhr.response?onload(xhr.response):onerror()},xhr.onerror=onerror,xhr.send(null)}));ENVIRONMENT_IS_NODE&&"undefined"==typeof performance&&(__webpack_require__.g.performance=__webpack_require__("?cedb").performance);var defaultPrint=console.log.bind(console),defaultPrintErr=console.warn.bind(console);ENVIRONMENT_IS_NODE&&(defaultPrint=str=>fs.writeSync(1,str+"\n"),defaultPrintErr=str=>fs.writeSync(2,str+"\n"));var wasmBinary,out=Module.print||defaultPrint,err=Module.printErr||defaultPrintErr;Object.assign(Module,moduleOverrides),moduleOverrides=null,Module.arguments&&(arguments_=Module.arguments),Module.thisProgram&&Module.thisProgram,Module.quit&&(quit_=Module.quit),Atomics.load,Atomics.store,Atomics.compareExchange,Module.wasmBinary&&(wasmBinary=Module.wasmBinary);var wasmMemory,wasmModule,noExitRuntime=Module.noExitRuntime||!0;"object"!=typeof WebAssembly&&abort("no native wasm support detected");var EXITSTATUS,buffer,HEAP8,HEAPU8,HEAP32,HEAPU32,HEAPF64,ABORT=!1,UTF8Decoder="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function UTF8ArrayToString(heapOrArray,idx,maxBytesToRead){for(var endIdx=(idx>>>=0)+maxBytesToRead,endPtr=idx;heapOrArray[endPtr]&&!(endPtr>=endIdx);)++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder)return UTF8Decoder.decode(heapOrArray.buffer instanceof SharedArrayBuffer?heapOrArray.slice(idx,endPtr):heapOrArray.subarray(idx,endPtr));for(var str="";idx<endPtr;){var u0=heapOrArray[idx++];if(128&u0){var u1=63&heapOrArray[idx++];if(192!=(224&u0)){var u2=63&heapOrArray[idx++];if((u0=224==(240&u0)?(15&u0)<<12|u1<<6|u2:(7&u0)<<18|u1<<12|u2<<6|63&heapOrArray[idx++])<65536)str+=String.fromCharCode(u0);else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|1023&ch)}}else str+=String.fromCharCode((31&u0)<<6|u1)}else str+=String.fromCharCode(u0)}return str}function UTF8ToString(ptr,maxBytesToRead){return(ptr>>>=0)?UTF8ArrayToString(GROWABLE_HEAP_U8(),ptr,maxBytesToRead):""}function updateGlobalBufferAndViews(buf){buffer=buf,Module.HEAP8=HEAP8=new Int8Array(buf),Module.HEAP16=new Int16Array(buf),Module.HEAP32=HEAP32=new Int32Array(buf),Module.HEAPU8=HEAPU8=new Uint8Array(buf),Module.HEAPU16=new Uint16Array(buf),Module.HEAPU32=HEAPU32=new Uint32Array(buf),Module.HEAPF32=new Float32Array(buf),Module.HEAPF64=HEAPF64=new Float64Array(buf)}ENVIRONMENT_IS_PTHREAD&&(buffer=Module.buffer);var wasmTable,INITIAL_MEMORY=Module.INITIAL_MEMORY||16777216;if(ENVIRONMENT_IS_PTHREAD)wasmMemory=Module.wasmMemory,buffer=Module.buffer;else if(Module.wasmMemory)wasmMemory=Module.wasmMemory;else if(!((wasmMemory=new WebAssembly.Memory({initial:INITIAL_MEMORY/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw err("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),ENVIRONMENT_IS_NODE&&err("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");wasmMemory&&(buffer=wasmMemory.buffer),INITIAL_MEMORY=buffer.byteLength,updateGlobalBufferAndViews(buffer);var __ATPRERUN__=[],__ATINIT__=[],__ATPOSTRUN__=[];function keepRuntimeAlive(){return noExitRuntime}function initRuntime(){ENVIRONMENT_IS_PTHREAD||callRuntimeCallbacks(__ATINIT__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var wasmBinaryFile,runDependencies=0,runDependencyWatcher=null,dependenciesFulfilled=null;function abort(what){Module.onAbort&&Module.onAbort(what),err(what="Aborted("+what+")"),ABORT=!0,EXITSTATUS=1,what+=". Build with -sASSERTIONS for more info.";var e=new WebAssembly.RuntimeError(what);throw readyPromiseReject(e),e}function isDataURI(filename){return filename.startsWith("data:application/octet-stream;base64,")}function isFileURI(filename){return filename.startsWith("file://")}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary)return new Uint8Array(wasmBinary);if(readBinary)return readBinary(file);throw"both async and sync fetching of the wasm failed"}catch(err){abort(err)}}isDataURI(wasmBinaryFile="tfjs-backend-wasm-threaded-simd.wasm")||(wasmBinaryFile=locateFile(wasmBinaryFile));var ASM_CONSTS={};function ExitStatus(status){this.name="ExitStatus",this.message="Program terminated with exit("+status+")",this.status=status}function cleanupThread(pthread_ptr){var worker=PThread.pthreads[pthread_ptr];!function assert(condition,text){condition||abort(text)}(worker),PThread.returnWorkerToPool(worker)}function spawnThread(threadParams){var worker=PThread.getNewWorker();if(!worker)return 6;PThread.runningWorkers.push(worker),PThread.pthreads[threadParams.pthread_ptr]=worker,worker.pthread_ptr=threadParams.pthread_ptr;var msg={cmd:"run",start_routine:threadParams.startRoutine,arg:threadParams.arg,pthread_ptr:threadParams.pthread_ptr};return worker.runPthread=()=>{ENVIRONMENT_IS_NODE&&worker.ref(),worker.postMessage(msg,threadParams.transferList),delete worker.runPthread},worker.loaded&&worker.runPthread(),0}function _proc_exit(code){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(1,1,code);EXITSTATUS=code,keepRuntimeAlive()||(PThread.terminateAllThreads(),Module.onExit&&Module.onExit(code),ABORT=!0),quit_(code,new ExitStatus(code))}var _exit=function exitJS(status,implicit){if(EXITSTATUS=status,!implicit&&ENVIRONMENT_IS_PTHREAD)throw exitOnMainThread(status),"unwind";_proc_exit(status)},PThread={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){ENVIRONMENT_IS_PTHREAD?PThread.initWorker():PThread.initMainThread()},initMainThread:function(){for(var pthreadPoolSize=8;pthreadPoolSize--;)PThread.allocateUnusedWorker()},initWorker:function(){noExitRuntime=!1},setExitStatus:function(status){EXITSTATUS=status},terminateAllThreads:function(){for(var worker of Object.values(PThread.pthreads))PThread.returnWorkerToPool(worker);for(var worker of PThread.unusedWorkers)worker.terminate();PThread.unusedWorkers=[]},returnWorkerToPool:function(worker){var pthread_ptr=worker.pthread_ptr;delete PThread.pthreads[pthread_ptr],PThread.unusedWorkers.push(worker),PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker),1),worker.pthread_ptr=0,ENVIRONMENT_IS_NODE&&worker.unref(),__emscripten_thread_free_data(pthread_ptr)},receiveObjectTransfer:function(data){},threadInitTLS:function(){PThread.tlsInitFunctions.forEach(f=>f())},loadWasmModuleToWorker:function(worker,onFinishedLoading){worker.onmessage=e=>{var d=e.data,cmd=d.cmd;if(worker.pthread_ptr&&(PThread.currentProxiedOperationCallerThread=worker.pthread_ptr),d.targetThread&&d.targetThread!=_pthread_self()){var targetWorker=PThread.pthreads[d.targetThread];return targetWorker?targetWorker.postMessage(d,d.transferList):err('Internal error! Worker sent a message "'+cmd+'" to target pthread '+d.targetThread+", but that thread no longer exists!"),void(PThread.currentProxiedOperationCallerThread=void 0)}"processProxyingQueue"===cmd?executeNotifiedProxyingQueue(d.queue):"spawnThread"===cmd?spawnThread(d):"cleanupThread"===cmd?cleanupThread(d.thread):"killThread"===cmd?function killThread(pthread_ptr){var worker=PThread.pthreads[pthread_ptr];delete PThread.pthreads[pthread_ptr],worker.terminate(),__emscripten_thread_free_data(pthread_ptr),PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker),1),worker.pthread_ptr=0}(d.thread):"cancelThread"===cmd?function cancelThread(pthread_ptr){PThread.pthreads[pthread_ptr].postMessage({cmd:"cancel"})}(d.thread):"loaded"===cmd?(worker.loaded=!0,ENVIRONMENT_IS_NODE&&worker.unref(),onFinishedLoading&&onFinishedLoading(worker),worker.runPthread&&worker.runPthread()):"print"===cmd?out("Thread "+d.threadId+": "+d.text):"printErr"===cmd?err("Thread "+d.threadId+": "+d.text):"alert"===cmd?alert("Thread "+d.threadId+": "+d.text):"setimmediate"===d.target?worker.postMessage(d):"callHandler"===cmd?Module[d.handler](...d.args):cmd&&err("worker sent an unknown command "+cmd),PThread.currentProxiedOperationCallerThread=void 0},worker.onerror=e=>{throw err("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},ENVIRONMENT_IS_NODE&&(worker.on("message",function(data){worker.onmessage({data})}),worker.on("error",function(e){worker.onerror(e)}),worker.on("detachedExit",function(){}));var handlers=[];for(var handler of["onExit","onAbort","print","printErr"])Module.hasOwnProperty(handler)&&handlers.push(handler);worker.postMessage({cmd:"load",handlers,urlOrBlob:Module.mainScriptUrlOrBlob||_scriptDir,wasmMemory,wasmModule})},allocateUnusedWorker:function(){var worker,pthreadMainJs=locateFile("tfjs-backend-wasm-threaded-simd.worker.js");worker=new Worker(pthreadMainJs),PThread.unusedWorkers.push(worker)},getNewWorker:function(){return 0==PThread.unusedWorkers.length&&(PThread.allocateUnusedWorker(),PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0])),PThread.unusedWorkers.pop()}};function callRuntimeCallbacks(callbacks){for(;callbacks.length>0;)callbacks.shift()(Module)}function exitOnMainThread(returnCode){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(2,0,returnCode);try{_exit(returnCode)}catch(e){!function handleException(e){if(e instanceof ExitStatus||"unwind"==e)return EXITSTATUS;quit_(1,e)}(e)}}Module.PThread=PThread,Module.establishStackSpace=function establishStackSpace(){var pthread_ptr=_pthread_self(),stackTop=GROWABLE_HEAP_I32()[pthread_ptr+52>>>2],stackSize=GROWABLE_HEAP_I32()[pthread_ptr+56>>>2];_emscripten_stack_set_limits(stackTop,stackTop-stackSize),stackRestore(stackTop)};var _emscripten_get_now,wasmTableMirror=[];function pthreadCreateProxied(pthread_ptr,attr,startRoutine,arg){return ENVIRONMENT_IS_PTHREAD?_emscripten_proxy_to_main_thread_js(3,1,pthread_ptr,attr,startRoutine,arg):___pthread_create_js(pthread_ptr,attr,startRoutine,arg)}function ___pthread_create_js(pthread_ptr,attr,startRoutine,arg){if("undefined"==typeof SharedArrayBuffer)return err("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var transferList=[];if(ENVIRONMENT_IS_PTHREAD&&0===transferList.length)return pthreadCreateProxied(pthread_ptr,attr,startRoutine,arg);var threadParams={startRoutine,pthread_ptr,arg,transferList};return ENVIRONMENT_IS_PTHREAD?(threadParams.cmd="spawnThread",postMessage(threadParams,transferList),0):spawnThread(threadParams)}function executeNotifiedProxyingQueue(queue){Atomics.store(GROWABLE_HEAP_I32(),queue>>2,1),_pthread_self()&&__emscripten_proxy_execute_task_queue(queue),Atomics.compareExchange(GROWABLE_HEAP_I32(),queue>>2,1,0)}function warnOnce(text){warnOnce.shown||(warnOnce.shown={}),warnOnce.shown[text]||(warnOnce.shown[text]=1,ENVIRONMENT_IS_NODE&&(text="warning: "+text),err(text))}function _emscripten_proxy_to_main_thread_js(index,sync){var numCallArgs=arguments.length-2,outerArgs=arguments;return function withStackSave(f){var stack=stackSave(),ret=f();return stackRestore(stack),ret}(()=>{for(var serializedNumCallArgs=numCallArgs,args=stackAlloc(8*serializedNumCallArgs),b=args>>3,i=0;i<numCallArgs;i++){var arg=outerArgs[2+i];GROWABLE_HEAP_F64()[b+i>>>0]=arg}return _emscripten_run_in_main_runtime_thread_js(index,serializedNumCallArgs,args,sync)})}Module.invokeEntryPoint=function invokeEntryPoint(ptr,arg){var result=function getWasmTableEntry(funcPtr){var func=wasmTableMirror[funcPtr];return func||(funcPtr>=wasmTableMirror.length&&(wasmTableMirror.length=funcPtr+1),wasmTableMirror[funcPtr]=func=wasmTable.get(funcPtr)),func}(ptr)(arg);keepRuntimeAlive()?PThread.setExitStatus(result):__emscripten_thread_exit(result)},Module.executeNotifiedProxyingQueue=executeNotifiedProxyingQueue,_emscripten_get_now=ENVIRONMENT_IS_NODE?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.timeOrigin+performance.now();var _emscripten_receive_on_main_thread_js_callArgs=[];function emscripten_realloc_buffer(size){try{return wasmMemory.grow(size-buffer.byteLength+65535>>>16),updateGlobalBufferAndViews(wasmMemory.buffer),1}catch(e){}}function _fd_close(fd){return ENVIRONMENT_IS_PTHREAD?_emscripten_proxy_to_main_thread_js(4,1,fd):52}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){return ENVIRONMENT_IS_PTHREAD?_emscripten_proxy_to_main_thread_js(5,1,fd,offset_low,offset_high,whence,newOffset):70}var printCharBuffers=[null,[],[]];function printChar(stream,curr){var buffer=printCharBuffers[stream];0===curr||10===curr?((1===stream?out:err)(UTF8ArrayToString(buffer,0)),buffer.length=0):buffer.push(curr)}function _fd_write(fd,iov,iovcnt,pnum){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(6,1,fd,iov,iovcnt,pnum);for(var num=0,i=0;i<iovcnt;i++){var ptr=GROWABLE_HEAP_U32()[iov>>>2],len=GROWABLE_HEAP_U32()[iov+4>>>2];iov+=8;for(var j=0;j<len;j++)printChar(fd,GROWABLE_HEAP_U8()[ptr+j>>>0]);num+=len}return GROWABLE_HEAP_U32()[pnum>>>2]=num,0}function getCFunc(ident){return Module["_"+ident]}function ccall(ident,returnType,argTypes,args,opts){var toC={string:str=>{var ret=0;if(null!=str&&0!==str){var len=1+(str.length<<2);!function stringToUTF8(str,outPtr,maxBytesToWrite){return function stringToUTF8Array(str,heap,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;for(var startIdx=outIdx>>>=0,endIdx=outIdx+maxBytesToWrite-1,i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343&&(u=65536+((1023&u)<<10)|1023&str.charCodeAt(++i)),u<=127){if(outIdx>=endIdx)break;heap[outIdx++>>>0]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++>>>0]=192|u>>6,heap[outIdx++>>>0]=128|63&u}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++>>>0]=224|u>>12,heap[outIdx++>>>0]=128|u>>6&63,heap[outIdx++>>>0]=128|63&u}else{if(outIdx+3>=endIdx)break;heap[outIdx++>>>0]=240|u>>18,heap[outIdx++>>>0]=128|u>>12&63,heap[outIdx++>>>0]=128|u>>6&63,heap[outIdx++>>>0]=128|63&u}}return heap[outIdx>>>0]=0,outIdx-startIdx}(str,GROWABLE_HEAP_U8(),outPtr,maxBytesToWrite)}(str,ret=stackAlloc(len),len)}return ret},array:arr=>{var ret=stackAlloc(arr.length);return function writeArrayToMemory(array,buffer){GROWABLE_HEAP_I8().set(array,buffer>>>0)}(arr,ret),ret}},func=getCFunc(ident),cArgs=[],stack=0;if(args)for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];converter?(0===stack&&(stack=stackSave()),cArgs[i]=converter(args[i])):cArgs[i]=args[i]}var ret=func.apply(null,cArgs);return ret=function onDone(ret){return 0!==stack&&stackRestore(stack),function convertReturnValue(ret){return"string"===returnType?UTF8ToString(ret):"boolean"===returnType?Boolean(ret):ret}(ret)}(ret)}PThread.init();var calledRun,listenersAdded,actualModule,proxiedFunctionTable=[null,_proc_exit,exitOnMainThread,pthreadCreateProxied,_fd_close,_fd_seek,_fd_write],asmLibraryArg={__emscripten_init_main_thread_js:function ___emscripten_init_main_thread_js(tb){__emscripten_thread_init(tb,!ENVIRONMENT_IS_WORKER,1,!ENVIRONMENT_IS_WEB),PThread.threadInitTLS()},__emscripten_thread_cleanup:function ___emscripten_thread_cleanup(thread){ENVIRONMENT_IS_PTHREAD?postMessage({cmd:"cleanupThread",thread}):cleanupThread(thread)},__pthread_create_js:___pthread_create_js,_emscripten_default_pthread_stack_size:function __emscripten_default_pthread_stack_size(){return 65536},_emscripten_get_now_is_monotonic:function __emscripten_get_now_is_monotonic(){return!0},_emscripten_notify_task_queue:function __emscripten_notify_task_queue(targetThreadId,currThreadId,mainThreadId,queue){if(targetThreadId==currThreadId)setTimeout(()=>executeNotifiedProxyingQueue(queue));else if(ENVIRONMENT_IS_PTHREAD)postMessage({targetThread:targetThreadId,cmd:"processProxyingQueue",queue});else{var worker=PThread.pthreads[targetThreadId];if(!worker)return;worker.postMessage({cmd:"processProxyingQueue",queue})}return 1},_emscripten_set_offscreencanvas_size:function __emscripten_set_offscreencanvas_size(target,width,height){return-1},abort:function _abort(){abort("")},emscripten_check_blocking_allowed:function _emscripten_check_blocking_allowed(){ENVIRONMENT_IS_NODE||ENVIRONMENT_IS_WORKER||warnOnce("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")},emscripten_date_now:function _emscripten_date_now(){return Date.now()},emscripten_get_heap_max:function _emscripten_get_heap_max(){return 4294901760},emscripten_get_now:_emscripten_get_now,emscripten_memcpy_big:function _emscripten_memcpy_big(dest,src,num){GROWABLE_HEAP_U8().copyWithin(dest>>>0,src>>>0,src+num>>>0)},emscripten_num_logical_cores:function _emscripten_num_logical_cores(){return ENVIRONMENT_IS_NODE?__webpack_require__("?cb39").cpus().length:navigator.hardwareConcurrency},emscripten_receive_on_main_thread_js:function _emscripten_receive_on_main_thread_js(index,numCallArgs,args){_emscripten_receive_on_main_thread_js_callArgs.length=numCallArgs;for(var b=args>>3,i=0;i<numCallArgs;i++)_emscripten_receive_on_main_thread_js_callArgs[i]=GROWABLE_HEAP_F64()[b+i>>>0];return(index<0?ASM_CONSTS[-index-1]:proxiedFunctionTable[index]).apply(null,_emscripten_receive_on_main_thread_js_callArgs)},emscripten_resize_heap:function _emscripten_resize_heap(requestedSize){var oldSize=GROWABLE_HEAP_U8().length;if((requestedSize>>>=0)<=oldSize)return!1;if(requestedSize>4294901760)return!1;let alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);if(overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296),emscripten_realloc_buffer(Math.min(4294901760,alignUp(Math.max(requestedSize,overGrownHeapSize),65536))))return!0}return!1},emscripten_unwind_to_js_event_loop:function _emscripten_unwind_to_js_event_loop(){throw"unwind"},exit:_exit,fd_close:_fd_close,fd_seek:_fd_seek,fd_write:_fd_write,memory:wasmMemory||Module.wasmMemory},_pthread_self=(function createWasm(){var info={env:asmLibraryArg,wasi_snapshot_preview1:asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;if(Module.asm=exports,function registerTLSInit(tlsInitFunc){PThread.tlsInitFunctions.push(tlsInitFunc)}(Module.asm._emscripten_tls_init),wasmTable=Module.asm.__indirect_function_table,function addOnInit(cb){__ATINIT__.unshift(cb)}(Module.asm.__wasm_call_ctors),wasmModule=module,!ENVIRONMENT_IS_PTHREAD){var numWorkersToLoad=PThread.unusedWorkers.length;PThread.unusedWorkers.forEach(function(w){PThread.loadWasmModuleToWorker(w,function(){--numWorkersToLoad||function removeRunDependency(id){if(runDependencies--,Module.monitorRunDependencies&&Module.monitorRunDependencies(runDependencies),0==runDependencies&&(null!==runDependencyWatcher&&(clearInterval(runDependencyWatcher),runDependencyWatcher=null),dependenciesFulfilled)){var callback=dependenciesFulfilled;dependenciesFulfilled=null,callback()}}()})})}}function receiveInstantiationResult(result){receiveInstance(result.instance,result.module)}function instantiateArrayBuffer(receiver){return function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if("function"==typeof fetch&&!isFileURI(wasmBinaryFile))return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response.ok)throw"failed to load wasm binary file at '"+wasmBinaryFile+"'";return response.arrayBuffer()}).catch(function(){return getBinary(wasmBinaryFile)});if(readAsync)return new Promise(function(resolve,reject){readAsync(wasmBinaryFile,function(response){resolve(new Uint8Array(response))},reject)})}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(function(instance){return instance}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason),abort(reason)})}if(ENVIRONMENT_IS_PTHREAD||function addRunDependency(id){runDependencies++,Module.monitorRunDependencies&&Module.monitorRunDependencies(runDependencies)}(),Module.instantiateWasm)try{return Module.instantiateWasm(info,receiveInstance)}catch(e){err("Module.instantiateWasm callback failed with error: "+e),readyPromiseReject(e)}return function instantiateAsync(){return wasmBinary||"function"!=typeof WebAssembly.instantiateStreaming||isDataURI(wasmBinaryFile)||isFileURI(wasmBinaryFile)||ENVIRONMENT_IS_NODE||"function"!=typeof fetch?instantiateArrayBuffer(receiveInstantiationResult):fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){return WebAssembly.instantiateStreaming(response,info).then(receiveInstantiationResult,function(reason){return err("wasm streaming compile failed: "+reason),err("falling back to ArrayBuffer instantiation"),instantiateArrayBuffer(receiveInstantiationResult)})})}().catch(readyPromiseReject),{}}(),Module.___wasm_call_ctors=function(){return(Module.___wasm_call_ctors=Module.asm.__wasm_call_ctors).apply(null,arguments)},Module._init=function(){return(Module._init=Module.asm.init).apply(null,arguments)},Module._init_with_threads_count=function(){return(Module._init_with_threads_count=Module.asm.init_with_threads_count).apply(null,arguments)},Module._get_threads_count=function(){return(Module._get_threads_count=Module.asm.get_threads_count).apply(null,arguments)},Module._register_tensor=function(){return(Module._register_tensor=Module.asm.register_tensor).apply(null,arguments)},Module._dispose_data=function(){return(Module._dispose_data=Module.asm.dispose_data).apply(null,arguments)},Module._dispose=function(){return(Module._dispose=Module.asm.dispose).apply(null,arguments)},Module._Abs=function(){return(Module._Abs=Module.asm.Abs).apply(null,arguments)},Module._Acos=function(){return(Module._Acos=Module.asm.Acos).apply(null,arguments)},Module._Acosh=function(){return(Module._Acosh=Module.asm.Acosh).apply(null,arguments)},Module._Add=function(){return(Module._Add=Module.asm.Add).apply(null,arguments)},Module._AddN=function(){return(Module._AddN=Module.asm.AddN).apply(null,arguments)},Module._All=function(){return(Module._All=Module.asm.All).apply(null,arguments)},Module._Any=function(){return(Module._Any=Module.asm.Any).apply(null,arguments)},Module._ArgMax=function(){return(Module._ArgMax=Module.asm.ArgMax).apply(null,arguments)},Module._ArgMin=function(){return(Module._ArgMin=Module.asm.ArgMin).apply(null,arguments)},Module._Asin=function(){return(Module._Asin=Module.asm.Asin).apply(null,arguments)},Module._Asinh=function(){return(Module._Asinh=Module.asm.Asinh).apply(null,arguments)},Module._Atan=function(){return(Module._Atan=Module.asm.Atan).apply(null,arguments)},Module._Atan2=function(){return(Module._Atan2=Module.asm.Atan2).apply(null,arguments)},Module._Atanh=function(){return(Module._Atanh=Module.asm.Atanh).apply(null,arguments)},Module._AvgPool=function(){return(Module._AvgPool=Module.asm.AvgPool).apply(null,arguments)},Module._AvgPool3D=function(){return(Module._AvgPool3D=Module.asm.AvgPool3D).apply(null,arguments)},Module._AvgPool3DGrad=function(){return(Module._AvgPool3DGrad=Module.asm.AvgPool3DGrad).apply(null,arguments)},Module._AvgPoolGrad=function(){return(Module._AvgPoolGrad=Module.asm.AvgPoolGrad).apply(null,arguments)},Module._BatchMatMul=function(){return(Module._BatchMatMul=Module.asm.BatchMatMul).apply(null,arguments)},Module._Bincount=function(){return(Module._Bincount=Module.asm.Bincount).apply(null,arguments)},Module._BitwiseAnd=function(){return(Module._BitwiseAnd=Module.asm.BitwiseAnd).apply(null,arguments)},Module._Ceil=function(){return(Module._Ceil=Module.asm.Ceil).apply(null,arguments)},Module._ClipByValue=function(){return(Module._ClipByValue=Module.asm.ClipByValue).apply(null,arguments)},Module._Conv2D=function(){return(Module._Conv2D=Module.asm.Conv2D).apply(null,arguments)},Module._Conv2DBackpropInput=function(){return(Module._Conv2DBackpropInput=Module.asm.Conv2DBackpropInput).apply(null,arguments)},Module._Conv3D=function(){return(Module._Conv3D=Module.asm.Conv3D).apply(null,arguments)},Module._Conv3DBackpropFilterV2=function(){return(Module._Conv3DBackpropFilterV2=Module.asm.Conv3DBackpropFilterV2).apply(null,arguments)},Module._Conv3DBackpropInputV2=function(){return(Module._Conv3DBackpropInputV2=Module.asm.Conv3DBackpropInputV2).apply(null,arguments)},Module._Cos=function(){return(Module._Cos=Module.asm.Cos).apply(null,arguments)},Module._Cosh=function(){return(Module._Cosh=Module.asm.Cosh).apply(null,arguments)},Module._CropAndResize=function(){return(Module._CropAndResize=Module.asm.CropAndResize).apply(null,arguments)},Module._Cumprod=function(){return(Module._Cumprod=Module.asm.Cumprod).apply(null,arguments)},Module._Cumsum=function(){return(Module._Cumsum=Module.asm.Cumsum).apply(null,arguments)},Module._DenseBincount=function(){return(Module._DenseBincount=Module.asm.DenseBincount).apply(null,arguments)},Module._DepthToSpace=function(){return(Module._DepthToSpace=Module.asm.DepthToSpace).apply(null,arguments)},Module._DepthwiseConv2dNative=function(){return(Module._DepthwiseConv2dNative=Module.asm.DepthwiseConv2dNative).apply(null,arguments)},Module._Diag=function(){return(Module._Diag=Module.asm.Diag).apply(null,arguments)},Module._Dilation2D=function(){return(Module._Dilation2D=Module.asm.Dilation2D).apply(null,arguments)},Module._Dilation2DBackpropFilter=function(){return(Module._Dilation2DBackpropFilter=Module.asm.Dilation2DBackpropFilter).apply(null,arguments)},Module._Dilation2DBackpropInput=function(){return(Module._Dilation2DBackpropInput=Module.asm.Dilation2DBackpropInput).apply(null,arguments)},Module._Elu=function(){return(Module._Elu=Module.asm.Elu).apply(null,arguments)},Module._EluGrad=function(){return(Module._EluGrad=Module.asm.EluGrad).apply(null,arguments)},Module._Equal=function(){return(Module._Equal=Module.asm.Equal).apply(null,arguments)},Module._Erf=function(){return(Module._Erf=Module.asm.Erf).apply(null,arguments)},Module._Exp=function(){return(Module._Exp=Module.asm.Exp).apply(null,arguments)},Module._Expm1=function(){return(Module._Expm1=Module.asm.Expm1).apply(null,arguments)},Module._FlipLeftRight=function(){return(Module._FlipLeftRight=Module.asm.FlipLeftRight).apply(null,arguments)},Module._Floor=function(){return(Module._Floor=Module.asm.Floor).apply(null,arguments)},Module._FloorDiv=function(){return(Module._FloorDiv=Module.asm.FloorDiv).apply(null,arguments)},Module._FusedBatchNorm=function(){return(Module._FusedBatchNorm=Module.asm.FusedBatchNorm).apply(null,arguments)},Module._FusedConv2D=function(){return(Module._FusedConv2D=Module.asm.FusedConv2D).apply(null,arguments)},Module._FusedDepthwiseConv2D=function(){return(Module._FusedDepthwiseConv2D=Module.asm.FusedDepthwiseConv2D).apply(null,arguments)},Module._Gather=function(){return(Module._Gather=Module.asm.Gather).apply(null,arguments)},Module._GatherNd=function(){return(Module._GatherNd=Module.asm.GatherNd).apply(null,arguments)},Module._Greater=function(){return(Module._Greater=Module.asm.Greater).apply(null,arguments)},Module._GreaterEqual=function(){return(Module._GreaterEqual=Module.asm.GreaterEqual).apply(null,arguments)},Module._IsFinite=function(){return(Module._IsFinite=Module.asm.IsFinite).apply(null,arguments)},Module._IsInf=function(){return(Module._IsInf=Module.asm.IsInf).apply(null,arguments)},Module._IsNan=function(){return(Module._IsNan=Module.asm.IsNan).apply(null,arguments)},Module._LRN=function(){return(Module._LRN=Module.asm.LRN).apply(null,arguments)},Module._LRNGrad=function(){return(Module._LRNGrad=Module.asm.LRNGrad).apply(null,arguments)},Module._LeakyRelu=function(){return(Module._LeakyRelu=Module.asm.LeakyRelu).apply(null,arguments)},Module._Less=function(){return(Module._Less=Module.asm.Less).apply(null,arguments)},Module._LessEqual=function(){return(Module._LessEqual=Module.asm.LessEqual).apply(null,arguments)},Module._LinSpace=function(){return(Module._LinSpace=Module.asm.LinSpace).apply(null,arguments)},Module._Log=function(){return(Module._Log=Module.asm.Log).apply(null,arguments)},Module._Log1p=function(){return(Module._Log1p=Module.asm.Log1p).apply(null,arguments)},Module._LogicalAnd=function(){return(Module._LogicalAnd=Module.asm.LogicalAnd).apply(null,arguments)},Module._LogicalNot=function(){return(Module._LogicalNot=Module.asm.LogicalNot).apply(null,arguments)},Module._LogicalOr=function(){return(Module._LogicalOr=Module.asm.LogicalOr).apply(null,arguments)},Module._LogicalXor=function(){return(Module._LogicalXor=Module.asm.LogicalXor).apply(null,arguments)},Module._Max=function(){return(Module._Max=Module.asm.Max).apply(null,arguments)},Module._MaxPool=function(){return(Module._MaxPool=Module.asm.MaxPool).apply(null,arguments)},Module._MaxPool3D=function(){return(Module._MaxPool3D=Module.asm.MaxPool3D).apply(null,arguments)},Module._MaxPool3DGrad=function(){return(Module._MaxPool3DGrad=Module.asm.MaxPool3DGrad).apply(null,arguments)},Module._MaxPoolGrad=function(){return(Module._MaxPoolGrad=Module.asm.MaxPoolGrad).apply(null,arguments)},Module._MaxPoolWithArgmax=function(){return(Module._MaxPoolWithArgmax=Module.asm.MaxPoolWithArgmax).apply(null,arguments)},Module._Maximum=function(){return(Module._Maximum=Module.asm.Maximum).apply(null,arguments)},Module._Mean=function(){return(Module._Mean=Module.asm.Mean).apply(null,arguments)},Module._Min=function(){return(Module._Min=Module.asm.Min).apply(null,arguments)},Module._Minimum=function(){return(Module._Minimum=Module.asm.Minimum).apply(null,arguments)},Module._MirrorPad=function(){return(Module._MirrorPad=Module.asm.MirrorPad).apply(null,arguments)},Module._Mod=function(){return(Module._Mod=Module.asm.Mod).apply(null,arguments)},Module._Multinomial=function(){return(Module._Multinomial=Module.asm.Multinomial).apply(null,arguments)},Module._Multiply=function(){return(Module._Multiply=Module.asm.Multiply).apply(null,arguments)},Module._Neg=function(){return(Module._Neg=Module.asm.Neg).apply(null,arguments)},Module._NonMaxSuppressionV3=function(){return(Module._NonMaxSuppressionV3=Module.asm.NonMaxSuppressionV3).apply(null,arguments)},Module._NonMaxSuppressionV4=function(){return(Module._NonMaxSuppressionV4=Module.asm.NonMaxSuppressionV4).apply(null,arguments)},Module._NonMaxSuppressionV5=function(){return(Module._NonMaxSuppressionV5=Module.asm.NonMaxSuppressionV5).apply(null,arguments)},Module._NotEqual=function(){return(Module._NotEqual=Module.asm.NotEqual).apply(null,arguments)},Module._OneHot=function(){return(Module._OneHot=Module.asm.OneHot).apply(null,arguments)},Module._PadV2=function(){return(Module._PadV2=Module.asm.PadV2).apply(null,arguments)},Module._Pow=function(){return(Module._Pow=Module.asm.Pow).apply(null,arguments)},Module._Prelu=function(){return(Module._Prelu=Module.asm.Prelu).apply(null,arguments)},Module._Prod=function(){return(Module._Prod=Module.asm.Prod).apply(null,arguments)},Module._RealDiv=function(){return(Module._RealDiv=Module.asm.RealDiv).apply(null,arguments)},Module._Reciprocal=function(){return(Module._Reciprocal=Module.asm.Reciprocal).apply(null,arguments)},Module._Relu=function(){return(Module._Relu=Module.asm.Relu).apply(null,arguments)},Module._Relu6=function(){return(Module._Relu6=Module.asm.Relu6).apply(null,arguments)},Module._ResizeBilinear=function(){return(Module._ResizeBilinear=Module.asm.ResizeBilinear).apply(null,arguments)},Module._ResizeBilinearGrad=function(){return(Module._ResizeBilinearGrad=Module.asm.ResizeBilinearGrad).apply(null,arguments)},Module._ResizeNearestNeighbor=function(){return(Module._ResizeNearestNeighbor=Module.asm.ResizeNearestNeighbor).apply(null,arguments)},Module._ResizeNearestNeighborGrad=function(){return(Module._ResizeNearestNeighborGrad=Module.asm.ResizeNearestNeighborGrad).apply(null,arguments)},Module._Reverse=function(){return(Module._Reverse=Module.asm.Reverse).apply(null,arguments)},Module._RotateWithOffset=function(){return(Module._RotateWithOffset=Module.asm.RotateWithOffset).apply(null,arguments)},Module._Round=function(){return(Module._Round=Module.asm.Round).apply(null,arguments)},Module._Rsqrt=function(){return(Module._Rsqrt=Module.asm.Rsqrt).apply(null,arguments)},Module._ScatterNd=function(){return(Module._ScatterNd=Module.asm.ScatterNd).apply(null,arguments)},Module._SearchSorted=function(){return(Module._SearchSorted=Module.asm.SearchSorted).apply(null,arguments)},Module._SelectV2=function(){return(Module._SelectV2=Module.asm.SelectV2).apply(null,arguments)},Module._Selu=function(){return(Module._Selu=Module.asm.Selu).apply(null,arguments)},Module._Sigmoid=function(){return(Module._Sigmoid=Module.asm.Sigmoid).apply(null,arguments)},Module._Sign=function(){return(Module._Sign=Module.asm.Sign).apply(null,arguments)},Module._Sin=function(){return(Module._Sin=Module.asm.Sin).apply(null,arguments)},Module._Sinh=function(){return(Module._Sinh=Module.asm.Sinh).apply(null,arguments)},Module._Softmax=function(){return(Module._Softmax=Module.asm.Softmax).apply(null,arguments)},Module._Softplus=function(){return(Module._Softplus=Module.asm.Softplus).apply(null,arguments)},Module._SparseFillEmptyRows=function(){return(Module._SparseFillEmptyRows=Module.asm.SparseFillEmptyRows).apply(null,arguments)},Module._SparseReshape=function(){return(Module._SparseReshape=Module.asm.SparseReshape).apply(null,arguments)},Module._SparseSegmentReduction=function(){return(Module._SparseSegmentReduction=Module.asm.SparseSegmentReduction).apply(null,arguments)},Module._SparseToDense=function(){return(Module._SparseToDense=Module.asm.SparseToDense).apply(null,arguments)},Module._Sqrt=function(){return(Module._Sqrt=Module.asm.Sqrt).apply(null,arguments)},Module._Square=function(){return(Module._Square=Module.asm.Square).apply(null,arguments)},Module._SquaredDifference=function(){return(Module._SquaredDifference=Module.asm.SquaredDifference).apply(null,arguments)},Module._Step=function(){return(Module._Step=Module.asm.Step).apply(null,arguments)},Module._StridedSlice=function(){return(Module._StridedSlice=Module.asm.StridedSlice).apply(null,arguments)},Module._Sub=function(){return(Module._Sub=Module.asm.Sub).apply(null,arguments)},Module._Sum=function(){return(Module._Sum=Module.asm.Sum).apply(null,arguments)},Module._Tan=function(){return(Module._Tan=Module.asm.Tan).apply(null,arguments)},Module._Tanh=function(){return(Module._Tanh=Module.asm.Tanh).apply(null,arguments)},Module._TensorScatterUpdate=function(){return(Module._TensorScatterUpdate=Module.asm.TensorScatterUpdate).apply(null,arguments)},Module._Tile=function(){return(Module._Tile=Module.asm.Tile).apply(null,arguments)},Module._TopK=function(){return(Module._TopK=Module.asm.TopK).apply(null,arguments)},Module._Transform=function(){return(Module._Transform=Module.asm.Transform).apply(null,arguments)},Module._Transpose=function(){return(Module._Transpose=Module.asm.Transpose).apply(null,arguments)},Module.__FusedMatMul=function(){return(Module.__FusedMatMul=Module.asm._FusedMatMul).apply(null,arguments)},Module._malloc=function(){return(Module._malloc=Module.asm.malloc).apply(null,arguments)},Module._free=function(){return(Module._free=Module.asm.free).apply(null,arguments)},Module.__emscripten_tls_init=function(){return(Module.__emscripten_tls_init=Module.asm._emscripten_tls_init).apply(null,arguments)},Module._pthread_self=function(){return(_pthread_self=Module._pthread_self=Module.asm.pthread_self).apply(null,arguments)}),__emscripten_thread_init=(Module.___errno_location=function(){return(Module.___errno_location=Module.asm.__errno_location).apply(null,arguments)},Module.__emscripten_thread_init=function(){return(__emscripten_thread_init=Module.__emscripten_thread_init=Module.asm._emscripten_thread_init).apply(null,arguments)}),_emscripten_run_in_main_runtime_thread_js=(Module.__emscripten_thread_crashed=function(){return(Module.__emscripten_thread_crashed=Module.asm._emscripten_thread_crashed).apply(null,arguments)},Module._emscripten_main_thread_process_queued_calls=function(){return(Module._emscripten_main_thread_process_queued_calls=Module.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},Module._emscripten_main_browser_thread_id=function(){return(Module._emscripten_main_browser_thread_id=Module.asm.emscripten_main_browser_thread_id).apply(null,arguments)},Module._emscripten_run_in_main_runtime_thread_js=function(){return(_emscripten_run_in_main_runtime_thread_js=Module._emscripten_run_in_main_runtime_thread_js=Module.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)}),__emscripten_proxy_execute_task_queue=(Module._emscripten_dispatch_to_thread_=function(){return(Module._emscripten_dispatch_to_thread_=Module.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},Module.__emscripten_proxy_execute_task_queue=function(){return(__emscripten_proxy_execute_task_queue=Module.__emscripten_proxy_execute_task_queue=Module.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)}),__emscripten_thread_free_data=Module.__emscripten_thread_free_data=function(){return(__emscripten_thread_free_data=Module.__emscripten_thread_free_data=Module.asm._emscripten_thread_free_data).apply(null,arguments)},__emscripten_thread_exit=Module.__emscripten_thread_exit=function(){return(__emscripten_thread_exit=Module.__emscripten_thread_exit=Module.asm._emscripten_thread_exit).apply(null,arguments)},_emscripten_stack_set_limits=Module._emscripten_stack_set_limits=function(){return(_emscripten_stack_set_limits=Module._emscripten_stack_set_limits=Module.asm.emscripten_stack_set_limits).apply(null,arguments)},stackSave=Module.stackSave=function(){return(stackSave=Module.stackSave=Module.asm.stackSave).apply(null,arguments)},stackRestore=Module.stackRestore=function(){return(stackRestore=Module.stackRestore=Module.asm.stackRestore).apply(null,arguments)},stackAlloc=Module.stackAlloc=function(){return(stackAlloc=Module.stackAlloc=Module.asm.stackAlloc).apply(null,arguments)};function run(args){if(args=args||arguments_,!(runDependencies>0)){if(ENVIRONMENT_IS_PTHREAD)return readyPromiseResolve(Module),initRuntime(),void startWorker(Module);!function preRun(){if(Module.preRun)for("function"==typeof Module.preRun&&(Module.preRun=[Module.preRun]);Module.preRun.length;)addOnPreRun(Module.preRun.shift());callRuntimeCallbacks(__ATPRERUN__)}(),runDependencies>0||(Module.setStatus?(Module.setStatus("Running..."),setTimeout(function(){setTimeout(function(){Module.setStatus("")},1),doRun()},1)):doRun())}function doRun(){calledRun||(calledRun=!0,Module.calledRun=!0,ABORT||(initRuntime(),readyPromiseResolve(Module),Module.onRuntimeInitialized&&Module.onRuntimeInitialized(),function postRun(){if(!ENVIRONMENT_IS_PTHREAD){if(Module.postRun)for("function"==typeof Module.postRun&&(Module.postRun=[Module.postRun]);Module.postRun.length;)addOnPostRun(Module.postRun.shift());callRuntimeCallbacks(__ATPOSTRUN__)}}()))}}if(Module.dynCall_iijjiiii=function(){return(Module.dynCall_iijjiiii=Module.asm.dynCall_iijjiiii).apply(null,arguments)},Module.dynCall_jiji=function(){return(Module.dynCall_jiji=Module.asm.dynCall_jiji).apply(null,arguments)},Module.keepRuntimeAlive=keepRuntimeAlive,Module.wasmMemory=wasmMemory,Module.cwrap=function cwrap(ident,returnType,argTypes,opts){var numericArgs=(argTypes=argTypes||[]).every(type=>"number"===type||"boolean"===type);return"string"!==returnType&&numericArgs&&!opts?getCFunc(ident):function(){return ccall(ident,returnType,argTypes,arguments)}},Module.ExitStatus=ExitStatus,Module.PThread=PThread,dependenciesFulfilled=function runCaller(){calledRun||run(),calledRun||(dependenciesFulfilled=runCaller)},Module.preInit)for("function"==typeof Module.preInit&&(Module.preInit=[Module.preInit]);Module.preInit.length>0;)Module.preInit.pop()();if(run(),beforeListeners&&(listenersAdded={uncaughtException:process.listeners("uncaughtException").filter(function(listener){return!beforeListeners.uncaughtException.indexOf(listener)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(listener){return!beforeListeners.unhandledRejection.indexOf(listener)>-1})}),"undefined"!=typeof WasmBackendModule)actualModule=WasmBackendModule;else{if(void 0===WasmBackendModuleThreadedSimd)throw new Error("Could not find wasm module in post.js");actualModule=WasmBackendModuleThreadedSimd}if(listenersAdded){var tmpDispose=actualModule._dispose;actualModule._dispose=function(){tmpDispose(),listenersAdded.uncaughtException.forEach(function(listener){process.removeListener("uncaughtException",listener)}),listenersAdded.unhandledRejection.forEach(function(listener){process.removeListener("unhandledRejection",listener)})}}return WasmBackendModuleThreadedSimd.ready});module.exports=WasmBackendModuleThreadedSimd},"./node_modules/@tensorflow/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm-threaded-simd.worker.js":module=>{module.exports.$='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};'},"./node_modules/@tensorflow/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm.js":(module,__unused_webpack_exports,__webpack_require__)=>{var _scriptDir,process=__webpack_require__("./node_modules/process/browser.js"),console=__webpack_require__("./node_modules/console-browserify/index.js"),WasmBackendModule=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(WasmBackendModule){var readyPromiseResolve,readyPromiseReject,beforeListeners,Module=void 0!==(WasmBackendModule=WasmBackendModule||{})?WasmBackendModule:{};Module.ready=new Promise(function(resolve,reject){readyPromiseResolve=resolve,readyPromiseReject=reject}),void 0!==process&&process.listeners&&(beforeListeners={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var read_,readAsync,readBinary,moduleOverrides=Object.assign({},Module),arguments_=[],ENVIRONMENT_IS_WEB="object"==typeof window,ENVIRONMENT_IS_WORKER="function"==typeof importScripts,ENVIRONMENT_IS_NODE="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,scriptDirectory="";if(ENVIRONMENT_IS_NODE){var fs=__webpack_require__("?ee47"),nodePath=__webpack_require__("?633a");scriptDirectory=ENVIRONMENT_IS_WORKER?nodePath.dirname(scriptDirectory)+"/":"//",read_=(filename,binary)=>(filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename),fs.readFileSync(filename,binary?void 0:"utf8")),readBinary=filename=>{var ret=read_(filename,!0);return ret.buffer||(ret=new Uint8Array(ret)),ret},readAsync=(filename,onload,onerror)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename),fs.readFile(filename,function(err,data){err?onerror(err):onload(data.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),arguments_=process.argv.slice(2),process.on("uncaughtException",function(ex){if(!(ex instanceof ExitStatus))throw ex}),process.on("unhandledRejection",function(reason){throw reason}),Module.inspect=function(){return"[Emscripten Module object]"}}else(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)&&(ENVIRONMENT_IS_WORKER?scriptDirectory=self.location.href:"undefined"!=typeof document&&document.currentScript&&(scriptDirectory=document.currentScript.src),_scriptDir&&(scriptDirectory=_scriptDir),scriptDirectory=0!==scriptDirectory.indexOf("blob:")?scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1):"",read_=url=>{var xhr=new XMLHttpRequest;return xhr.open("GET",url,!1),xhr.send(null),xhr.responseText},ENVIRONMENT_IS_WORKER&&(readBinary=url=>{var xhr=new XMLHttpRequest;return xhr.open("GET",url,!1),xhr.responseType="arraybuffer",xhr.send(null),new Uint8Array(xhr.response)}),readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,!0),xhr.responseType="arraybuffer",xhr.onload=()=>{200==xhr.status||0==xhr.status&&xhr.response?onload(xhr.response):onerror()},xhr.onerror=onerror,xhr.send(null)});var wasmBinary,out=Module.print||console.log.bind(console),err=Module.printErr||console.warn.bind(console);Object.assign(Module,moduleOverrides),moduleOverrides=null,Module.arguments&&(arguments_=Module.arguments),Module.thisProgram&&Module.thisProgram,Module.quit&&Module.quit,Module.wasmBinary&&(wasmBinary=Module.wasmBinary);var wasmMemory;Module.noExitRuntime;"object"!=typeof WebAssembly&&abort("no native wasm support detected");var buffer,HEAP8,HEAPU8,HEAPU32,ABORT=!1,UTF8Decoder="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function UTF8ArrayToString(heapOrArray,idx,maxBytesToRead){for(var endIdx=(idx>>>=0)+maxBytesToRead,endPtr=idx;heapOrArray[endPtr]&&!(endPtr>=endIdx);)++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder)return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr));for(var str="";idx<endPtr;){var u0=heapOrArray[idx++];if(128&u0){var u1=63&heapOrArray[idx++];if(192!=(224&u0)){var u2=63&heapOrArray[idx++];if((u0=224==(240&u0)?(15&u0)<<12|u1<<6|u2:(7&u0)<<18|u1<<12|u2<<6|63&heapOrArray[idx++])<65536)str+=String.fromCharCode(u0);else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|1023&ch)}}else str+=String.fromCharCode((31&u0)<<6|u1)}else str+=String.fromCharCode(u0)}return str}function UTF8ToString(ptr,maxBytesToRead){return(ptr>>>=0)?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function updateGlobalBufferAndViews(buf){buffer=buf,Module.HEAP8=HEAP8=new Int8Array(buf),Module.HEAP16=new Int16Array(buf),Module.HEAP32=new Int32Array(buf),Module.HEAPU8=HEAPU8=new Uint8Array(buf),Module.HEAPU16=new Uint16Array(buf),Module.HEAPU32=HEAPU32=new Uint32Array(buf),Module.HEAPF32=new Float32Array(buf),Module.HEAPF64=new Float64Array(buf)}Module.INITIAL_MEMORY;var __ATPRERUN__=[],__ATINIT__=[],__ATPOSTRUN__=[];function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var wasmBinaryFile,runDependencies=0,runDependencyWatcher=null,dependenciesFulfilled=null;function abort(what){Module.onAbort&&Module.onAbort(what),err(what="Aborted("+what+")"),ABORT=!0,what+=". Build with -sASSERTIONS for more info.";var e=new WebAssembly.RuntimeError(what);throw readyPromiseReject(e),e}function isDataURI(filename){return filename.startsWith("data:application/octet-stream;base64,")}function isFileURI(filename){return filename.startsWith("file://")}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary)return new Uint8Array(wasmBinary);if(readBinary)return readBinary(file);throw"both async and sync fetching of the wasm failed"}catch(err){abort(err)}}function ExitStatus(status){this.name="ExitStatus",this.message="Program terminated with exit("+status+")",this.status=status}function callRuntimeCallbacks(callbacks){for(;callbacks.length>0;)callbacks.shift()(Module)}function emscripten_realloc_buffer(size){try{return wasmMemory.grow(size-buffer.byteLength+65535>>>16),updateGlobalBufferAndViews(wasmMemory.buffer),1}catch(e){}}isDataURI(wasmBinaryFile="tfjs-backend-wasm.wasm")||(wasmBinaryFile=function locateFile(path){return Module.locateFile?Module.locateFile(path,scriptDirectory):scriptDirectory+path}(wasmBinaryFile));var printCharBuffers=[null,[],[]];function printChar(stream,curr){var buffer=printCharBuffers[stream];0===curr||10===curr?((1===stream?out:err)(UTF8ArrayToString(buffer,0)),buffer.length=0):buffer.push(curr)}function getCFunc(ident){return Module["_"+ident]}function ccall(ident,returnType,argTypes,args,opts){var toC={string:str=>{var ret=0;if(null!=str&&0!==str){var len=1+(str.length<<2);!function stringToUTF8(str,outPtr,maxBytesToWrite){return function stringToUTF8Array(str,heap,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;for(var startIdx=outIdx>>>=0,endIdx=outIdx+maxBytesToWrite-1,i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343&&(u=65536+((1023&u)<<10)|1023&str.charCodeAt(++i)),u<=127){if(outIdx>=endIdx)break;heap[outIdx++>>>0]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++>>>0]=192|u>>6,heap[outIdx++>>>0]=128|63&u}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++>>>0]=224|u>>12,heap[outIdx++>>>0]=128|u>>6&63,heap[outIdx++>>>0]=128|63&u}else{if(outIdx+3>=endIdx)break;heap[outIdx++>>>0]=240|u>>18,heap[outIdx++>>>0]=128|u>>12&63,heap[outIdx++>>>0]=128|u>>6&63,heap[outIdx++>>>0]=128|63&u}}return heap[outIdx>>>0]=0,outIdx-startIdx}(str,HEAPU8,outPtr,maxBytesToWrite)}(str,ret=stackAlloc(len),len)}return ret},array:arr=>{var ret=stackAlloc(arr.length);return function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer>>>0)}(arr,ret),ret}},func=getCFunc(ident),cArgs=[],stack=0;if(args)for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];converter?(0===stack&&(stack=stackSave()),cArgs[i]=converter(args[i])):cArgs[i]=args[i]}var ret=func.apply(null,cArgs);return ret=function onDone(ret){return 0!==stack&&stackRestore(stack),function convertReturnValue(ret){return"string"===returnType?UTF8ToString(ret):"boolean"===returnType?Boolean(ret):ret}(ret)}(ret)}var calledRun,listenersAdded,actualModule,asmLibraryArg={abort:function _abort(){abort("")},emscripten_get_heap_max:function _emscripten_get_heap_max(){return 4294901760},emscripten_memcpy_big:function _emscripten_memcpy_big(dest,src,num){HEAPU8.copyWithin(dest>>>0,src>>>0,src+num>>>0)},emscripten_resize_heap:function _emscripten_resize_heap(requestedSize){var oldSize=HEAPU8.length;if((requestedSize>>>=0)>4294901760)return!1;let alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);if(overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296),emscripten_realloc_buffer(Math.min(4294901760,alignUp(Math.max(requestedSize,overGrownHeapSize),65536))))return!0}return!1},fd_close:function _fd_close(fd){return 52},fd_seek:function _fd_seek(fd,offset_low,offset_high,whence,newOffset){return 70},fd_write:function _fd_write(fd,iov,iovcnt,pnum){for(var num=0,i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>>2],len=HEAPU32[iov+4>>>2];iov+=8;for(var j=0;j<len;j++)printChar(fd,HEAPU8[ptr+j>>>0]);num+=len}return HEAPU32[pnum>>>2]=num,0}},stackSave=(function createWasm(){var info={env:asmLibraryArg,wasi_snapshot_preview1:asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module.asm=exports,updateGlobalBufferAndViews((wasmMemory=Module.asm.memory).buffer),Module.asm.__indirect_function_table,function addOnInit(cb){__ATINIT__.unshift(cb)}(Module.asm.__wasm_call_ctors),function removeRunDependency(id){if(runDependencies--,Module.monitorRunDependencies&&Module.monitorRunDependencies(runDependencies),0==runDependencies&&(null!==runDependencyWatcher&&(clearInterval(runDependencyWatcher),runDependencyWatcher=null),dependenciesFulfilled)){var callback=dependenciesFulfilled;dependenciesFulfilled=null,callback()}}()}function receiveInstantiationResult(result){receiveInstance(result.instance)}function instantiateArrayBuffer(receiver){return function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if("function"==typeof fetch&&!isFileURI(wasmBinaryFile))return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response.ok)throw"failed to load wasm binary file at '"+wasmBinaryFile+"'";return response.arrayBuffer()}).catch(function(){return getBinary(wasmBinaryFile)});if(readAsync)return new Promise(function(resolve,reject){readAsync(wasmBinaryFile,function(response){resolve(new Uint8Array(response))},reject)})}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(function(instance){return instance}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason),abort(reason)})}if(function addRunDependency(id){runDependencies++,Module.monitorRunDependencies&&Module.monitorRunDependencies(runDependencies)}(),Module.instantiateWasm)try{return Module.instantiateWasm(info,receiveInstance)}catch(e){err("Module.instantiateWasm callback failed with error: "+e),readyPromiseReject(e)}return function instantiateAsync(){return wasmBinary||"function"!=typeof WebAssembly.instantiateStreaming||isDataURI(wasmBinaryFile)||isFileURI(wasmBinaryFile)||ENVIRONMENT_IS_NODE||"function"!=typeof fetch?instantiateArrayBuffer(receiveInstantiationResult):fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){return WebAssembly.instantiateStreaming(response,info).then(receiveInstantiationResult,function(reason){return err("wasm streaming compile failed: "+reason),err("falling back to ArrayBuffer instantiation"),instantiateArrayBuffer(receiveInstantiationResult)})})}().catch(readyPromiseReject),{}}(),Module.___wasm_call_ctors=function(){return(Module.___wasm_call_ctors=Module.asm.__wasm_call_ctors).apply(null,arguments)},Module._init=function(){return(Module._init=Module.asm.init).apply(null,arguments)},Module._init_with_threads_count=function(){return(Module._init_with_threads_count=Module.asm.init_with_threads_count).apply(null,arguments)},Module._get_threads_count=function(){return(Module._get_threads_count=Module.asm.get_threads_count).apply(null,arguments)},Module._register_tensor=function(){return(Module._register_tensor=Module.asm.register_tensor).apply(null,arguments)},Module._dispose_data=function(){return(Module._dispose_data=Module.asm.dispose_data).apply(null,arguments)},Module._dispose=function(){return(Module._dispose=Module.asm.dispose).apply(null,arguments)},Module._Abs=function(){return(Module._Abs=Module.asm.Abs).apply(null,arguments)},Module._Acos=function(){return(Module._Acos=Module.asm.Acos).apply(null,arguments)},Module._Acosh=function(){return(Module._Acosh=Module.asm.Acosh).apply(null,arguments)},Module._Add=function(){return(Module._Add=Module.asm.Add).apply(null,arguments)},Module._AddN=function(){return(Module._AddN=Module.asm.AddN).apply(null,arguments)},Module._All=function(){return(Module._All=Module.asm.All).apply(null,arguments)},Module._Any=function(){return(Module._Any=Module.asm.Any).apply(null,arguments)},Module._ArgMax=function(){return(Module._ArgMax=Module.asm.ArgMax).apply(null,arguments)},Module._ArgMin=function(){return(Module._ArgMin=Module.asm.ArgMin).apply(null,arguments)},Module._Asin=function(){return(Module._Asin=Module.asm.Asin).apply(null,arguments)},Module._Asinh=function(){return(Module._Asinh=Module.asm.Asinh).apply(null,arguments)},Module._Atan=function(){return(Module._Atan=Module.asm.Atan).apply(null,arguments)},Module._Atan2=function(){return(Module._Atan2=Module.asm.Atan2).apply(null,arguments)},Module._Atanh=function(){return(Module._Atanh=Module.asm.Atanh).apply(null,arguments)},Module._AvgPool=function(){return(Module._AvgPool=Module.asm.AvgPool).apply(null,arguments)},Module._AvgPool3D=function(){return(Module._AvgPool3D=Module.asm.AvgPool3D).apply(null,arguments)},Module._AvgPool3DGrad=function(){return(Module._AvgPool3DGrad=Module.asm.AvgPool3DGrad).apply(null,arguments)},Module._AvgPoolGrad=function(){return(Module._AvgPoolGrad=Module.asm.AvgPoolGrad).apply(null,arguments)},Module._BatchMatMul=function(){return(Module._BatchMatMul=Module.asm.BatchMatMul).apply(null,arguments)},Module._Bincount=function(){return(Module._Bincount=Module.asm.Bincount).apply(null,arguments)},Module._BitwiseAnd=function(){return(Module._BitwiseAnd=Module.asm.BitwiseAnd).apply(null,arguments)},Module._Ceil=function(){return(Module._Ceil=Module.asm.Ceil).apply(null,arguments)},Module._ClipByValue=function(){return(Module._ClipByValue=Module.asm.ClipByValue).apply(null,arguments)},Module._Conv2D=function(){return(Module._Conv2D=Module.asm.Conv2D).apply(null,arguments)},Module._Conv2DBackpropInput=function(){return(Module._Conv2DBackpropInput=Module.asm.Conv2DBackpropInput).apply(null,arguments)},Module._Conv3D=function(){return(Module._Conv3D=Module.asm.Conv3D).apply(null,arguments)},Module._Conv3DBackpropFilterV2=function(){return(Module._Conv3DBackpropFilterV2=Module.asm.Conv3DBackpropFilterV2).apply(null,arguments)},Module._Conv3DBackpropInputV2=function(){return(Module._Conv3DBackpropInputV2=Module.asm.Conv3DBackpropInputV2).apply(null,arguments)},Module._Cos=function(){return(Module._Cos=Module.asm.Cos).apply(null,arguments)},Module._Cosh=function(){return(Module._Cosh=Module.asm.Cosh).apply(null,arguments)},Module._CropAndResize=function(){return(Module._CropAndResize=Module.asm.CropAndResize).apply(null,arguments)},Module._Cumprod=function(){return(Module._Cumprod=Module.asm.Cumprod).apply(null,arguments)},Module._Cumsum=function(){return(Module._Cumsum=Module.asm.Cumsum).apply(null,arguments)},Module._DenseBincount=function(){return(Module._DenseBincount=Module.asm.DenseBincount).apply(null,arguments)},Module._DepthToSpace=function(){return(Module._DepthToSpace=Module.asm.DepthToSpace).apply(null,arguments)},Module._DepthwiseConv2dNative=function(){return(Module._DepthwiseConv2dNative=Module.asm.DepthwiseConv2dNative).apply(null,arguments)},Module._Diag=function(){return(Module._Diag=Module.asm.Diag).apply(null,arguments)},Module._Dilation2D=function(){return(Module._Dilation2D=Module.asm.Dilation2D).apply(null,arguments)},Module._Dilation2DBackpropFilter=function(){return(Module._Dilation2DBackpropFilter=Module.asm.Dilation2DBackpropFilter).apply(null,arguments)},Module._Dilation2DBackpropInput=function(){return(Module._Dilation2DBackpropInput=Module.asm.Dilation2DBackpropInput).apply(null,arguments)},Module._Elu=function(){return(Module._Elu=Module.asm.Elu).apply(null,arguments)},Module._EluGrad=function(){return(Module._EluGrad=Module.asm.EluGrad).apply(null,arguments)},Module._Equal=function(){return(Module._Equal=Module.asm.Equal).apply(null,arguments)},Module._Erf=function(){return(Module._Erf=Module.asm.Erf).apply(null,arguments)},Module._Exp=function(){return(Module._Exp=Module.asm.Exp).apply(null,arguments)},Module._Expm1=function(){return(Module._Expm1=Module.asm.Expm1).apply(null,arguments)},Module._FlipLeftRight=function(){return(Module._FlipLeftRight=Module.asm.FlipLeftRight).apply(null,arguments)},Module._Floor=function(){return(Module._Floor=Module.asm.Floor).apply(null,arguments)},Module._FloorDiv=function(){return(Module._FloorDiv=Module.asm.FloorDiv).apply(null,arguments)},Module._FusedBatchNorm=function(){return(Module._FusedBatchNorm=Module.asm.FusedBatchNorm).apply(null,arguments)},Module._FusedConv2D=function(){return(Module._FusedConv2D=Module.asm.FusedConv2D).apply(null,arguments)},Module._FusedDepthwiseConv2D=function(){return(Module._FusedDepthwiseConv2D=Module.asm.FusedDepthwiseConv2D).apply(null,arguments)},Module._Gather=function(){return(Module._Gather=Module.asm.Gather).apply(null,arguments)},Module._GatherNd=function(){return(Module._GatherNd=Module.asm.GatherNd).apply(null,arguments)},Module._Greater=function(){return(Module._Greater=Module.asm.Greater).apply(null,arguments)},Module._GreaterEqual=function(){return(Module._GreaterEqual=Module.asm.GreaterEqual).apply(null,arguments)},Module._IsFinite=function(){return(Module._IsFinite=Module.asm.IsFinite).apply(null,arguments)},Module._IsInf=function(){return(Module._IsInf=Module.asm.IsInf).apply(null,arguments)},Module._IsNan=function(){return(Module._IsNan=Module.asm.IsNan).apply(null,arguments)},Module._LRN=function(){return(Module._LRN=Module.asm.LRN).apply(null,arguments)},Module._LRNGrad=function(){return(Module._LRNGrad=Module.asm.LRNGrad).apply(null,arguments)},Module._LeakyRelu=function(){return(Module._LeakyRelu=Module.asm.LeakyRelu).apply(null,arguments)},Module._Less=function(){return(Module._Less=Module.asm.Less).apply(null,arguments)},Module._LessEqual=function(){return(Module._LessEqual=Module.asm.LessEqual).apply(null,arguments)},Module._LinSpace=function(){return(Module._LinSpace=Module.asm.LinSpace).apply(null,arguments)},Module._Log=function(){return(Module._Log=Module.asm.Log).apply(null,arguments)},Module._Log1p=function(){return(Module._Log1p=Module.asm.Log1p).apply(null,arguments)},Module._LogicalAnd=function(){return(Module._LogicalAnd=Module.asm.LogicalAnd).apply(null,arguments)},Module._LogicalNot=function(){return(Module._LogicalNot=Module.asm.LogicalNot).apply(null,arguments)},Module._LogicalOr=function(){return(Module._LogicalOr=Module.asm.LogicalOr).apply(null,arguments)},Module._LogicalXor=function(){return(Module._LogicalXor=Module.asm.LogicalXor).apply(null,arguments)},Module._Max=function(){return(Module._Max=Module.asm.Max).apply(null,arguments)},Module._MaxPool=function(){return(Module._MaxPool=Module.asm.MaxPool).apply(null,arguments)},Module._MaxPool3D=function(){return(Module._MaxPool3D=Module.asm.MaxPool3D).apply(null,arguments)},Module._MaxPool3DGrad=function(){return(Module._MaxPool3DGrad=Module.asm.MaxPool3DGrad).apply(null,arguments)},Module._MaxPoolGrad=function(){return(Module._MaxPoolGrad=Module.asm.MaxPoolGrad).apply(null,arguments)},Module._MaxPoolWithArgmax=function(){return(Module._MaxPoolWithArgmax=Module.asm.MaxPoolWithArgmax).apply(null,arguments)},Module._Maximum=function(){return(Module._Maximum=Module.asm.Maximum).apply(null,arguments)},Module._Mean=function(){return(Module._Mean=Module.asm.Mean).apply(null,arguments)},Module._Min=function(){return(Module._Min=Module.asm.Min).apply(null,arguments)},Module._Minimum=function(){return(Module._Minimum=Module.asm.Minimum).apply(null,arguments)},Module._MirrorPad=function(){return(Module._MirrorPad=Module.asm.MirrorPad).apply(null,arguments)},Module._Mod=function(){return(Module._Mod=Module.asm.Mod).apply(null,arguments)},Module._Multinomial=function(){return(Module._Multinomial=Module.asm.Multinomial).apply(null,arguments)},Module._Multiply=function(){return(Module._Multiply=Module.asm.Multiply).apply(null,arguments)},Module._Neg=function(){return(Module._Neg=Module.asm.Neg).apply(null,arguments)},Module._NonMaxSuppressionV3=function(){return(Module._NonMaxSuppressionV3=Module.asm.NonMaxSuppressionV3).apply(null,arguments)},Module._NonMaxSuppressionV4=function(){return(Module._NonMaxSuppressionV4=Module.asm.NonMaxSuppressionV4).apply(null,arguments)},Module._NonMaxSuppressionV5=function(){return(Module._NonMaxSuppressionV5=Module.asm.NonMaxSuppressionV5).apply(null,arguments)},Module._NotEqual=function(){return(Module._NotEqual=Module.asm.NotEqual).apply(null,arguments)},Module._OneHot=function(){return(Module._OneHot=Module.asm.OneHot).apply(null,arguments)},Module._PadV2=function(){return(Module._PadV2=Module.asm.PadV2).apply(null,arguments)},Module._Pow=function(){return(Module._Pow=Module.asm.Pow).apply(null,arguments)},Module._Prelu=function(){return(Module._Prelu=Module.asm.Prelu).apply(null,arguments)},Module._Prod=function(){return(Module._Prod=Module.asm.Prod).apply(null,arguments)},Module._RealDiv=function(){return(Module._RealDiv=Module.asm.RealDiv).apply(null,arguments)},Module._Reciprocal=function(){return(Module._Reciprocal=Module.asm.Reciprocal).apply(null,arguments)},Module._Relu=function(){return(Module._Relu=Module.asm.Relu).apply(null,arguments)},Module._Relu6=function(){return(Module._Relu6=Module.asm.Relu6).apply(null,arguments)},Module._ResizeBilinear=function(){return(Module._ResizeBilinear=Module.asm.ResizeBilinear).apply(null,arguments)},Module._ResizeBilinearGrad=function(){return(Module._ResizeBilinearGrad=Module.asm.ResizeBilinearGrad).apply(null,arguments)},Module._ResizeNearestNeighbor=function(){return(Module._ResizeNearestNeighbor=Module.asm.ResizeNearestNeighbor).apply(null,arguments)},Module._ResizeNearestNeighborGrad=function(){return(Module._ResizeNearestNeighborGrad=Module.asm.ResizeNearestNeighborGrad).apply(null,arguments)},Module._Reverse=function(){return(Module._Reverse=Module.asm.Reverse).apply(null,arguments)},Module._RotateWithOffset=function(){return(Module._RotateWithOffset=Module.asm.RotateWithOffset).apply(null,arguments)},Module._Round=function(){return(Module._Round=Module.asm.Round).apply(null,arguments)},Module._Rsqrt=function(){return(Module._Rsqrt=Module.asm.Rsqrt).apply(null,arguments)},Module._ScatterNd=function(){return(Module._ScatterNd=Module.asm.ScatterNd).apply(null,arguments)},Module._SearchSorted=function(){return(Module._SearchSorted=Module.asm.SearchSorted).apply(null,arguments)},Module._SelectV2=function(){return(Module._SelectV2=Module.asm.SelectV2).apply(null,arguments)},Module._Selu=function(){return(Module._Selu=Module.asm.Selu).apply(null,arguments)},Module._Sigmoid=function(){return(Module._Sigmoid=Module.asm.Sigmoid).apply(null,arguments)},Module._Sign=function(){return(Module._Sign=Module.asm.Sign).apply(null,arguments)},Module._Sin=function(){return(Module._Sin=Module.asm.Sin).apply(null,arguments)},Module._Sinh=function(){return(Module._Sinh=Module.asm.Sinh).apply(null,arguments)},Module._Softmax=function(){return(Module._Softmax=Module.asm.Softmax).apply(null,arguments)},Module._Softplus=function(){return(Module._Softplus=Module.asm.Softplus).apply(null,arguments)},Module._SparseFillEmptyRows=function(){return(Module._SparseFillEmptyRows=Module.asm.SparseFillEmptyRows).apply(null,arguments)},Module._SparseReshape=function(){return(Module._SparseReshape=Module.asm.SparseReshape).apply(null,arguments)},Module._SparseSegmentReduction=function(){return(Module._SparseSegmentReduction=Module.asm.SparseSegmentReduction).apply(null,arguments)},Module._SparseToDense=function(){return(Module._SparseToDense=Module.asm.SparseToDense).apply(null,arguments)},Module._Sqrt=function(){return(Module._Sqrt=Module.asm.Sqrt).apply(null,arguments)},Module._Square=function(){return(Module._Square=Module.asm.Square).apply(null,arguments)},Module._SquaredDifference=function(){return(Module._SquaredDifference=Module.asm.SquaredDifference).apply(null,arguments)},Module._Step=function(){return(Module._Step=Module.asm.Step).apply(null,arguments)},Module._StridedSlice=function(){return(Module._StridedSlice=Module.asm.StridedSlice).apply(null,arguments)},Module._Sub=function(){return(Module._Sub=Module.asm.Sub).apply(null,arguments)},Module._Sum=function(){return(Module._Sum=Module.asm.Sum).apply(null,arguments)},Module._Tan=function(){return(Module._Tan=Module.asm.Tan).apply(null,arguments)},Module._Tanh=function(){return(Module._Tanh=Module.asm.Tanh).apply(null,arguments)},Module._TensorScatterUpdate=function(){return(Module._TensorScatterUpdate=Module.asm.TensorScatterUpdate).apply(null,arguments)},Module._Tile=function(){return(Module._Tile=Module.asm.Tile).apply(null,arguments)},Module._TopK=function(){return(Module._TopK=Module.asm.TopK).apply(null,arguments)},Module._Transform=function(){return(Module._Transform=Module.asm.Transform).apply(null,arguments)},Module._Transpose=function(){return(Module._Transpose=Module.asm.Transpose).apply(null,arguments)},Module.__FusedMatMul=function(){return(Module.__FusedMatMul=Module.asm._FusedMatMul).apply(null,arguments)},Module._malloc=function(){return(Module._malloc=Module.asm.malloc).apply(null,arguments)},Module._free=function(){return(Module._free=Module.asm.free).apply(null,arguments)},Module.___errno_location=function(){return(Module.___errno_location=Module.asm.__errno_location).apply(null,arguments)},Module.stackSave=function(){return(stackSave=Module.stackSave=Module.asm.stackSave).apply(null,arguments)}),stackRestore=Module.stackRestore=function(){return(stackRestore=Module.stackRestore=Module.asm.stackRestore).apply(null,arguments)},stackAlloc=Module.stackAlloc=function(){return(stackAlloc=Module.stackAlloc=Module.asm.stackAlloc).apply(null,arguments)};function run(args){function doRun(){calledRun||(calledRun=!0,Module.calledRun=!0,ABORT||(function initRuntime(){callRuntimeCallbacks(__ATINIT__)}(),readyPromiseResolve(Module),Module.onRuntimeInitialized&&Module.onRuntimeInitialized(),function postRun(){if(Module.postRun)for("function"==typeof Module.postRun&&(Module.postRun=[Module.postRun]);Module.postRun.length;)addOnPostRun(Module.postRun.shift());callRuntimeCallbacks(__ATPOSTRUN__)}()))}args=args||arguments_,runDependencies>0||(function preRun(){if(Module.preRun)for("function"==typeof Module.preRun&&(Module.preRun=[Module.preRun]);Module.preRun.length;)addOnPreRun(Module.preRun.shift());callRuntimeCallbacks(__ATPRERUN__)}(),runDependencies>0||(Module.setStatus?(Module.setStatus("Running..."),setTimeout(function(){setTimeout(function(){Module.setStatus("")},1),doRun()},1)):doRun()))}if(Module.dynCall_iijjiiii=function(){return(Module.dynCall_iijjiiii=Module.asm.dynCall_iijjiiii).apply(null,arguments)},Module.dynCall_jiji=function(){return(Module.dynCall_jiji=Module.asm.dynCall_jiji).apply(null,arguments)},Module.cwrap=function cwrap(ident,returnType,argTypes,opts){var numericArgs=(argTypes=argTypes||[]).every(type=>"number"===type||"boolean"===type);return"string"!==returnType&&numericArgs&&!opts?getCFunc(ident):function(){return ccall(ident,returnType,argTypes,arguments)}},dependenciesFulfilled=function runCaller(){calledRun||run(),calledRun||(dependenciesFulfilled=runCaller)},Module.preInit)for("function"==typeof Module.preInit&&(Module.preInit=[Module.preInit]);Module.preInit.length>0;)Module.preInit.pop()();if(run(),beforeListeners&&(listenersAdded={uncaughtException:process.listeners("uncaughtException").filter(function(listener){return!beforeListeners.uncaughtException.indexOf(listener)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(listener){return!beforeListeners.unhandledRejection.indexOf(listener)>-1})}),void 0!==WasmBackendModule)actualModule=WasmBackendModule;else{if("undefined"==typeof WasmBackendModuleThreadedSimd)throw new Error("Could not find wasm module in post.js");actualModule=WasmBackendModuleThreadedSimd}if(listenersAdded){var tmpDispose=actualModule._dispose;actualModule._dispose=function(){tmpDispose(),listenersAdded.uncaughtException.forEach(function(listener){process.removeListener("uncaughtException",listener)}),listenersAdded.unhandledRejection.forEach(function(listener){process.removeListener("unhandledRejection",listener)})}}return WasmBackendModule.ready});module.exports=WasmBackendModule}}]);